{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5e8f\u8a00","text":"<p>\u5728\u8fd9\u91cc\u67e5\u770b\u5b8c\u6574\u6587\u6863 mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>=== \"C\"</p> <pre><code>C language\n</code></pre> <p>=== \"C++\"</p> <pre><code>C++ Language\n</code></pre>"},{"location":"broken/c-static-linking/","title":"\u9759\u6001\u94fe\u63a5","text":"<p>\u5728\u672c\u6b21\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u4e86\u89e3\u9759\u6001\u94fe\u63a5\u548cC\u8bed\u8a00\u4e2d\u7684\u5730\u5740\u5206\u914d\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002</p>"},{"location":"broken/c-static-linking/#ucore","title":"\u7406\u89e3 uCore \u662f\u5982\u4f55\u6784\u5efa\u7684","text":"<p>\u5f53\u6211\u4eec\u5728 uCore \u76ee\u5f55\u4e0b\u6267\u884c <code>make</code> \u7f16\u8bd1\u5185\u6838\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf make \u5de5\u5177\u662f\u5982\u4f55\u8c03\u7528\u7f16\u8bd1\u5de5\u5177\u94fe\u7684\uff1a</p> <pre><code>$ make\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/console.c -o build/os/console.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/kalloc.c -o build/os/kalloc.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/loader.c -o build/os/loader.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/main.c -o build/os/main.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/printf.c -o build/os/printf.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/proc.c -o build/os/proc.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/queue.c -o build/os/queue.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/sbi.c -o build/os/sbi.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/string.c -o build/os/string.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/syscall.c -o build/os/syscall.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/timer.c -o build/os/timer.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/trap.c -o build/os/trap.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/vm.c -o build/os/vm.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/entry.S -o build/os/entry.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/switch.S -o build/os/switch.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/trampoline.S -o build/os/trampoline.o\nriscv64-unknown-elf-gcc {Compiler_Flags} -c os/link_app.S -o build/os/link_app.o\nriscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/kalloc.o build/os/loader.o build/os/main.o build/os/printf.o build/os/proc.o build/os/queue.o build/os/sbi.o build/os/string.o build/os/syscall.o build/os/timer.o build/os/trap.o build/os/vm.o build/os/entry.o build/os/switch.o build/os/trampoline.o build/os/link_app.o\nriscv64-unknown-elf-objcopy -O binary build/kernel build/kernel.bin\nriscv64-unknown-elf-objdump -S build/kernel &gt; build/kernel.asm\nriscv64-unknown-elf-objdump -t build/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; build/kernel.sym\nBuild kernel done\n</code></pre> <p>\u9996\u5148\uff0cmake \u4f1a\u8c03\u7528 gcc \u5bf9\u6240\u6709\u7684 .c \u548c .S \u6e90\u4ee3\u7801\u8fdb\u884c\u7f16\u8bd1 (-c xxx.c)\uff0c\u751f\u6210 .o \u7684 Relocatable object file (-o xxx.o)\u3002 \u7136\u540e\uff0cmake \u4f1a\u8c03\u7528 ld \u94fe\u63a5\u6240\u6709\u7684 .o \u6587\u4ef6\uff0c\u5e76\u4e14\u6307\u5b9a\u4e86\u4f7f\u7528 os/kernel.ld \u4f5c\u4e3a\u94fe\u63a5\u811a\u672c\uff0c\u751f\u6210\u5185\u6838\u7684 ELF \u6587\u4ef6 kernel (-o build/kernel)\u3002</p> <p>\u94fe\u63a5\u811a\u672c (Linker Script) \u6307\u5b9a\u4e86\u94fe\u63a5\u5668 ld \u5e94\u8be5\u5982\u4f55\u6392\u5e03\u6240\u6709 Object File \u4e2d\u7684\u7b26\u53f7\uff0c\u5e76\u751f\u6210\u6700\u7ec8\u7684 ELF \u6587\u4ef6\u3002</p> <pre><code>OUTPUT_ARCH(riscv)\nENTRY(_entry)\nBASE_ADDRESS = 0x80200000;\n\nSECTIONS\n{\n    . = BASE_ADDRESS;\n    skernel = .;\n\n    s_text = .;\n    .text : {\n        *(.text.entry)\n        *(.text .text.*)\n        . = ALIGN(0x1000);\n        *(trampsec)\n        . = ALIGN(0x1000);\n    }\n\n    . = ALIGN(4K);\n    e_text = .;\n    s_rodata = .;\n    .rodata : {\n        *(.rodata .rodata.*)\n    }\n\n    . = ALIGN(4K);\n    e_rodata = .;\n    s_data = .;\n    .data : {\n        *(.data.apps)\n        *(.data .data.*)\n        *(.sdata .sdata.*)\n    }\n\n    . = ALIGN(4K);\n    e_data = .;\n    .bss : {\n        *(.bss.stack)\n        s_bss = .;\n        *(.bss .bss.*)\n        *(.sbss .sbss.*)\n    }\n\n    . = ALIGN(4K);\n    e_bss = .;\n    ekernel = .;\n\n    /DISCARD/ : {\n        *(.eh_frame)\n    }\n}\n</code></pre> <p>\u5728 Linker Script \u4e2d\uff0c\u6211\u4eec\u9996\u5148\u6307\u5b9a\u4e86\u8f93\u51fa ELF \u7684\u67b6\u6784\u662f RISC-V \u67b6\u6784\uff0c\u5165\u53e3\u51fd\u6570\u4e3a _entry \u7b26\u53f7\uff0c\u5e76\u5b9a\u4e49\u4e86 ELF \u7684\u57fa\u5730\u5740\u4e3a 0x80200000\u3002</p> <p>\u5728\u540e\u7eed\u7684 SECTIONS \u4e2d\uff0c\u6211\u4eec\u9996\u5148\u6307\u5b9a\u4e86\u5f53\u524d\u4f4d\u7f6e\u4e3a BASE_ADDRESS\uff1a<code>. = BASE_ADDRESS;</code>\uff0c\u5e76\u5b9a\u4e49\u4e86 <code>skernel</code> \u8fd9\u4e2a\u7b26\u53f7\u6307\u5411\u5f53\u524d\u5730\u5740\u3002</p> <p>\u7136\u540e\uff0c\u6211\u4eec\u6307\u5b9a\u4e86\u5982\u4f55\u6392\u5e03 text, rodata, data, bss \u7b49 Section\uff0c\u5e76\u5728\u4e0d\u540c\u7684 Section \u4e4b\u95f4\u4f7f\u7528 <code>. = ALIGN(4K)</code> \u786e\u4fddSection\u7684\u5f00\u59cb\u5730\u5740\u5bf9\u9f50\u5230\u4e86 4096 bytes \u7684\u8fb9\u754c\u3002\u6211\u4eec\u4e5f\u6307\u5b9a\u4e86 <code>skernel</code>\u3001<code>s_text</code>\u3001<code>e_text</code> \u7b49\u7b26\u53f7\u7684\u503c\uff0c\u8fd9\u4e9b\u503c\u5728\u540e\u7eed\u5185\u6838\u4e2d\u521d\u59cb\u5316\u5185\u6838\u7684\u9875\u8868\u4e2d\u4f1a\u88ab\u4f7f\u7528\u5230\u3002</p> <p>\u4f8b\u5982\uff0c\u6211\u4eec\u5728 <code>.text</code> \u6bb5\u4e2d\u9996\u5148\u5305\u542b\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684 Section <code>.text.entry</code>\uff0c\u8fd9\u4e2a section \u662f\u5728 <code>entry.S</code> \u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\uff1a</p> <pre><code>    .section .text.entry\n    .globl _entry\n_entry:\n</code></pre> <p>\u6211\u4eec\u5728 <code>entry.S</code> \u6587\u4ef6\u4e2d\u6307\u5b9a <code>_entry</code> \u7b26\u53f7\u5e94\u8be5\u88ab\u653e\u7f6e\u5230 <code>.text.entry</code> \u6bb5\uff0c\u5e76\u5728\u94fe\u63a5\u811a\u672c\u4e2d\u6307\u5b9a\u8fd9\u4e2a\u6bb5\u4e3a\u5185\u6838\u7684\u5f00\u59cb\u5730\u5740\u3002\u8fd9\u6837\u6211\u4eec\u5373\u53ef\u786e\u4fdd _entry \u4f1a\u88ab\u653e\u7f6e\u5230\u5185\u6838\u8d77\u59cb\u5730\u5740\u3002\u5f53\u6211\u4eec\u542f\u52a8\u5185\u6838\u65f6\uff0c\u6211\u4eec\u4f1a\u4ece\u8fd9\u4e2a\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u6267\u884c\uff0c\u4e5f\u5c31\u662f\u6267\u884c\u4e86\u5185\u6838\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u53cd\u7f16\u8bd1 <code>build/kernel</code> \u6765\u89c2\u5bdf\u8fd9\u4e00\u70b9\uff1a</p> <pre><code>$ riscv64-linux-gnu-objdump -d  build/kernel\nDisassembly of section .text:\n\n0000000080200000 &lt;_entry&gt;:\n    80200000:   0000100f                fence.i\n    80200004:   18001073                csrw    satp,zero\n    80200008:   00094117                auipc   sp,0x94\n    8020000c:   ff810113                addi    sp,sp,-8 # 80294000 &lt;idle&gt;\n    80200010:   00001097                auipc   ra,0x1\n    80200014:   a80080e7                jalr    -1408(ra) # 80200a90 &lt;main&gt;\n</code></pre>"},{"location":"broken/c-static-linking/#_2","title":"\u7406\u89e3\u7f16\u8bd1\u5668\u548c\u94fe\u63a5\u5668","text":"<p>\u63a8\u8350\u9605\u8bfb\uff1aCSAPP Chapter 7: Linking</p> <p>\u5728\u8fdb\u884c\u8fd9\u4e00\u5c0f\u8282\u7684\u5b66\u4e60\u524d\uff0c\u6211\u4eec\u975e\u5e38\u5efa\u8bae\u4f60\u9605\u8bfb CSAPP \u4e2d\u7684\u7b2c7\u7ae0 \u94fe\u63a5\u3002</p> <p>https://csapp.cs.cmu.edu/2e/ch7-preview.pdf</p> <p>\u6211\u4eec\u5c06\u901a\u8fc7\u4e00\u4e2a\u7b80\u5355\u7684 printf \u4f8b\u5b50\u6765\u8bf4\u660e\u9759\u6001\u94fe\u63a5\u4e2d\uff0c\u94fe\u63a5\u5668\u662f\u5982\u4f55\u4e3a\u4e0d\u540c\u7684\u7b26\u53f7\u5206\u914d\u5730\u5740\u7684\uff0c\u4ee5\u53ca\u4ece\u6c47\u7f16\u5206\u6790\u4ee3\u7801\u662f\u5982\u4f55\u5f97\u5230\u7b26\u53f7\u7684\u5730\u5740 (Addressing)\u3002</p> <p>\u5728\u8ba1\u7b97\u673a\u7684\u4e16\u754c\u4e2d\uff0c\u6240\u6709\u53d8\u91cf\u3001\u5916\u8bbe\u5747\u662f\u5185\u5b58\u5730\u5740\u8bbf\u95ee\u7684\uff0cCPU \u53ea\u4e0d\u8fc7\u662f\u5728\u4e0d\u540c\u7684\u5185\u5b58\u5730\u5740\u4e0a\u5c06\u6570\u636e\u6765\u56de\u642c\u8fd0\u800c\u5df2\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u6709\u5fc5\u8981\u4e86\u89e3\u5728\u6c47\u7f16\u4ee3\u7801\u4e2d\uff0cCPU \u662f\u5982\u4f55\u5f97\u5230\u67d0\u4e2a\u5bf9\u8c61\u7684\u5185\u5b58\u5730\u5740\u7684\u3002</p> <p>\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50 (lab1-1.c) \u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf <code>a</code>\uff0c\u4e00\u4e2a <code>main</code> \u7684\u6808\u4e0a\u53d8\u91cf <code>b</code>\uff0c\u4e00\u4e2a <code>recursive</code> \u7684\u6808\u4e0a\u53d8\u91cf <code>c</code>\uff0c\u5e76\u6253\u5370\u5b83\u4eec\u7684\u5730\u5740\u3002</p> example.c<pre><code>#include &lt;stdio.h&gt;\n\nint a = 0;\n\nvoid recursive(int depth) {\n    int c;\n    if (depth == 5) return;\n    printf(\"[%d] c is at: %p\\n\", depth, &amp;c);\n    recursive(depth + 1);\n}\n\nint main() {\n    int b;\n    printf(\"main is at: %p\\n\", &amp;main);\n    printf(\"a is at: %p\\n\", &amp;a);\n    printf(\"b is at: %p\\n\", &amp;b);\n    recursive(0);\n}\n</code></pre> <p>\u6211\u4eec\u4f7f\u7528 <code>riscv64-linux-gnu-gcc -O0 -g -static -march=rv64g -Wl,--no-relax lab1-1.c</code> \u7f16\u8bd1\u5b83\u3002<code>-O0</code> \u8868\u793a\u7981\u7528\u4efb\u4f55\u7f16\u8bd1\u5668\u4f18\u5316\uff1b<code>-g</code> \u8868\u793a\u751f\u6210\u7684 ELF \u6587\u4ef6\u5e26\u4e0a\u8c03\u8bd5\u4fe1\u606f\uff0c\u65b9\u4fbf objdump \u65f6\u9644\u5e26\u4e0a\u6e90\u4ee3\u7801\uff1b<code>-static</code> \u8868\u793a\u751f\u6210\u9759\u6001\u94fe\u63a5\u7684 ELF \u6587\u4ef6\uff1b<code>-march=rv64g</code> \u963b\u6b62\u4e86\u7f16\u8bd1\u5668\u751f\u6210 RISC-V Compressed \u77ed\u6307\u4ee4\u3002</p> <p>\u6211\u4eec\u8fd0\u884c\u7f16\u8bd1\u4ea7\u7269\uff1a</p> <pre><code>$ ./a.out\nmain is at: 0x105e0\na is at: 0x7e8d8\nb is at: 0x7f2c6f5ffb2c\n[0] c is at: 0x7f2c6f5ffb0c\n[1] c is at: 0x7f2c6f5ffadc\n[2] c is at: 0x7f2c6f5ffaac\n[3] c is at: 0x7f2c6f5ffa7c\n[4] c is at: 0x7f2c6f5ffa4c\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c<code>main</code>\u7684\u5730\u5740\u662f <code>0x105e0</code>\uff0c<code>a</code>\u7684\u5730\u5740\u662f <code>0x7e8d8</code> \uff0c\u800c <code>b</code> \u4e0e <code>c</code> \u7684\u5730\u5740\u662f\u4ee5 <code>0x7f</code> \u5f00\u5934\u7684\u3002</p> <p>\u591a\u6b21\u8fd0\u884c a.out \u53ef\u4ee5\u53d1\u73b0\uff0cmain \u548c a \u7684\u5730\u5740\u662f\u56fa\u5b9a\u7684\uff0c\u800c b \u548c c \u7684\u5730\u5740\u5747\u4ee5 0x7f \u5f00\u5934\uff0c\u4f46\u662f\u4e0d\u662f\u56fa\u5b9a\u7684\uff0c\u5e76\u4e14\uff0c\u4e94\u4e2a <code>c</code> \u7684\u5730\u5740\u4e4b\u95f4\u5747\u76f8\u5dee\u56fa\u5b9a\u7684 <code>0x30</code>\u3002</p> <p>\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u5c06 <code>main</code> \u653e\u7f6e\u5230\u4e86 <code>.text</code> \u6bb5\uff0c<code>a</code> \u653e\u7f6e\u5230\u4e86\u7a0b\u5e8f\u7684 <code>.data</code> \u6bb5\uff0c\u8fd9\u4e24\u4e2a\u7b26\u53f7\u62e5\u6709\u56fa\u5b9a\u7684\u5730\u5740\uff1b\u800c <code>b</code> \u4e0e <code>c</code> \u5219\u662f\u5728\u7a0b\u5e8f\u7684\u6808\u4e0a\u5206\u914d\u7684\u3002</p>"},{"location":"broken/c-static-linking/#aout","title":"\u53cd\u6c47\u7f16 a.out","text":"<p>\u6211\u4eec\u901a\u8fc7 <code>objdump</code> \u5de5\u5177\u67e5\u770b\u7f16\u8bd1\u4ea7\u7269 <code>a.out</code> \u4e2d <code>main</code> \u7b26\u53f7\u7684\u6c47\u7f16\u4ee3\u7801\uff0c<code>--disassemble=main</code> \u8868\u793a\u53ea\u53cd\u6c47\u7f16 <code>main</code> \u7b26\u53f7\uff0c<code>-S</code> \u8868\u793a\u5728\u53cd\u6c47\u7f16\u4e0a\u6807\u6ce8\u5bf9\u5e94\u7684\u6e90\u4ee3\u7801\u3002</p> <pre><code>$ riscv64-linux-gnu-objdump --disassemble=main -S a.out\n\na.out:     file format elf64-littleriscv\n\nDisassembly of section .text:\n\n00000000000105e0 &lt;main&gt;:\nint main() {\n   105e0:       fe010113                addi    sp,sp,-32\n   105e4:       00113c23                sd      ra,24(sp)\n   105e8:       00813823                sd      s0,16(sp)\n   105ec:       02010413                addi    s0,sp,32\n    int b;\n    printf(\"main is at: %p\\n\", &amp;main);\n   105f0:       00000597                auipc   a1,0x0\n   105f4:       ff058593                addi    a1,a1,-16 # 105e0 &lt;main&gt;\n   105f8:       0003f517                auipc   a0,0x3f\n   105fc:       63850513                addi    a0,a0,1592 # 4fc30 &lt;__rseq_flags+0x1c&gt;\n   10600:       1ad000ef                jal     10fac &lt;_IO_printf&gt;\n    printf(\"a is at: %p\\n\", &amp;a);\n   10604:       84018593                addi    a1,gp,-1984 # 7e8d8 &lt;a&gt;\n   10608:       0003f517                auipc   a0,0x3f\n   1060c:       63850513                addi    a0,a0,1592 # 4fc40 &lt;__rseq_flags+0x2c&gt;\n   10610:       19d000ef                jal     10fac &lt;_IO_printf&gt;\n    printf(\"b is at: %p\\n\", &amp;b);\n   10614:       fec40793                addi    a5,s0,-20\n   10618:       00078593                mv      a1,a5\n   1061c:       0003f517                auipc   a0,0x3f\n   10620:       63450513                addi    a0,a0,1588 # 4fc50 &lt;__rseq_flags+0x3c&gt;\n   10624:       189000ef                jal     10fac &lt;_IO_printf&gt;\n    recursive(0);\n   10628:       00000513                li      a0,0\n   1062c:       f45ff0ef                jal     10570 &lt;recursive&gt;\n   10630:       00000793                li      a5,0\n   10634:       00078513                mv      a0,a5\n   10638:       01813083                ld      ra,24(sp)\n   1063c:       01013403                ld      s0,16(sp)\n   10640:       02010113                addi    sp,sp,32\n   10644:       00008067                ret\n</code></pre> <p>\u8f93\u51fa\u7684\u7b2c\u4e00\u884c\u544a\u8bc9\u6211\u4eec <code>a.out</code> \u6587\u4ef6\u7684\u683c\u5f0f\u662f <code>elf64-littleriscv</code>\uff0c\u8fd9\u4ee3\u8868\u8fd9\u662f\u4e00\u4e2a 64 \u4f4d ELF \u6587\u4ef6\uff0c\u67b6\u6784\u4e3a RISC-V \u5c0f\u7aef\u5e8f\u3002\u7b2c\u4e8c\u884c\u8868\u793a\u6211\u4eec\u6b63\u5728\u53cd\u6c47\u7f16\u5176\u4e2d\u7684 <code>.text</code> \u6bb5\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u5728 <code>10600</code>\u3001<code>10610</code> \u548c <code>10624</code> \u5904\uff0c\u5206\u522b\u6709\u4e09\u6b21 <code>jal 10fac &lt;_IO_printf&gt;</code>\uff0c\u8fd9\u8868\u793a\u8c03\u7528\u4e86 <code>printf</code> \u51fd\u6570\uff0c\u800c <code>printf</code> \u51fd\u6570\u5730\u5740\u4e3a <code>0x10fac</code>\u3002</p>"},{"location":"broken/c-static-linking/#_3","title":"\u6c47\u7f16\u4e2d\u7684\u5bfb\u5740","text":"<p>\u5728\u8fd9\u4e00\u5c0f\u8282\uff0c\u6211\u4eec\u4e3b\u8981\u63a2\u8ba8\u5728\u6c47\u7f16\u5c42\u9762\u4e0a\uff0c\u7f16\u8bd1\u5668\u662f\u5982\u4f55\u751f\u6210\u6c47\u7f16\u6307\u4ee4\u6765\u627e\u5230\u67d0\u4e2a\u7b26\u53f7\u7684\u5730\u5740\u7684\u3002</p> <p>\u5728\u4e0a\u8ff0\u7a0b\u5e8f\u8c03\u7528 printf \u65f6\uff0c\u6211\u4eec\u4f20\u5165\u4e86\u4e24\u4e2a\u53c2\u6570\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u5e38\u91cf\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u67d0\u4e2a\u53d8\u91cf\u7684\u5730\u5740\u3002</p> <p>\u6839\u636e <code>jal</code> \u6307\u4ee4\u524d\u7684\u6307\u4ee4\u5e8f\u5217\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u6d4b <code>jal printf</code> \u524d\u7684\u5bc4\u5b58\u5668\u503c\u3002\u5e76\u4e14\uff0c\u6839\u636e RISC-V \u67b6\u6784\u4e0b\u7684\u51fd\u6570\u8c03\u7528\u7ea6\u5b9a (Calling Convention, \u524d 8 \u4e2a\u6574\u6570\u53c2\u6570\u901a\u8fc7 a0-a7 \u4f20\u9012)\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u8c03\u7528 <code>printf</code> \u7684\u5177\u4f53\u53c2\u6570\uff1a</p> <pre><code># \u7b2c\u4e00\u6b21\uff1a\n   105f0:       00000597                auipc   a1,0x0\n   105f4:       ff058593                addi    a1,a1,-16 # 105e0 &lt;main&gt;\n   105f8:       0003f517                auipc   a0,0x3f\n   105fc:       63850513                addi    a0,a0,1592 # 4fc30 &lt;__rseq_flags+0x1c&gt;\n# a0 = 0x4fc30, a1 = 0x105e0\n# printf(0x4fc30, 0x105e0)\n   10600:       1ad000ef                jal     10fac &lt;_IO_printf&gt;\n\n# \u7b2c\u4e8c\u6b21\uff1a\n   10604:       84018593                addi    a1,gp,-1984 # 7e8d8 &lt;a&gt;\n   10608:       0003f517                auipc   a0,0x3f\n   1060c:       63850513                addi    a0,a0,1592 # 4fc40 &lt;__rseq_flags+0x2c&gt;\n# a0 = 0x4fc40, a1 = 0x7e8d8\n# printf(0x4fc40, 0x7e8d8)\n   10610:       19d000ef                jal     10fac &lt;_IO_printf&gt;\n</code></pre> <p>auipc</p> <p>AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC appends 12 low-order zero bits to the 20-bit U-immediate, sign-extends the result to 64 bits, then adds it to the pc and places the result in register rd.</p> <p>AUIPC \u662f RISC-V \u4e2d\u5b9e\u73b0 PC-Relative Addressing (PC\u76f8\u5bf9\u5bfb\u5740) \u7684\u65b9\u5f0f\u3002AUIPC \u4f1a\u5c06 20 \u4f4d\u7684\u7acb\u5373\u6570\u5de6\u79fb 12 \u4f4d\uff0c\u7b26\u53f7\u6269\u5c55\u540e\u52a0\u4e0a pc \u5bc4\u5b58\u5668\u7684\u503c\uff0c\u5e76\u4fdd\u5b58\u5230\u6307\u5b9a\u7684 rd \u5bc4\u5b58\u5668\u4e2d\u3002</p> <p>\u4f8b\u5982\uff0c<code>auipc   a1,0x0</code>\uff0c\u5c06 pc (0x105f0) \u52a0\u4e0a 0x0\uff0c\u5b58\u5165 a1 \u4e2d\u3002<code>addi    a1,a1,-16</code> \u5c06 a1 \u51cf\u53bb 0x01\uff0c\u5f97\u5230 0x105e0\uff0c\u5373 <code>main</code> \u7684\u5730\u5740\u3002</p> <p>\u6839\u636e <code>printf</code> \u7684\u5b9a\u4e49: <code>int printf(const char *restrict format, ...);</code>\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570 a0 \u5e94\u8be5\u662f\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 <code>objdump</code> \u89c2\u5bdf\u6307\u5b9a\u5730\u5740\u5904\u7684\u503c\u6765\u9a8c\u8bc1\u8fd9\u4e00\u70b9\uff1a</p> <pre><code>$ riscv64-linux-gnu-objdump -s --start-address=0x4fc30 --stop-address=0x4fc60\n\na.out:     file format elf64-littleriscv\n\nContents of section .rodata:\n 4fc30 6d61696e 20697320 61743a20 25700a00  main is at: %p..\n 4fc40 61206973 2061743a 2025700a 00000000  a is at: %p.....\n 4fc50 62206973 2061743a 2025700a 00000000  b is at: %p.....\n</code></pre> <p><code>objdump</code> \u7684\u8f93\u51fa\u4e2d\uff0c\u6700\u5de6\u4fa7\u662f\u5185\u5b58\u5730\u5740 <code>4fc30</code>\uff0c\u540e\u9762\u8ddf\u968f\u7684\u662f\u8be5\u5730\u5740\u4e0a0x10 (32) bytes \u7684\u4e8c\u8fdb\u5236\u5185\u5bb9\uff0c\u800c\u6700\u540e\u662f\u8fd9\u4e9b\u4e8c\u8fdb\u5236\u5185\u5bb9\u7684 ASCII \u89e3\u7801\u3002</p> <p><code>objdump</code> \u7684\u7ed3\u679c\u8868\u793a\uff0c<code>0x4fc30</code> \u5230 <code>0x4fc60</code> \u662f .rodata \u6bb5\u7684\u5185\u5bb9\uff1b\u5730\u5740 <code>0x4fc30</code> \u5904\u662f\u4e00\u4e2a NULL-terminated \u7684\u5b57\u7b26\u4e32 <code>main is at: %p..</code>\uff0c\u8fd9\u6b63\u662f\u6211\u4eec\u7b2c\u4e00\u6b21\u8c03\u7528 <code>printf</code> \u65f6\u6307\u5b9a\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u3002</p> <p>\u7b2c\u4e8c\u4e2a\u53c2\u6570 a1 \u5219\u5206\u522b\u662f <code>0x105e0</code> \u548c <code>0x7e8d8</code>\uff0c\u5b83\u4eec\u5206\u522b\u662f <code>main</code> \u548c <code>a</code> \u7684\u5730\u5740\u3002\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5b83\u4eec\u5206\u522b\u662f\u901a\u8fc7 <code>auipc + addi</code> \u548c <code>addi a1,gp,xxx</code> \u8ba1\u7b97\u51fa\u6765\u7684\u3002</p> <p>\u5bfb\u5740 (Addressing)</p> <p>\u5bfb\u5740\u6a21\u5f0f\u8868\u793a\u4e86\u5982\u4f55\u8ba1\u7b97\u5185\u5b58\u5730\u5740\uff0c\u5728 RISC-V \u4e2d\uff0c\u5bfb\u5740\u6a21\u5f0f (Addressing Mode) \u6709\u4ee5\u4e0b\u51e0\u79cd\uff1a</p> <ul> <li>PC-relative: auipc, jal, branch \u7b49\u6307\u4ee4\uff0c\u901a\u8fc7\u5f53\u524d\u6307\u4ee4\u7684 PC \u503c\u52a0\u4e0a\u4e00\u4e2a\u504f\u79fb\u91cf\u5f97\u5230</li> <li>Register-offset: jalr, ld, sw \u7b49\u6240\u6709\u8bbf\u5b58\u6307\u4ee4\uff0c\u901a\u8fc7\u67d0\u4e2a\u5bc4\u5b58\u5668\u7684\u503c\u52a0\u4e0a\u4e00\u4e2a\u504f\u79fb\u91cf\u5f97\u5230</li> <li>Absolute: lui \u6307\u4ee4\uff0c\u76f4\u63a5\u901a\u8fc7\u7acb\u5373\u6570\u5f97\u5230\u5730\u5740</li> </ul> <p>\u6211\u4eec\u53d1\u73b0\uff0cRISC-V \u7f16\u8bd1\u5668\u901a\u5e38\u4f1a\u4f7f\u7528 auipc + addi \u7684\u65b9\u5f0f\u4f7f\u7528 PC-Relative \u6765\u5f97\u5230\u76ee\u6807\u7b26\u53f7\u7684\u5730\u5740\u3002</p>"},{"location":"broken/c-static-linking/#_4","title":"\u7b26\u53f7\u89e3\u6790","text":"<p>\u6211\u4eec\u5728\u4e4b\u524d\u7f16\u8bd1 <code>lab1-1.c</code> \u65f6\uff0c\u4f7f\u7528\u4e86 gcc \u76f4\u63a5\u7f16\u8bd1\u3002\u5b9e\u9645\u4e0a gcc \u4f1a\u8fdb\u884c\u7f16\u8bd1\u5e76\u94fe\u63a5\u3002\u73b0\u5728\uff0c\u6211\u4eec\u5728\u7f16\u8bd1 <code>lab1-1.c</code> \u65f6\u52a0\u5165 <code>-c</code> \u53c2\u6570\uff0c\u544a\u8bc9 gcc \u53ea\u8981\u8fdb\u884c\u7f16\u8bd1\u800c\u4e0d\u8fdb\u884c\u94fe\u63a5\uff0c\u8fd9\u4e00\u6b65\u4f1a\u751f\u6210Relocatable Object file <code>lab1-1.o</code></p> <pre><code>$ riscv64-linux-gnu-gcc -O0 -g -static -march=rv64g -c lab1-1.c\n</code></pre> <p>\u6211\u4eec\u4f7f\u7528 <code>llvm-readelf</code> \u5de5\u5177\u89e3\u6790\u7f16\u8bd1\u4ea7\u7269 <code>lab1-1.o</code>\uff1a</p> <pre><code>$ llvm-readelf-17 --all lab1-1.o\n\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           RISC-V\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          6856 (bytes into file)\n  Flags:                             0x4, double-float ABI\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         23\n  Section header string table index: 22\nThere are 23 section headers, starting at offset 0x1ac8:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        0000000000000000 000040 0000f4 00  AX  0   0  4\n  [ 2] .rela.text        RELA            0000000000000000 000fb8 000390 18   I 20   1  8\n  [ 3] .data             PROGBITS        0000000000000000 000134 000000 00  WA  0   0  1\n  [ 4] .bss              NOBITS          0000000000000000 000134 000004 00  WA  0   0  4\n  [ 5] .rodata           PROGBITS        0000000000000000 000138 000045 00   A  0   0  8\n  [ 6] .debug_info       PROGBITS        0000000000000000 00017d 000108 00      0   0  1\n  [ 7] .rela.debug_info  RELA            0000000000000000 001348 000288 18   I 20   6  8\n  [ 8] .debug_abbrev     PROGBITS        0000000000000000 000285 0000c8 00      0   0  1\n  [ 9] .debug_aranges    PROGBITS        0000000000000000 00034d 000030 00      0   0  1\n  [10] .rela.debug_aranges RELA          0000000000000000 0015d0 000060 18   I 20   9  8\n  [11] .debug_line       PROGBITS        0000000000000000 00037d 0000a3 00      0   0  1\n  [12] .rela.debug_line  RELA            0000000000000000 001630 0002d0 18   I 20  11  8\n  [13] .debug_str        PROGBITS        0000000000000000 000420 0000e9 01  MS  0   0  1\n  [14] .debug_line_str   PROGBITS        0000000000000000 000509 00009e 01  MS  0   0  1\n  [15] .comment          PROGBITS        0000000000000000 0005a7 00001f 01  MS  0   0  1\n  [16] .note.GNU-stack   PROGBITS        0000000000000000 0005c6 000000 00      0   0  1\n  [17] .eh_frame         PROGBITS        0000000000000000 0005c8 000068 00   A  0   0  8\n  [18] .rela.eh_frame    RELA            0000000000000000 001900 0000f0 18   I 20  17  8\n  [19] .riscv.attributes RISCV_ATTRIBUTES 0000000000000000 000630 000061 00      0   0  1\n  [20] .symtab           SYMTAB          0000000000000000 000698 0007c8 18     21  79  8\n  [21] .strtab           STRTAB          0000000000000000 000e60 000156 00      0   0  1\n  [22] .shstrtab         STRTAB          0000000000000000 0019f0 0000d2 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  R (retain), p (processor specific)\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\u4ee5\u4e0b\u51e0\u70b9\uff1a</p> <ol> <li> <p>ELF Header \u4e2d\u7684 Type \u662f <code>REL (Relocatable file)</code>\uff0c\u8fd9\u8868\u793a\u8fd9\u662f\u4e00\u4e2a\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\u3002</p> </li> <li> <p>ELF \u6587\u4ef6\u4e2d\u4e00\u5171\u6709 23 \u4e2a Section\uff0c\u6bcf\u4e2a Section \u90fd\u6709\u81ea\u5df1\u7684\u540d\u5b57 (Name)\u3001\u7c7b\u578b (Type)\u3001\u5730\u5740 (Address)\u3001\u5728 ELF \u6587\u4ef6\u4e2d\u7684\u504f\u79fb\u91cf (Off)\u3001\u5927\u5c0f (Size) \u548c Flag</p> </li> <li> <p>Flag \u4e2d\u6807\u5fd7\u4e86\u6bcf\u4e2a Section \u7684\u4e00\u4e9b\u5c5e\u6027\uff0c\u4f8b\u5982 <code>A (alloc)</code>\u3001<code>W (write)</code>\u3001<code>X (execute)</code>\u3002<code>A (alloc)</code> \u8868\u793a\u5728\u52a0\u8f7d ELF \u65f6\uff0c\u8fd9\u4e2a Section \u5e94\u8be5\u88ab\u5206\u914d\u5185\u5b58\u5e76\u52a0\u8f7d\u3002\u800c <code>W</code> \u4e0e <code>X</code> \u5219\u8868\u793a\u6bb5\u662f\u5426\u53ef\u5199\u548c\u53ef\u6267\u884c\u3002</p> </li> <li> <p>\u6211\u4eec\u53d1\u73b0\u4e86\u5e38\u89c1\u7684 <code>.text</code> \u6bb5\uff0c\u5b83\u662f AX \uff1a\u9700\u8981\u88ab\u52a0\u8f7d\u3001\u53ef\u6267\u884c\u7684\u3002<code>.data</code> \u6bb5\u548c <code>.bss</code> \u6bb5\u662f AW \u7684\uff1a\u9700\u8981\u88ab\u52a0\u8f7d\u3001\u53ef\u5199\u7684\u3002\u800c <code>.rodata</code> \u662f\u8fd1\u9700\u8981\u88ab\u52a0\u8f7d\u7684\uff0c\u4e0d\u53ef\u5199\u548c\u4e0d\u53ef\u6267\u884c\u7684\u3002</p> </li> <li> <p>\u6211\u4eec\u53d1\u73b0\u6709\u4e00\u4e2a\u7279\u6b8a\u7684 Section <code>.symtab</code>\uff0c\u5b83\u5b58\u50a8\u7740\u8fd9\u4e2a Relocatable file \u7684 Symbol Table \u7b26\u53f7\u8868\u3002</p> </li> </ol> <p>\u7b26\u53f7\u8868\u662f\u8fde\u63a5\u7f16\u8bd1\u5668\u548c\u94fe\u63a5\u5668\u7684\u91cd\u8981\u6570\u636e\u7ed3\u6784\uff0c\u6211\u4eec\u8fdb\u4e00\u6b65\u89c2\u5bdf <code>lab1-1.o</code> \u7684\u7b26\u53f7\u8868\uff1a</p> <pre><code>$ llvm-readelf-17 --symbols lab1-1.o\nSymbol table '.symtab' contains 83 entries:\n   Num:    Value          Size Type    Bind   Vis       Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT   UND \n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT   ABS lab1-1.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT     1 .text\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT     3 .data\n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT     4 .bss\n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT     5 .rodata\n    ...\n    79: 0000000000000000     4 OBJECT  GLOBAL DEFAULT     4 a\n    80: 0000000000000000   120 FUNC    GLOBAL DEFAULT     1 recursive\n    81: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND printf\n    82: 0000000000000078   124 FUNC    GLOBAL DEFAULT     1 main\n</code></pre> <p>\u7b26\u53f7\u8868\u4e2d\u6709 83 \u6761 Symbol\uff0c\u6bcf\u4e00\u6761\u5747\u6709\u4e00\u4e2a\u503c\u3001\u5927\u5c0f\u3001\u7c7b\u578b\u3001\u53ef\u89c1\u57df (Bind)\u3001\u540d\u5b57 (Name)\uff0c\u9664\u6b64\u4e4b\u5916\uff0cNdx \u4e00\u5217\u8868\u793a\u4e86\u8fd9\u4e2a\u7b26\u53f7\u662f\u5c5e\u4e8e\u54ea\u4e2a Section \u7684\u3002</p> <p>\u4f8b\u5982\uff0c<code>main</code> \u548c <code>recursize</code> \u662f\u4e24\u4e2a\u51fd\u6570\uff0c\u6240\u4ee5\u5b83\u4eec\u7684\u7c7b\u578b\u662f FUNC\uff0cNdx \u4e3a 1\uff0c\u8868\u660e\u5b83\u5c5e\u4e8e Section Headers \u4e2d\u7684 1 \u53f7 Section <code>.text</code>\u3002 <code>a</code> \u662f\u4e00\u4e2a\u672a\u88ab\u521d\u59cb\u5316\u7684 int \u53d8\u91cf\uff0c\u6240\u4ee5\u5b83\u7684\u7c7b\u578b\u662f OBJECT\uff0c\u6240\u5c5e\u4e8e <code>.bss</code> \u6bb5\uff0c\u5927\u5c0f\u4e3a 4 \u4e2a\u5b57\u8282\u3002 \u7279\u522b\u7684\uff0c\u6211\u4eec\u5728\u4ee3\u7801\u4e2d\u5f15\u7528\u4e86\u5916\u90e8\u7b26\u53f7 (\u6ca1\u6709\u5728 lab1-1.c \u4e2d\u5b9a\u4e49) printf\uff0c\u5b83\u7684 Ndx \u662f UND (\u8868\u660e\u8fd9\u4e2a\u7b26\u53f7\u88ab\u8be5\u6587\u4ef6\u5f15\u7528\u4e86\uff0c\u4f46\u662f\u6ca1\u6709\u5728\u8be5\u6587\u4ef6\u4e2d\u88ab\u5b9a\u4e49)\uff0c\u5e76\u4e14\u6211\u4eec\u4e5f\u4e0d\u77e5\u9053\u5b83\u7684\u7c7b\u578b\u3002</p> <p>\u94fe\u63a5\u5668\u4f1a\u8bfb\u53d6\u6240\u6709\u8981\u94fe\u63a5\u7684 .o \u6587\u4ef6\u7684\u7b26\u53f7\u8868\uff0c\u7ed3\u5408\u6240\u6709\u88ab\u5b9a\u4e49\u7684\u7b26\u53f7\uff0c\u548c\u88ab\u5f15\u7528\u7684\u5916\u90e8\u7b26\u53f7\u3002\u8fd9\u4e00\u6b65\u88ab\u6210\u4e3a\u7b26\u53f7\u89e3\u6790 (Symbol Resolution)\u3002</p>"},{"location":"broken/c-static-linking/#_5","title":"\u7b26\u53f7\u91cd\u5b9a\u4f4d","text":"<p>\u6211\u4eec\u4f7f\u7528 <code>objdump</code> \u89c2\u5bdf\u751f\u6210\u7684 lab1-1.o \u6587\u4ef6\u3002</p> <pre><code>$ riscv64-linux-gnu-objdump --disassemble=main -S lab1-1.o\n\nDisassembly of section .text:\n\n0000000000000078 &lt;main&gt;:\nint main() {\n  78:   fe010113                addi    sp,sp,-32\n  7c:   00113c23                sd      ra,24(sp)\n  80:   00813823                sd      s0,16(sp)\n  84:   02010413                addi    s0,sp,32\n    int b;\n    printf(\"main is at: %p\\n\", &amp;main);\n  88:   00000597                auipc   a1,0x0\n  8c:   00058593                mv      a1,a1\n  90:   00000517                auipc   a0,0x0\n  94:   00050513                mv      a0,a0\n  98:   00000097                auipc   ra,0x0\n  9c:   000080e7                jalr    ra # 98 &lt;main+0x20&gt;\n    printf(\"a is at: %p\\n\", &amp;a);\n  a0:   00000597                auipc   a1,0x0\n  a4:   00058593                mv      a1,a1\n  a8:   00000517                auipc   a0,0x0\n  ac:   00050513                mv      a0,a0\n  b0:   00000097                auipc   ra,0x0\n  b4:   000080e7                jalr    ra # b0 &lt;main+0x38&gt;\n    printf(\"b is at: %p\\n\", &amp;b);\n</code></pre> <p>\u6211\u4eec\u5bf9\u6bd4 <code>a.out</code> \u548c <code>lab1-1.o</code> \u4e2d\u7b2c\u4e00\u6b21 <code>printf</code> \u65f6\u7684\u6c47\u7f16\u4ee3\u7801\uff1a</p> <pre><code># lab1-1.o:\n  88:          00000597                auipc   a1,0x0\n  8c:          00058593                mv      a1,a1\n  90:          00000517                auipc   a0,0x0\n  94:          00050513                mv      a0,a0\n  98:          00000097                auipc   ra,0x0\n  9c:          000080e7                jalr    ra # 98 &lt;main+0x20&gt;\n# a.out:\n  105f0:       00000597                auipc   a1,0x0\n  105f4:       ff058593                addi    a1,a1,-16 # 105e0 &lt;main&gt;\n  105f8:       0003f517                auipc   a0,0x3f\n  105fc:       63850513                addi    a0,a0,1592 # 4fc30 &lt;__rseq_flags+0x1c&gt;\n  10600:       1ad000ef                jal     10fac &lt;_IO_printf&gt;\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c<code>lab1-1.o</code> \u4e2d\uff0c<code>auipc</code> \u548c <code>mv</code> \u6307\u4ee4\u4e2d\u7684\u7acb\u5373\u6570\u5747\u4e3a 0\u3002\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u5e76\u4e0d\u77e5\u9053\u8fd9\u4e9b\u7b26\u53f7 (main\u51fd\u6570\u3001printf\u51fd\u6570\u3001\u53d8\u91cfa\u7b49) \u5c06\u4f1a\u88ab\u94fe\u63a5\u5668\u5b89\u6392\u5230\u4ec0\u4e48\u5730\u5740\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\u53ea\u80fd\u6446\u70c2\uff0c\u751f\u6210\u4e86\u4e00\u4e9b\u5360\u4f4d\u6307\u4ee4\uff0c\u5e76\u751f\u6210\u4e86\u4e00\u4e9b Relocation \u4fe1\u606f\uff0c\u5c06\u6700\u7ec8\u786e\u8ba4\u5730\u5740\u7684\u4efb\u52a1\u7559\u7ed9\u4e86\u94fe\u63a5\u5668\u5904\u7406\u3002</p> <p>\u5728\u9759\u6001\u94fe\u63a5\u4e2d\uff0c\u51fd\u6570\u7684\u5730\u5740\u548c\u5168\u5c40\u53d8\u91cf\u7684\u5730\u5740\u5728\u94fe\u63a5\u9636\u6bb5\u88ab\u786e\u5b9a\u3002\u94fe\u63a5\u5668\u4f1a\u6839\u636e Linker Script \u5408\u5e76\u6240\u6709 object \u6587\u4ef6\u4e2d\u7684\u6240\u6709\u7b26\u53f7\uff0c\u5e76\u4e3a\u5176\u5206\u914d\u5730\u5740\u3002 \u5728\u5206\u914d\u5730\u5740\u7ed3\u675f\u540e\uff0c\u94fe\u63a5\u5668\u4f1a\u6839\u636e\u7f16\u8bd1\u5668\u751f\u6210\u7684\u6c47\u7f16\u4ee3\u7801\uff0c\u5728\u6307\u5b9a\u6c47\u7f16\u4ee3\u7801\u7684\u4f4d\u7f6e\u586b\u5165\u7acb\u5373\u6570\uff0c\u4ee5\u786e\u4fdd\u8fd9\u4e9b\u5bfb\u5740\u4ee3\u7801\u80fd\u6b63\u786e\u7684\u627e\u5230\u5b83\u4eec\u6240\u5f15\u7528\u7684\u7b26\u53f7\u3002\u8fd9\u4e00\u6b65\u88ab\u6210\u4e3a Relocation \u91cd\u5b9a\u4f4d\u3002</p> <p>\u5728 lab1-1.o \u4e2d\uff0c<code>main</code> \u7684\u5730\u5740\u662f 0x0078\uff0c\u800c\u6700\u7ec8\u7684\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\uff0c<code>main</code> \u7684\u5730\u5740\u662f <code>0x105e0</code>\u3002\u8fd9\u662f\u56e0\u4e3a\u94fe\u63a5\u5668\u5b8c\u6210\u4e86\u5bf9 lab1-1.o \u4e2d <code>main</code> \u51fd\u6570\u7684\u91cd\u5b9a\u4f4d\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c<code>main</code> \u51fd\u6570\u6700\u7ec8\u88ab\u91cd\u5b9a\u4f4d\u5230\u4e86 <code>0x105e0</code>\u3002\u5e76\u4e14\uff0c<code>printf</code> \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e5f\u88ab\u6b63\u786e\u5b9a\u4f4d\u4e86 (0x4fc30)\u3002</p> <p>\u6211\u4eec\u4f7f\u7528 <code>readelf</code> \u5de5\u5177\u67e5\u9605 lab1-1.o \u6587\u4ef6\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u53d1\u73b0 <code>.rela.text</code> \u6bb5\u4e2d\u6709\u4ee5\u4e0b\u4fe1\u606f\uff1a</p> <pre><code>$ llvm-readelf-17 --relocs lab1-1.o\n\nRelocation section '.rela.text' at offset 0xfb8 contains 38 entries:\n    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n0000000000000088  0000005200000017 R_RISCV_PCREL_HI20     0000000000000078 main + 0\n0000000000000098  0000005100000013 R_RISCV_CALL_PLT       0000000000000000 printf + 0\n</code></pre> <p>\u8fd9\u8868\u793a\u4e86\u5728 lab1-1.o \u6c47\u7f16\u7684 0x88 \u5904\u5f15\u7528\u4e86 <code>main</code> \u7b26\u53f7\u7684\u5730\u5740\uff0c\u5e76\u5728 0x98 \u5904\u8c03\u7528\u4e86 <code>printf</code> \u51fd\u6570\uff0c\u8fd9\u4e0e\u6211\u4eec\u89c2\u5bdf\u5230 lab1-1.o \u4e2d\u7684\u6c47\u7f16\u884c\u4e3a\u76f8\u7b26\u5408\u3002\u94fe\u63a5\u5668\u9700\u8981\u5904\u7406\u8fd9\u4e9b Relocation \u4fe1\u606f\u5e76\u6700\u7ec8\u751f\u6210\u6700\u540e\u7684 a.out \u6587\u4ef6\u3002</p>"},{"location":"broken/c-static-linking/#_6","title":"\u603b\u7ed3","text":"<p>\u7efc\u4e0a\uff0c\u5728\u9759\u6001\u94fe\u63a5\u4e2d\uff0c\u94fe\u63a5\u5668\u4e3b\u8981\u5b8c\u6210\u4e86\u4e24\u4ef6\u4e8b\u60c5\uff1a</p> <ul> <li> <p>\u89e3\u6790\u7b26\u53f7\uff1a\u786e\u5b9a object \u6587\u4ef6\u4e2d\u5f15\u7528\u7684 Symbol \u5177\u4f53\u4e3a\u54ea\u4e2a</p> </li> <li> <p>\u91cd\u5b9a\u4f4d\uff1a\u91cd\u5b9a\u4f4d object \u6587\u4ef6\u4e2d\u7684\u6bb5\uff0c\u5e76\u91cd\u5b9a\u4f4d\u5176\u4e2d\u5bf9 Symbol \u7684\u5f15\u7528</p> </li> </ul> <p>\u5728\u7b2c\u4e8c\u6b65\u4e2d\uff0cld \u4f1a\u6839\u636e Linker Script \u6307\u793a\u8fdb\u884c\u91cd\u5b9a\u4f4d\uff0c\u6240\u6709\u51fd\u6570\u3001\u5168\u5c40\u53d8\u91cf\uff0c\u5747\u62e5\u6709\u4e86\u81ea\u5df1\u6240\u5c5e\u7684\u7a7a\u95f4\u4ee5\u53ca\u5176\u5730\u5740\u3002</p>"},{"location":"broken/c-static-linking/#ex-libc","title":"Ex: libc","text":"<p>main.c \u4e2d\u5e76\u6ca1\u6709\u5b9a\u4e49 <code>printf</code> \u51fd\u6570\uff0c\u5b83\u5728\u5934\u6587\u4ef6 <code>stdio.h</code> \u4e2d\u88ab\u58f0\u660e\u4e86\u3002</p> <p>\u4f46\u662f\uff0c\u6211\u4eec\u5728\u94fe\u63a5\u65f6\u4e5f\u5e76\u6ca1\u6709\u989d\u5916\u6307\u5b9a\u5176\u4ed6 .o \u6587\u4ef6\u3002\u8fd9\u662f\u56e0\u4e3a <code>printf</code> \u662f C \u6807\u51c6\u5e93 (libc) \u7684\u4e00\u90e8\u5206\uff0c\u800c\u9ed8\u8ba4\u7684\u94fe\u63a5\u53c2\u6570\u4e2d\u5747\u4f1a\u94fe\u63a5\u4e0a libc\u3002</p> <p>\u6211\u4eec\u5728\u7f16\u8bd1\u94fe\u63a5 lab1-1.o \u65f6\uff0c\u4f7f\u7528 <code>-Wl,-v</code> \u663e\u793a\u94fe\u63a5\u5668 ld \u7684\u5177\u4f53\u53c2\u6570\uff1a</p> <pre><code>$ riscv64-linux-gnu-gcc -O0 -g -static -march=rv64g lab1-1.o -Wl,-v\ncollect2 version 14.2.0\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld -plugin /usr/libexec/gcc-cross/riscv64-linux-gnu/14/liblto_plugin.so -plugin-opt=/usr/libexec/gcc-cross/riscv64-linux-gnu/14/lto-wrapper -plugin-opt=-fresolution=/tmp/cc0dIN9b.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --sysroot=/ --build-id -hash-style=gnu --as-needed -melf64lriscv -X -static /usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/lib/crt1.o /usr/lib/gcc-cross/riscv64-linux-gnu/14/crti.o /usr/lib/gcc-cross/riscv64-linux-gnu/14/crtbeginT.o -L/usr/lib/gcc-cross/riscv64-linux-gnu/14 -L/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/lib -L/lib/riscv64-linux-gnu -L/usr/lib/riscv64-linux-gnu lab1-1.o -v --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc-cross/riscv64-linux-gnu/14/crtend.o /usr/lib/gcc-cross/riscv64-linux-gnu/14/crtn.o\nGNU ld (GNU Binutils for Debian) 2.43.1\n</code></pre> <p>\u5176\u4e2d\u5305\u542b\u4e86 <code>-L/usr/lib/gcc-cross/riscv64-linux-gnu/14</code> \u6307\u5b9a\u4e86\u94fe\u63a5\u8be5\u76ee\u5f55\u4e0b\u9762\u7684\u67d0\u4e9b Object \u6587\u4ef6\uff0c<code>--start-group -lgcc -lgcc_eh -lc --end-group</code> \u8868\u793a\u4e86\u94fe\u63a5 libc \u5e93\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>-nostdlib</code> \u6765\u7981\u6b62\u94fe\u63a5\u6807\u51c6\u5e93\uff1a</p> <pre><code>$ riscv64-linux-gnu-gcc -O0 -g -static -march=rv64g lab1-1.o -Wl,-v -nostdlib\ncollect2 version 14.2.0\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld -plugin /usr/libexec/gcc-cross/riscv64-linux-gnu/14/liblto_plugin.so -plugin-opt=/usr/libexec/gcc-cross/riscv64-linux-gnu/14/lto-wrapper -plugin-opt=-fresolution=/tmp/cceuW8LP.res --sysroot=/ --build-id -hash-style=gnu --as-needed -melf64lriscv -X -static -L/usr/lib/gcc-cross/riscv64-linux-gnu/14 -L/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/lib -L/lib/riscv64-linux-gnu -L/usr/lib/riscv64-linux-gnu lab1-1.o -v\nGNU ld (GNU Binutils for Debian) 2.43.1\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld: warning: cannot find entry symbol _start; defaulting to 000000000001017c\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld: lab1-1.o: in function `recursive':\nlab1-1.c:8:(.text+0x40): undefined reference to `printf'\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld: lab1-1.o: in function `main':\nlab1-1.c:14:(.text+0x94): undefined reference to `printf'\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld: lab1-1.c:15:(.text+0xac): undefined reference to `printf'\n/usr/lib/gcc-cross/riscv64-linux-gnu/14/../../../../riscv64-linux-gnu/bin/ld: lab1-1.c:16:(.text+0xc4): undefined reference to `printf'\ncollect2: error: ld returned 1 exit status\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c\u5c3d\u7ba1 ld \u88ab\u6307\u5b9a\u4e86\u4e00\u4e9b\u94fe\u63a5\u76ee\u5f55 <code>-L</code> \u4f46\u662f\u6ca1\u6709\u6307\u5b9a <code>-lc</code>\u3002\u56e0\u6b64 ld \u62a5\u9519\u4e86 undefined reference\uff0c\u63d0\u793a\u627e\u4e0d\u5230 <code>printf</code> \u8fd9\u4e2a\u7b26\u53f7\u3002</p>"},{"location":"broken/c-static-linking/#_7","title":"\u7ed3\u6784\u4f53","text":"<p>C \u8bed\u8a00\u4e2d\uff0c\u7ed3\u6784\u4f53\u662f\u5bf9\u4e00\u4e9b\u6570\u636e\u7684\u8868\u793a\u3002(A structure is a programmer-defined data type made up of variables of other data types (possibly including other structure types).)</p> <p>\u6211\u4eec\u901a\u8fc7 <code>struct</code> \u5173\u952e\u5b57\u58f0\u660e\u4e00\u4e2a\u7ed3\u6784\u4f53\u3002 \u901a\u5e38\uff0c\u6211\u4eec\u5c06\u4e00\u4e9b\u76f8\u5173\u8054\u7684\u6570\u636e\u653e\u7f6e\u5728\u540c\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0a\u3002</p> <p>\u7ed3\u6784\u4f53\u6709\u7740\u7f16\u8bd1\u671f\u5c31\u5df2\u77e5\u7684\u56fa\u5b9a\u5927\u5c0f\u3002\u901a\u5e38\u6765\u8bf4\uff0c\u7ed3\u6784\u4f53\u4e2d\u7684\u53d8\u91cf\u4f1a\u4f9d\u6b21\u5728\u5185\u5b58\u4e2d\u6392\u5e03\uff0c\u4f46\u662f\u53d8\u91cf\u4e4b\u95f4\u53ef\u80fd\u4f1a\u5b58\u5728\u4e00\u4e9b Padding\uff0c\u786e\u4fdd\u7ed3\u6784\u4f53\u4e2d\u7684\u53d8\u91cf\u88ab\u6b63\u786e\u5bf9\u9f50\u4e86\u3002</p> <pre><code>struct proc {\n    enum procstate state;   // Process state\n    int pid;                // Process ID\n    uint64 pagetable;  // User page table\n    uint64 ustack;          // Virtual address of kernel stack\n    uint64 kstack;          // Virtual address of kernel stack\n    struct trapframe *trapframe; // data page for trampoline.S\n    struct context context; // swtch() here to run process\n    struct proc *parent;    // Parent process\n};\n</code></pre> <p>\u4f8b\u5982\uff0c\u5728\u6211\u4eec\u7684 uCore \u5185\u6838\u4e0a\uff0c\u63cf\u8ff0\u8fdb\u7a0b\u7684\u7ed3\u6784\u4f53 <code>struct proc</code> \u5305\u542b\u4e86 \u8fdb\u7a0b\u72b6\u6001 <code>state</code>\uff0cPID\uff0c\u9875\u8868\uff0c\u7528\u6237\u6808\u548c\u5185\u6838\u6808\u5730\u5740\u7b49\u4fe1\u606f\u3002</p> <p>\u5728\u5bf9\u7ed3\u6784\u4f53\u6307\u9488\u8bbf\u95ee\u5176\u6210\u5458\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u4f7f\u7528 <code>-&gt;</code> \u64cd\u4f5c\u7b26\u3002 \u5728\u5bf9\u7ed3\u6784\u4f53\u8bbf\u95ee\u5176\u6210\u5458\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u4f7f\u7528 <code>.</code> \u64cd\u4f5c\u7b26\u3002</p> <p>\u5728\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf <code>current_proc</code>\uff0c\u5b83\u662f\u4e00\u4e2a\u6307\u5411 <code>struct proc</code> \u7ed3\u6784\u4f53\u7684\u6307\u9488\uff1b\u6211\u4eec\u4e5f\u5b9a\u4e49\u4e86\u4e00\u4e2a <code>idle</code> \u53d8\u91cf\uff0c\u5b83\u7684\u7c7b\u578b\u662f <code>struct proc</code> \u7ed3\u6784\u4f53\u3002</p> <pre><code>struct proc *current_proc;\nstruct proc idle;\n\nvoid proc_init()\n{\n    current_proc = &amp;idle;\n}\n\nvoid test()\n{\n    current_proc-&gt;pid = 0x114514;\n}\n</code></pre> <p>\u5728\u5185\u5b58\u4e2d\uff0c\u8fd9\u4e24\u4e2a\u53d8\u91cf\u5c06\u6309\u7167\u4ee5\u4e0b\u683c\u5f0f\u6392\u5217\uff1a</p> <p></p> <p>\u5728 <code>proc_init</code> \u521d\u59cb\u5316\u51fd\u6570\u4e2d\uff0c\u6211\u4eec\u5c06 <code>idle</code> \u7684\u5730\u5740\u8d4b\u4e88 <code>current_proc</code>\uff08<code>&amp;</code> \u662f\u53d6\u5730\u5740\u7b26\uff09\u3002\u6b64\u65f6\uff0c<code>current_proc</code> \u7684\u503c\u5373\u662f <code>idle</code> \u53d8\u91cf\u7684\u8d77\u59cb\u5730\u5740\u3002</p> <p>\u4e3a\u4ec0\u4e48\u662f\u8d77\u59cb\u5730\u5740\uff1f</p> <p>\u8bb8\u591a\u4f53\u7cfb\u7ed3\u6784 (x86, ARM, RISC-V) \u5747\u5305\u542b Base displacement addressing (\u57fa\u5730\u5740 + \u504f\u79fb\u91cf) \u7684\u5bfb\u5740\u6a21\u5f0f\u3002 \u56e0\u4e3a\u7ed3\u6784\u4f53\u4e2d\u67d0\u4e2a\u53d8\u91cf\u76f8\u5bf9\u4e8e\u7ed3\u6784\u4f53\u57fa\u5730\u5740\u7684\u504f\u79fb\u91cf\u662f\u5728\u7f16\u8bd1\u671f\u5df2\u77e5\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u67d0\u4e2a\u5bc4\u5b58\u5668\u4fdd\u5b58\u8be5\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\uff0c\u4f7f\u7528 ld/sw \u6307\u4ee4\u4e2d\u7684\u7acb\u5373\u6570\u504f\u79fb\u91cf\u8bbf\u95ee\u7ed3\u6784\u4f53\u4e2d\u7684\u6210\u5458\u53d8\u91cf\u3002</p> <p>\u6211\u4eec\u5c06\u4ece\u6c47\u7f16\u5c42\u9762\u4e86\u89e3\u5982\u4f55\u8fdb\u884c\u7ed3\u6784\u4f53\u8bbf\u95ee\uff1a</p> <pre><code>        current_proc-&gt;pid = 0x114514;\n    802013c4:   004bb717                auipc   a4,0x4bb\n    802013c8:   c4c70713                addi    a4,a4,-948 # 806bc010 &lt;current_proc&gt;\n    802013cc:   00073683                ld      a3,0(a4)\n    802013d0:   001147b7                lui     a5,0x114\n    802013d4:   51478793                addi    a5,a5,1300 # 114514\n    802013d8:   00f6a223                sw      a5,4(a3)\n</code></pre> <p>\u8fd9\u4e00\u4e32\u6c47\u7f16\u5bf9\u5e94\u7684\u662f <code>current_proc-&gt;pid = 0x114514;</code> \u8bed\u53e5\u3002</p> <p>\u524d\u4e24\u884c\u6c47\u7f16\u901a\u8fc7 auipc + addi \u8ba1\u7b97\u51fa\u6765\u4e86 <code>current_proc</code> \u8fd9\u4e2a\u53d8\u91cf\u7684\u5730\u5740\uff1a</p> <pre><code>    802013c4:   004bb717                auipc   a4,0x4bb\n    802013c8:   c4c70713                addi    a4,a4,-948 # 806bc010 &lt;current_proc&gt;\n</code></pre> <p>\u7136\u540e\uff0c\u5c06\u8be5\u5730\u5740\u5904\u7684\u503c\u8bfb\u53d6\u5230 a3 \u4e2d\u3002\u6b64\u65f6\uff0ca3 \u4e2d\u5b58\u653e\u7684\u5373\u662f\u67d0\u4e2a <code>struct proc</code> \u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\u3002</p> <pre><code>    802013cc:   00073683                ld      a3,0(a4)\n</code></pre> <p>\u7136\u540e\uff0c\u901a\u8fc7 lui + addi \u6784\u9020\u7acb\u5373\u6570 0x114514\uff1a</p> <pre><code>    802013d0:   001147b7                lui     a5,0x114\n    802013d4:   51478793                addi    a5,a5,1300 # 114514\n</code></pre> <p>\u6700\u540e\uff0c\u5c06\u7acb\u5373\u6570 a5 \u5199\u5165 a3 + 4 \u7684\u5730\u5740\u5904\u3002\u8fd9\u91cc\u5373\u662f <code>struct proc</code> \u7ed3\u6784\u4f53\u4e2d\u7684 pid \u53d8\u91cf\u7684\u5730\u5740\u3002</p> <pre><code>    802013d8:   00f6a223                sw      a5,4(a3)\n</code></pre> <p>NULL-Pointer Dereference</p> <p>\u5f53\u6211\u4eec\u5c1d\u8bd5\u8bbf\u95ee\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u53d8\u91cf\u65f6\uff0c\u5982\u679c\u7ed3\u6784\u4f53\u6307\u9488\u662f\u4e00\u4e2a\u7a7a\u6307\u9488\uff0c\u90a3\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</p> <p>\u5728 <code>sw a5,4(a3)</code> \u65f6\uff0ca3 \u672c\u5e94\u8be5\u5b58\u50a8\u7740\u4e00\u4e2a\u5408\u6cd5\u5730\u5740\uff1b\u4f46\u662f\uff0c\u5f53\u5b83\u7684\u503c\u662f\u7a7a\u6307\u9488 0x0 \u65f6\uff0cCPU \u5c31\u4f1a\u5bf9 0x00000004 \u8fd9\u4e2a\u5730\u5740\u53d1\u8d77\u5199\u5165\uff0c\u8fd9\u4f1a\u89e6\u53d1 CPU \u7684\u8bbf\u5b58\u5f02\u5e38\uff0c\u5bfc\u81f4\u7a0b\u5e8f\u7ec8\u6b62\u3002</p> <p>\u73b0\u5728\uff0c\u4f60\u80fd\u731c\u5230\u4e3a\u4ec0\u4e48\u6709\u7684\u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u65f6\u4f1a\u5d29\u6e83 \"The instruction at 0xdeadbeef referenced memory at 0x00000008. The memory could not be written.\" \u4e86\u5417\uff1f</p>"},{"location":"env/","title":"\u5f00\u53d1\u73af\u5883\u914d\u7f6e","text":"<p>\u5728\u8fd9\u90e8\u5206\u5185\u5bb9\u4e2d\uff0c\u6211\u4eec\u5c06\u5411\u540c\u5b66\u4eec\u4ecb\u7ecd Linux \u53d1\u884c\u7248\uff0c\u4ee5\u5907\u540e\u7eed\u5b9e\u9a8c\u3002</p> <p>Linux\u662f\u4e00\u4e2a\u514d\u8d39\u53ef\u7528\u7684\u64cd\u4f5c\u7cfb\u7edf\uff0c\u975e\u5e38\u9002\u7528\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5f00\u53d1\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u9a8c\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 Ubuntu 24.04 LTS \u4f5c\u4e3a\u6807\u51c6\u7684\u5b9e\u9a8c\u73af\u5883\u3002</p> <p>Warning</p> <p>\u5373\u4fbf\u90e8\u5206\u540c\u5b66\u4eec\u5df2\u7ecf\u62e5\u6709\u4e00\u4e2a\u8fd0\u884c\u7740 Linux \u53d1\u884c\u7248\u7684\u7269\u7406\u673a\u6216\u865a\u62df\u673a\u73af\u5883\uff0c\u6211\u4eec\u4f9d\u7136\u8981\u6c42\u8bf8\u4f4d\u540c\u5b66\u53c2\u7167\u4e0b\u8ff0\u6587\u6863\u4e3a\u8fd9\u95e8\u8bfe\u51c6\u5907\u4e00\u4e2a\u65b0\u7684\u6807\u51c6\u73af\u5883\uff0c\u4ee5\u51cf\u5c11\u53ef\u80fd\u51fa\u73b0\u7684\u95ee\u9898\u3002</p> <p>\u6b64\u5916\uff0c\u6211\u4eec\u8981\u6c42\u5404\u4f4d\u540c\u5b66\u5728\u7cfb\u7edf\u540d\u4e2d\u8bbe\u7f6e\u81ea\u5df1\u7684\u5b66\u53f7\uff0c\u4ee5\u5907Lab\u5b9e\u9a8c\u6216\u8bfe\u7a0b\u4f5c\u4e1a\u9700\u8981\u63d0\u4ea4\u622a\u56fe\u3002</p> <p>\u4e3a\u4e86\u5e94\u5bf9\u540e\u7eed\u7684\u5b9e\u9a8c\uff0c\u6211\u4eec\u63a8\u8350\u540c\u5b66\u4eec\u9009\u62e9 Ubuntu LTS \u6216 Debian stable\uff0c\u5e76\u52a0\u88c5\u56fe\u5f62\u754c\u9762\u3002</p> <p>\u4f60\u4e5f\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528 SSH + vscode \u8fdb\u884c\u8fdc\u7a0b\u5f00\u53d1\uff0c\u5373\u5728\u4f60\u7684\u5bbf\u4e3b\u673a \uff08\u901a\u5e38\u662f Windows \u6216 macOS \u7cfb\u7edf\uff09\u4e0a\u4f7f\u7528 vscode \u6216 SSH \u8fde\u63a5\u5230\u4f60\u7684\u865a\u62df\u673a\u4e2d\u8fdb\u884c\u5f00\u53d1\u3002</p>"},{"location":"env/#linux","title":"\u642d\u5efa Linux \u865a\u62df\u73af\u5883","text":"<p>\u6211\u4eec\u63a8\u8350\u4f7f\u7528 VMware \u4f5c\u4e3a\u865a\u62df\u673a\u8f6f\u4ef6\uff0c\u5e76\u5bf9 Windows (amd64) \u548c macOS (arm64, Apple Silicon) \u63d0\u4f9b\u652f\u6301\u3002</p> <ul> <li> <p>\u8bf7\u4f60\u53c2\u7167\u5217\u8868\u4e2d\u7684\u65b9\u6848\u8fdb\u884c VMware \u5b89\u88c5\u540e\uff0c\u5bfc\u5165\u6211\u4eec\u9884\u5148\u63d0\u4f9b\u7684\u865a\u62df\u73af\u5883(OVF)\u3002</p> </li> <li> <p>\u5982\u679c\u4f60\u9009\u62e9\u4ece\u96f6\u5b89\u88c5 Linux \u865a\u62df\u673a\uff0c\u8bf7\u4f60\u5b89\u88c5 Ubuntu LTS / Debian stable\uff0c\u5e76\u53c2\u7167 \u624b\u52a8\u73af\u5883\u914d\u7f6e \u5b89\u88c5 RISC-V gcc \u5de5\u5177\u94fe\u3001QEMU \u6a21\u62df\u5668\u7b49\u3002</p> </li> </ul> <p>\u6700\u540e\uff0c\u4f60\u53ef\u4ee5\u8003\u8651\u914d\u7f6e VSCode \u5f00\u53d1\u5de5\u5177\u4ee5\u53ca\u9a8c\u8bc1\u73af\u5883\u53ef\u7528\u3002</p> <p>Note</p> <p>\u8bf7\u540c\u5b66\u4eec\u5728\u5b89\u88c5\u7cfb\u7edf\u65f6\u989d\u5916\u6ee1\u8db3\u5982\u4e0b\u8981\u6c42\uff1a</p> <ol> <li>\u5728\u8bbe\u5b9a\u7684\u7cfb\u7edf\u540d\u4e2d\u5305\u542b\u4f60\u7684\u5b66\u53f7\u3002</li> <li>\u8bed\u8a00\u5c3d\u91cf\u9009\u62e9\u82f1\u6587\uff0c\u4e2d\u6587\u8def\u5f84\u53ef\u80fd\u5bfc\u81f4\u90e8\u5206\u5b9e\u9a8c\u5185\u5bb9\u65e0\u6cd5\u987a\u5229\u5b8c\u6210\u3002</li> </ol>"},{"location":"env/helloworld/","title":"\u9a8c\u8bc1\u73af\u5883","text":""},{"location":"env/helloworld/#_1","title":"\u7f16\u8bd1\u4e0e\u8fd0\u884c\u5185\u6838","text":"<p>\u514b\u9686\u5185\u6838\u4ee3\u7801\u548c\u7528\u6237\u7a0b\u5e8f\u4ee3\u7801\u4ed3\u5e93\uff1a</p> <pre><code>git clone https://github.com/yuk1i/SUSTechOS\ncd SUSTechOS\ngit clone https://github.com/yuk1i/SUSTechOS-2025S-user user\n</code></pre> <p>\u7f16\u8bd1\u7528\u6237\u7a0b\u5e8f\uff1a</p> <pre><code>make user\n</code></pre> <p>\u7f16\u8bd1\u5185\u6838:</p> <pre><code>make\n</code></pre> <p>\u5728 QEMU \u4e2d\u8fd0\u884c\u5185\u6838\uff1a</p> <pre><code>make run\n</code></pre> <p>\u5982\u679c\u4e00\u5207\u6b63\u5e38\uff0c\u4f60\u5c06\u80fd\u591f\u770b\u5230\uff1a</p> <pre><code>OpenSBI v1.5\n   ____                    _____ ____ _____\n  / __ \\                  / ____|  _ \\_   _|\n | |  | |_ __   ___ _ __ | (___ | |_) || |\n | |  | | '_ \\ / _ \\ '_ \\ \\___ \\|  _ &lt; | |\n | |__| | |_) |  __/ | | |____) | |_) || |_\n  \\____/| .__/ \\___|_| |_|_____/|____/_____|\n        | |\n        |_|\n\nPlatform Name             : riscv-virtio,qemu\nPlatform Features         : medeleg\nPlatform HART Count       : 1\nPlatform IPI Device       : aclint-mswi\nPlatform Timer Device     : aclint-mtimer @ 10000000Hz\nPlatform Console Device   : uart8250\nPlatform HSM Device       : ---\nPlatform PMU Device       : ---\nPlatform Reboot Device    : syscon-reboot\nPlatform Shutdown Device  : syscon-poweroff\nPlatform Suspend Device   : ---\nPlatform CPPC Device      : ---\nFirmware Base             : 0x80000000\nFirmware Size             : 327 KB\nFirmware RW Offset        : 0x40000\nFirmware RW Size          : 71 KB\nFirmware Heap Offset      : 0x49000\nFirmware Heap Size        : 35 KB (total), 2 KB (reserved), 11 KB (used), 21 KB (free)\nFirmware Scratch Size     : 4096 B (total), 416 B (used), 3680 B (free)\nRuntime SBI Version       : 2.0\n\nDomain0 Name              : root\nDomain0 Boot HART         : 0\nDomain0 HARTs             : 0*\nDomain0 Region00          : 0x0000000000100000-0x0000000000100fff M: (I,R,W) S/U: (R,W)\nDomain0 Region01          : 0x0000000010000000-0x0000000010000fff M: (I,R,W) S/U: (R,W)\nDomain0 Region02          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()\nDomain0 Region03          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()\nDomain0 Region04          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()\nDomain0 Region05          : 0x000000000c400000-0x000000000c5fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region06          : 0x000000000c000000-0x000000000c3fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region07          : 0x0000000000000000-0xffffffffffffffff M: () S/U: (R,W,X)\nDomain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\nDomain0 SysReset          : yes\nDomain0 SysSuspend        : yes\n\nBoot HART ID              : 0\nBoot HART Domain          : root\nBoot HART Priv Version    : v1.12\nBoot HART Base ISA        : rv64imafdch\nBoot HART ISA Extensions  : sstc,zicntr,zihpm,zicboz,zicbom,sdtrig,svadu\nBoot HART PMP Count       : 16\nBoot HART PMP Granularity : 2 bits\nBoot HART PMP Address Bits: 54\nBoot HART MHPM Info       : 16 (0x0007fff8)\nBoot HART Debug Triggers  : 2 triggers\nBoot HART MIDELEG         : 0x0000000000001666\nBoot HART MEDELEG         : 0x0000000000f0b509\n\n\n=====\nHello World!\n=====\n\nBoot stack: 0x000000008021d000\nclean bss: 0x000000008021e000 - 0x0000000080228000\nBoot m_hartid 0\n[INFO  0,-1] bootcpu_entry: basic smp inited, thread_id available now, we are cpu 0: 0x00000000802270d8\nKernel Starts Relocating...\nKernel size: 0x0000000000028000, Rounded to 2MiB: 0x0000000000200000\n[INFO  0,-1] bootcpu_start_relocation: Kernel phy_base: 0x0000000080200000, phy_end_4k:0x0000000080228000, phy_end_2M 0x0000000080400000\nMapping Identity: 0x0000000080200000 to 0x0000000080200000\nMapping kernel image: 0xffffffff80200000 to 0x0000000080200000\nMapping Direct Mapping: 0xffffffc080400000 to 0x0000000080400000\nEnable SATP on temporary pagetable.\nBoot HART Relocated. We are at high address now! PC: 0xffffffff80203cc4\n[INFO  0,-1] kvm_init: boot-stage page allocator: base 0xffffffc080400000, end 0xffffffc080600000\n[INFO  0,-1] kvmmake: Memory after kernel image (phys) size = 0x0000000003c00000\n[INFO  0,-1] kvm_init: enable pageing at 0x8000000000080400\n[INFO  0,-1] kvm_init: boot-stage page allocator ends up: base 0xffffffc080400000, used: 0xffffffc080411000\nRelocated. Boot halt sp at 0xffffffffff001fb0\nBoot another cpus.\n- booting hart 1: hsm_hart_start(hartid=1, pc=_entry_sec, opaque=1) = -3. waiting for hart online\nskipped for hart 1\n- booting hart 2: hsm_hart_start(hartid=2, pc=_entry_sec, opaque=1) = -3. waiting for hart online\nskipped for hart 2\n- booting hart 3: hsm_hart_start(hartid=3, pc=_entry_sec, opaque=1) = -3. waiting for hart online\nskipped for hart 3\nSystem has 1 cpus online\n\nUART inited.\n[INFO  0,-1] kpgmgrinit: page allocator init: base: 0xffffffc080411000, stop: 0xffffffc084000000\n[INFO  0,-1] allocator_init: allocator mm inited base 0xfffffffd00000000\n[INFO  0,-1] allocator_init: allocator vma inited base 0xfffffffd01000000\n[INFO  0,-1] allocator_init: allocator proc inited base 0xfffffffd02000000\n[INFO  0,-1] allocator_init: allocator kstrbuf inited base 0xfffffffd03000000\napplist:\n        init\n        sh\n        test_arg\n        test_malloc\n[INFO  0,-1] load_init_app: load init proc init\n[INFO  0,-1] bootcpu_init: start scheduler!\ninit: starting sh\n</code></pre>"},{"location":"env/setup/","title":"\u624b\u52a8\u73af\u5883\u914d\u7f6e","text":""},{"location":"env/setup/#_1","title":"\u624b\u52a8\u914d\u7f6e\u5f00\u53d1\u73af\u5883","text":"<p>\u5982\u679c\u4f60\u4f7f\u7528\u6211\u4eec\u6253\u5305\u7684 ovf \u683c\u5f0f\u7684\u955c\u50cf\uff0c\u4f60\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e00\u6b65</p> <p>\u5230\u8fd9\u4e00\u6b65\u65f6\uff0c\u8bf7\u786e\u4fdd\u4f60\u5df2\u7ecf\u914d\u7f6e\u597d Linux \u73af\u5883\uff0c\u80fd\u6253\u5f00\u4e00\u4e2a Terminal \u6267\u884c\u547d\u4ee4\u3002</p> <p>Warning</p> <p>\u8bf7\u4f7f\u7528\u5c3d\u53ef\u80fd\u65b0\u7684\u53d1\u884c\u7248\u672c\u3002\u4ee5\u4e0b\u4ee3\u7801\u5747\u5df2 Ubuntu 24.04 LTS \u4e3a\u57fa\u51c6\u3002</p>"},{"location":"env/setup/#gcc-qemu","title":"\u5b89\u88c5 gcc \u5de5\u5177\u94fe\u4ee5\u53ca QEMU","text":"<p>\u4f7f\u7528\u5305\u7ba1\u7406\u5668 apt \u5b89\u88c5\u4f9d\u8d56\uff1a</p> <pre><code>sudo apt update &amp;&amp; sudo apt install gcc-riscv64-unknown-elf qemu-system-misc git make cmake python3-pip elfutils gdb-multiarch\n</code></pre> <p>\u5b89\u88c5\u5b8c\u6210\u540e\uff0c\u8fd0\u884c <code>riscv64-unknown-elf-gcc --version</code>\uff0c<code>qemu-system-riscv64 --version</code> \u548c <code>gdb-multiarch --version</code> \u68c0\u67e5\u7248\u672c\uff1a</p> <pre><code>$ riscv64-unknown-elf-gcc --version\nriscv64-unknown-elf-gcc (13.2.0-11ubuntu1+12) 13.2.0\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n$ qemu-system-riscv64 --version\nQEMU emulator version 8.2.2 (Debian 1:8.2.2+ds-0ubuntu1)\nCopyright (c) 2003-2023 Fabrice Bellard and the QEMU Project developers\n\n$ gdb-multiarch --version\nGNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git\nCopyright (C) 2024 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n</code></pre> <p>\u8bf7\u786e\u4fdd gcc \u7248\u672c &gt;= 13.0.0\uff0cqemu-system-riscv64 \u7248\u672c &gt;= 8.0.0\uff0cgdb-multiarch \u7248\u672c &gt;= 15</p> <p>\u5982\u679c\u4f60\u5747\u5b89\u88c5\u597d\u4e86\u4ee5\u4e0a\u4f9d\u8d56\uff0c\u8bf7\u5c1d\u8bd5\u7f16\u8bd1\u5e76\u8fd0\u884c Hello World</p>"},{"location":"env/setup/#_2","title":"\u4f7f\u7528\u81ea\u7f16\u8bd1\u7684\u5de5\u5177\u94fe","text":"<p>Warning</p> <p>\u5982\u6709\u53ef\u80fd\uff0c\u8bf7\u5c3d\u91cf\u4f7f\u7528\u53d1\u884c\u7248\u81ea\u5e26\u7684\u5de5\u5177\u94fe/QEMU \u7b49\u3002</p> <p>\u5982\u679c\u4f60\u5728\u4f7f\u7528\u53d1\u884c\u7248\u7684 gcc/qemu \u65f6\u9047\u5230\u95ee\u9898\uff0c\u5e76\u4e14\u4f60\u786e\u5b9a\u662f\u73af\u5883\u4e0d\u4e00\u81f4\u5bfc\u81f4\u7684\u95ee\u9898\uff0c\u4f60\u53ef\u4ee5\u53c2\u7167\u8be5\u6587\u6863\u4ece\u96f6\u7f16\u8bd1\u6574\u4e2a\u5de5\u5177\u94fe\u3002</p>"},{"location":"env/setup/#risc-v","title":"\u5b89\u88c5RISC-V\u5de5\u5177\u94fe","text":"<p>\u53c2\u7167 https://github.com/riscv-collab/riscv-gnu-toolchain\uff1a</p> <pre><code>$ sudo -i\n$ git clone https://github.com/riscv/riscv-gnu-toolchain\n$ sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev\n$ mkdir -p /opt/riscv\n$ ./configure --prefix=/opt/riscv\n$ make\n</code></pre>"},{"location":"env/vscode/","title":"VSCode \u8fdc\u7a0b\u914d\u7f6e","text":""},{"location":"env/vscode/#_1","title":"\u65e5\u5e38\u5f00\u53d1\u5efa\u8bae","text":""},{"location":"env/vm/macos/","title":"macOS + VMware Fusion","text":""},{"location":"env/vm/macos/#vmware-fusion","title":"\u5b89\u88c5 VMware Fusion","text":"<p>\u5728 https://dl.cra.moe/CS302-OS-2025-Spring/ \u4e0b\u8f7d VMware-funsion-macOS.zip\u3002\u6253\u5f00 Finder\uff0c\u89e3\u538b\u8be5 zip \u540e\u5728 payload \u6587\u4ef6\u5939\u4e0b\u6709\u4e00\u4e2a \"VMware Fusion\"\uff0c\u5c06\u5b83\u62d6\u5230\u5de6\u4fa7\"\u5e94\u7528\u7a0b\u5e8f\"\u540e\u5373\u53ef\u3002</p> <p>\u7528 Spotlight \u6253\u5f00 VMware fusion\uff0c\u540c\u610f\u6240\u6709\u6743\u9650\u8981\u6c42\u3002</p> <p>\u4f60\u53ef\u4ee5\u9009\u62e9\u76f4\u63a5\u5bfc\u5165 OVF\uff0c\u6216\u8005\u624b\u52a8\u521b\u5efa Debian \u865a\u62df\u673a\u3002</p> <p>\u8bf7\u4f60\u5148\u786e\u8ba4\u4f60\u7684 macOS \u7cfb\u7edf\u7684 CPU \u7c7b\u578b\u662f Intel \u8fd8\u662f Apple Silicon (Apple M\u7cfb\u5217\u5904\u7406\u5668)\u3002\u76ee\u524d\uff0c\u6211\u4eec\u53ea\u63d0\u4f9b\u5bf9 Apple M\u7cfb\u5217\u5904\u7406\u5668\u7684\u652f\u6301\uff0c\u4e0d\u63d0\u4f9b Intel \u7cfb\u5217\u5904\u7406\u5668\u7684\u652f\u6301\u3002</p>"},{"location":"env/vm/macos/#_1","title":"\u5bfc\u5165\u5df2\u5b89\u88c5\u597d\u7684\u955c\u50cf","text":"<p>\u5728 https://dl.cra.moe/CS302-OS-2025-Spring/ \u4e0b\u8f7d <code>OSLab-2025S-macOS-arm64 \u7684\u514b\u9686.zip</code>\uff0c\u4e0b\u8f7d\u540e\u89e3\u538b\u3002</p> <p>\u6253\u5f00 VMware Fusion\u3002\u5728\u83dc\u5355\u680f\u4e2d\uff1a \u7a97\u53e3 -&gt; \u865a\u62df\u673a\u8d44\u6e90\u5e93\u3002\u6253\u5f00\u865a\u62df\u673a\u5217\u8868\u3002</p> <p></p> <p>\u5c06\u89e3\u538b\u51fa\u6765\u7684 <code>OSLab-2025S-macOS-arm64 \u7684\u514b\u9686</code> \u76f4\u63a5\u62d6\u5230\u865a\u62df\u673a\u5217\u8868\u4e2d\u3002</p> <p></p> <p>\u53cc\u51fb\u542f\u52a8\uff0c\u5e76\u9a8c\u8bc1\u73af\u5883\u3002</p>"},{"location":"env/vm/windows-vmware/","title":"Windows + VMware","text":"<p>\u5728\u8fd9\u90e8\u5206\u5185\u5bb9\u4e2d\uff0c\u6211\u4eec\u5c06\u5f15\u5bfc\u540c\u5b66\u4eec\u5728windows\u7cfb\u7edf\u4e2d\u5b89\u88c5VMware Workstation Pro, \u5e76\u5728VMware\u4e2d\u914d\u7f6eUbuntu\u865a\u62df\u673a</p>"},{"location":"env/vm/windows-vmware/#vmware-workstation-pro-16","title":"\u5b89\u88c5 VMware Workstation Pro 16","text":"<p>\u540c\u5b66\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u94fe\u63a5\u4e0b\u8f7dVMware Workstation Pro 17\uff0c\u5e76\u5c06\u5176\u5b89\u88c5\u5728\u81ea\u5df1\u7684\u8ba1\u7b97\u673a\u4e2d\u3002</p> <p>https://dl.cra.moe/CS302-OS-2025-Spring/</p> <p>Download VMware Workstation Pro</p> <p></p> <p>\u63a5\u4e0b\u6765\uff0c\u5173\u4e8e\u5b89\u88c5 Ubuntu 24.04\uff0c\u6211\u4eec\u63d0\u4f9b\u4e24\u79cd\u9009\u62e9\uff0c\u5927\u5bb6\u53ef\u4ee5\u9009\u62e9\u4e0b\u8f7d\u5df2\u7ecf\u642d\u8f7d\u5b9e\u9a8c\u73af\u5883\u7684 Ubuntu \u7cfb\u7edf\u955c\u50cf (OVF) \u5bfc\u5165\u8fdb\u865a\u62df\u673a\uff0c\u6216\u8005 Ubuntu \u5b98\u65b9\u539f\u7248\u955c\u50cf\u3002</p>"},{"location":"env/vm/windows-vmware/#ubuntu2404","title":"\u5b89\u88c5Ubuntu24.04","text":"<p>1. \u5bfc\u5165\u5df2\u642d\u8f7d\u5b9e\u9a8c\u73af\u5883\u7684\u7cfb\u7edf\u955c\u50cf</p> <p>\u6b64\u6b65\u9aa4\u4e3a\u5728VMware\u4e2d\u5bfc\u5165\u5df2\u7ecf\u642d\u8f7d\u5b9e\u9a8c\u73af\u5883\u7684\u7cfb\u7edf\u955c\u50cf\u3002\u5982\u4f60\u5df2\u7ecf\u62e5\u6709\u4e00\u4e2a\u73b0\u6709\u73af\u5883\uff0c\u4f8b\u5982\u4f60\u81ea\u5df1\u7684\u7528\u7684 Linux \u865a\u62df\u673a/\u7269\u7406\u673a\u73af\u5883\uff0c\u53ef\u53c2\u8003 <code>\u624b\u52a8\u73af\u5883\u914d\u7f6e</code> \u7684\u6b65\u9aa4\u5728\u7cfb\u7edf\u4e2d\u914d\u7f6e\u5b9e\u9a8c\u73af\u5883\uff0c\u4e0d\u8fc7\u6211\u4eec\u66f4\u52a0\u63a8\u8350\u4f7f\u7528\u6211\u4eec\u63d0\u4f9b\u7684\u73af\u5883\u4ee5\u9632\u6b62\u7cfb\u7edf\u7248\u672c\u5bfc\u81f4\u7684\u5b9e\u9a8c\u5dee\u5f02\u3002</p> <p>\u9996\u5148\u901a\u8fc7\u4ee5\u4e0b\u94fe\u63a5\u4e0b\u8f7dUbuntu24.04\u7684ovf\u683c\u5f0f\uff08Open Virtualization Format\uff09\u6587\u4ef6\u5e76\u8fdb\u884c\u89e3\u538b\u3002</p> <p></p> <p>\u4e4b\u540e\uff0c\u6253\u5f00VMware\u9009\u62e9<code>\u6587\u4ef6</code>-&gt;<code>\u6253\u5f00</code>\uff0c\u627e\u5230ovf\u6587\u4ef6\u9009\u62e9\u6253\u5f00\uff0c\u8f93\u5165\u865a\u62df\u673a\u540d\u79f0\u540e\u7b49\u5f85\u5bfc\u5165\u5b8c\u6210\u5373\u53ef\u3002</p> <p></p> <p></p> <p>2. \u5b89\u88c5\u5b98\u65b9ubuntu 24.04\u5e76\u914d\u7f6e\u5b9e\u9a8c\u73af\u5883</p> <p>\u540c\u5b66\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u94fe\u63a5\u4e0b\u8f7d\u539f\u7248Ubuntu24.04\u955c\u50cf\uff0c\u5e76\u5c06\u5176\u5b89\u88c5\u5728\u81ea\u5df1\u7684\u865a\u62df\u673a\u4e2d\u3002</p> <p>Download Ubuntu 24.04</p> <p></p> <p>\u4e0b\u8f7d\u597d\u955c\u50cf\u540e\uff0c\u6253\u5f00VMware workstation\uff0c\u9009\u62e9<code>\u521b\u5efa\u65b0\u7684\u865a\u62df\u673a</code>\uff1a</p> <p></p> <p>\u6839\u636e\u4ee5\u4e0b\u6307\u5f15\u5b8c\u6210\u865a\u62df\u673a\u914d\u7f6e\uff1a</p> <p>Note</p> <p>\u8bf7\u540c\u5b66\u4eec\u5728\u5b89\u88c5\u7cfb\u7edf\u65f6\u5c3d\u91cf\u6ee1\u8db3\u4ee5\u4e0b\u8981\u6c42\uff1a</p> <ol> <li> <p>\u8bed\u8a00\u5c3d\u91cf\u9009\u62e9\u82f1\u6587\uff0c\u4e2d\u6587\u8def\u5f84\u53ef\u80fd\u5bfc\u81f4\u5b9e\u9a8c\u5185\u5bb9\u65e0\u6cd5\u987a\u5229\u5b8c\u6210</p> </li> <li> <p>CPU\u5c3d\u91cf\u9009\u62e94\u6838\u6216\u4ee5\u4e0a</p> </li> <li> <p>\u865a\u62df\u673a\u786c\u76d8\u7a7a\u95f4\u5efa\u8bae\u9009\u62e930G\u4ee5\u4e0a</p> </li> </ol> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>\u4e4b\u540e\u8fd0\u884c\u865a\u62df\u673a\u5b8c\u6210\u865a\u62df\u673a\u5b89\u88c5\u5373\u53ef\u3002</p> <p>\u53e6\u5916\uff0c\u7531\u4e8e\u539f\u7248Ubuntu\u7cfb\u7edf\u4e0d\u5305\u542b\u672c\u8bfe\u7a0b\u5b9e\u9a8c\u7684\u5f00\u53d1\u73af\u5883\uff0c\u8fd8\u9700\u8981\u53c2\u8003<code>\u73af\u5883\u914d\u7f6e</code>\u5b8c\u6210\u5b9e\u9a8c\u5f00\u53d1\u73af\u5883\u914d\u7f6e\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u6211\u4eec\u8fd8\u63a8\u8350\u5b89\u88c5vscode\u7528\u4e8e\u4ee3\u7801\u7684\u9605\u8bfb\u4e0e\u7f16\u5199\u3002</p>"},{"location":"env/vm/wsl/","title":"Windows + WSL (\u4e0d\u63a8\u8350)","text":""},{"location":"env/vm/wsl/#windows-wsl","title":"Windows WSL \u8bbe\u7f6e","text":"<p>\u6211\u4eec\u4e0d\u5bf9 WSL \u73af\u5883\u4e0b\u9047\u5230\u7684\u95ee\u9898\u63d0\u4f9b\u5e2e\u52a9\u3002 \u5982\u679c\u4f60\u9047\u5230\u4e86\u4e00\u4e9b\u95ee\u9898\uff0c\u8bf7\u8003\u8651\u81ea\u884c\u89e3\u51b3\u6216\u5207\u6362\u4e3a VMware \u865a\u62df\u73af\u5883\u3002</p> <p>Windows WSL \u53ef\u80fd\u4f1a\u4e0d\u9002\u7528\u4e8e\u5728 Linux \u73af\u5883\u4e0b\u5237\u5199 VisionFive2 \u677f\u5b50\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u5728\u540e\u7eed\u5b9e\u9a8c\u63d0\u4f9b\u6587\u6863\u652f\u6301\u3002</p> <p>\u8bf7\u4f7f\u7528 Ubuntu 24.04 \u6216 Debian stable\u3002</p> <p>\u7136\u540e\uff0c\u8bf7\u53c2\u8003 \u624b\u52a8\u73af\u5883\u8bbe\u7f6e \u8bbe\u7f6e gcc \u5de5\u5177\u94fe\u548c QEMU \u6a21\u62df\u5668\u3002</p>"},{"location":"lab/lab1/","title":"Week 1 - Linux\u57fa\u7840","text":""},{"location":"lab/lab1/#linux","title":"Linux\u57fa\u7840","text":"<p>Note</p> <p>\u5728\u5b8c\u6210\u672c\u5b9e\u9a8c\u524d\uff0c\u8bf7\u53c2\u7167<code>\u5b9e\u9a8c\u73af\u5883\u642d\u5efa</code>\u5b8c\u6210\u5b9e\u9a8c\u73af\u5883\u7684\u914d\u7f6e</p> <p>\u672c\u90e8\u5206\u5185\u5bb9\u4e2d\uff0c\u6211\u4eec\u4f1a\u901a\u8fc7\u5b9e\u9a8c\u6b65\u9aa4\u719f\u6089Linux\u7684\u5e38\u7528\u547d\u4ee4\uff0c\u4ece\u800c\u5bf9Linux\u7cfb\u7edf\u6709\u4e00\u4e2a\u521d\u6b65\u4e86\u89e3\u3002</p>"},{"location":"lab/lab1/#step-1-terminal","title":"Step 1. \u6253\u5f00terminal","text":"<p>Terminal\uff08\u7ec8\u7aef\uff09\u662f\u4e00\u4e2a\u547d\u4ee4\u884c\u754c\u9762\uff0c\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u8f93\u5165\u6587\u672c\u547d\u4ee4\u4e0e\u64cd\u4f5c\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\u3002\u5b83\u662f Ubuntu \u548c\u5176\u4ed6\u57fa\u4e8e Linux \u7684\u64cd\u4f5c\u7cfb\u7edf\u7684\u6838\u5fc3\u5de5\u5177\u4e4b\u4e00\uff0c\u5141\u8bb8\u7528\u6237\u6267\u884c\u5404\u79cd\u4efb\u52a1\uff0c\u5982\u6587\u4ef6\u7ba1\u7406\u3001\u8f6f\u4ef6\u5b89\u88c5\u3001\u7cfb\u7edf\u914d\u7f6e\u7b49\u3002</p> <p>\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4e09\u79cd\u65b9\u5f0f\u6253\u5f00\u7ec8\u7aefterminal</p> <ul> <li>\u4f7f\u7528\u5feb\u6377\u952e\uff1a<code>Ctrl + Alt + T</code></li> <li>\u5728Show Applications\u4e2d\u641c\u7d22Terminal\u540e\u5355\u51fb\u6253\u5f00</li> <li>\u5728\u684c\u9762\u6216\u8005\u6587\u4ef6\u5939\u5185\u70b9\u51fb\u9f20\u6807\u53f3\u952e\uff0c\u9009\u62e9Open in Terminal</li> </ul> <p>\u4e0b\u56fe\u662fTerminal\u7684\u4e00\u4e2a\u57fa\u672c\u754c\u9762</p> <p></p> <p>\u4e0a\u56fe\u4e2d\uff1a</p> <ul> <li> <p>sy-OSlab\u4ee3\u8868\u5f53\u524d\u4e3b\u673a\u540d</p> </li> <li> <p>sy\u4ee3\u8868\u5f53\u524d\u7528\u6237\u540d</p> </li> <li> <p>~/Desktop\u4ee3\u8868\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\uff0c\u76f8\u5f53\u4e8e\u4f60\u7684\u6240\u6709\u547d\u4ee4\u90fd\u662f\u5728\u8fd9\u4e2a\u76ee\u5f55\u6267\u884c\u7684</p> </li> <li> <p>~\u4ee3\u8868\u76f8\u5bf9\u8def\u5f84\u201c/home/\u7528\u6237\u540d\u201d\uff0c\u76f8\u5f53\u4e8e\u5f53\u524d\u7528\u6237\u6240\u5c5e\u7684\u76ee\u5f55</p> </li> <li> <p>$\u4ee3\u8868\u76ee\u524d\u7528\u6237\u4e3a\u666e\u901a\u7528\u6237\u975e\u7ba1\u7406\u5458\u7528\u6237</p> </li> <li> <p>\u901a\u8fc7\u952e\u76d8\u7684\u4e0a\u3001\u4e0b\u6309\u94ae\u53ef\u4ee5\u9009\u62e9\u5386\u53f2\u547d\u4ee4</p> </li> <li> <p>\u901a\u8fc7\u8f93\u5165\u90e8\u5206\u8def\u5f84\u6216\u6587\u4ef6\u540d\u540e\u70b9\u51fbTab\u952e\u53ef\u4ee5\u81ea\u52a8\u8865\u5168</p> </li> </ul> <p>CUI vs GUI</p> <p>CUI(Command User Interface)\uff0c\u547d\u4ee4\u884c\u7528\u6237\u63a5\u53e3\uff0c\u7528\u6237\u901a\u8fc7\u6587\u672c\u547d\u4ee4\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\uff0c\u5982windows\u7cfb\u7edf\u4e2d\u7684Command Line\u548c\u6211\u4eec\u5373\u5c06\u4f7f\u7528\u7684Linux\u7cfb\u7edf\u7684Terminal\u3002\u5728\u672c\u8bfe\u7a0b\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u4e3b\u8981\u901a\u8fc7CUI\u64cd\u4f5c\u5b8c\u6210\u5b9e\u9a8c\u3002</p> <p>GUI(Graphical User Interface)\uff0c\u56fe\u5f62\u7528\u6237\u63a5\u53e3\uff0c\u7528\u6237\u901a\u8fc7\u5bf9\u56fe\u5f62\u5316\u7684\u754c\u9762\u8fdb\u884c\u591a\u79cd\u5f62\u5f0f\uff08\u9f20\u6807\u3001\u952e\u76d8\u7b49\u8f93\u5165\u8bbe\u5907\uff09\u7684\u64cd\u4f5c\u6765\u4e0e\u7cfb\u7edf\u8fdb\u884c\u4ea4\u4e92\uff0c\u5982\u6211\u4eec\u65e5\u5e38\u4f7f\u7528\u7684\u7535\u8111\u684c\u9762\u7cfb\u7edf\u53ca\u624b\u673a\u64cd\u4f5c\u3002</p>"},{"location":"lab/lab1/#step-2-ls-man-pwd-cd-mkdir-rm-cp-mv-history","title":"Step 2. \u5e38\u7528\u6307\u4ee4\uff1als, man, pwd, cd, mkdir, rm, cp, mv, history","text":""},{"location":"lab/lab1/#ls","title":"ls\u547d\u4ee4","text":"<p>\u5217\u51fa\u5f53\u524d\u8def\u5f84\u4e0b\u7684\u6240\u6709\u6587\u4ef6\uff08\u6587\u4ef6\u5939\uff09</p> <p></p> <p>\u8bf7\u5c1d\u8bd5\"ls -l\" \u53ca \"ls -a\"</p>"},{"location":"lab/lab1/#man","title":"man\u547d\u4ee4","text":"<p>\u5e2e\u52a9\u6307\u4ee4\uff0c\u901a\u8fc7man\u6307\u4ee4\u53ef\u4ee5\u67e5\u770blinux\u6307\u4ee4\u7684\u4f7f\u7528\u5e2e\u52a9</p> <p>\u8bf7\u5c1d\u8bd5\"man ls\"</p>"},{"location":"lab/lab1/#pwd","title":"pwd\u547d\u4ee4","text":"<p>\u67e5\u770b\u5f53\u524d\u76ee\u5f55\u5b8c\u6574\u7684\u7edd\u5bf9\u8def\u5f84</p> <p></p>"},{"location":"lab/lab1/#cd","title":"cd\u547d\u4ee4","text":"<p>\u8df3\u8f6c\u5de5\u4f5c\u76ee\u5f55</p> <p></p> <p>\"cd ..\"\uff0c\u8df3\u8f6c\u81f3\u4e0a\u7ea7\u76ee\u5f55</p> <p>\"cd \u8def\u5f84\"\u8df3\u8f6c\u81f3\u8def\u5f84\u7684\u76ee\u5f55</p> <p>\"cd /\"\u8df3\u8f6c\u81f3\u7cfb\u7edf\u6839\u76ee\u5f55\uff0clinux\u7cfb\u7edf\u6839\u76ee\u5f55\u4e3a/</p> <p>\"cd ~\"\u8df3\u8f6c\u81f3\u5f53\u524d\u7528\u6237\u76ee\u5f55\uff0c\u5373\"/home/\u7528\u6237\u540d\"\u76ee\u5f55</p>"},{"location":"lab/lab1/#mkdir","title":"mkdir\u547d\u4ee4","text":"<p>\u5728\u5f53\u524d\u76ee\u5f55\u521b\u5efa\u6587\u4ef6\u5939</p> <p></p> <p>linux\u7cfb\u7edf\u662f\u4e25\u683c\u533a\u5206\u5927\u5c0f\u5199\u7684\uff0c\u540c\u4e00\u4e2a\u5b57\u6bcd\u7684\u5927\u5c0f\u5199\u4f1a\u4f5c\u4e3a\u4e0d\u540c\u7684\u4e24\u4e2a\u5b57\u6bcd</p>"},{"location":"lab/lab1/#rm","title":"rm\u547d\u4ee4","text":"<p>\u5220\u9664\u6587\u4ef6\u6216\u6587\u4ef6\u5939</p> <p></p> <p>\u5220\u9664\u6587\u4ef6\u5939\u65f6\u53ef\u80fd\u4f1a\u78b0\u5230\u4ee5\u4e0b\u62a5\u9519</p> <p></p> <p>\u8fd9\u662f\u7531\u4e8e\u6587\u4ef6\u5939\u4e0e\u6587\u4ef6\u4e0d\u540c\uff0c\u6587\u4ef6\u5939\u5185\u53ef\u80fd\u6709\u6587\u4ef6\u6216\u6587\u4ef6\u5939\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u201c\u9012\u5f52\u5730\u201d\u8fdb\u884c\u5220\u9664\uff0c\u56e0\u6b64\u5728\u5220\u9664\u65f6\u589e\u52a0 -r  \u53c2\u6570\u4ee5\u9012\u5f52\u5730\u5220\u9664\u6587\u4ef6\u5939</p> <p></p>"},{"location":"lab/lab1/#cp","title":"cp\u547d\u4ee4","text":"<p>\u590d\u5236\u6587\u4ef6\u6216\u6587\u4ef6\u5939</p> <p></p> <p>\u8bf7\u5c1d\u8bd5\u901a\u8fc7cp\u547d\u4ee4\u590d\u5236\u6587\u4ef6\u5939</p>"},{"location":"lab/lab1/#mv","title":"mv\u547d\u4ee4","text":"<p>\u79fb\u52a8\u6587\u4ef6\u6216\u6587\u4ef6\u5939\uff0c\u540c\u76ee\u5f55\u4e0b\u79fb\u52a8\u76f8\u5f53\u4e8e\u91cd\u547d\u540d\u64cd\u4f5c</p> <p></p>"},{"location":"lab/lab1/#history","title":"history\u547d\u4ee4","text":"<p>\u67e5\u770b\u5386\u53f2\u547d\u4ee4</p>"},{"location":"lab/lab1/#step-3-echo-find-cat-grep-pipe","title":"Step 3. \u5e38\u7528\u6307\u4ee4: echo, find, cat, grep, |(pipe)\uff0c&gt;\uff0c&gt;&gt;\uff0c&lt;","text":""},{"location":"lab/lab1/#echo","title":"echo\u547d\u4ee4","text":"<p>\u8f93\u51fa\u5185\u5bb9</p> <p></p>"},{"location":"lab/lab1/#find","title":"find\u547d\u4ee4","text":"<p>\u67e5\u627e\u6587\u4ef6</p> <p></p> <p>\u53ef\u4ee5\u6307\u5b9a\u901a\u8fc7\u6587\u4ef6\u540d\u3001\u6587\u4ef6\u7c7b\u578b\u3001\u5927\u5c0f\u7b49\u4fe1\u606f\u8fdb\u884c\u67e5\u627e</p>"},{"location":"lab/lab1/#cat","title":"cat\u547d\u4ee4","text":"<p>\u5728terminal\u4e2d\u67e5\u770b\u6587\u4ef6\u5185\u5bb9</p> <p></p> <p>\u76f8\u5173\u7684\u547d\u4ee4\u8fd8\u6709head, tail, more, less\uff0c\u53ef\u4ee5\u5b9e\u73b0\u770b\u6587\u4ef6\u5934\u5c3e\uff0c\u5206\u9875\u67e5\u770b\u7684\u529f\u80fd</p> <p></p>"},{"location":"lab/lab1/#grep","title":"grep\u547d\u4ee4","text":"<p>\u67e5\u627e\u6587\u4ef6\u4e2d\u7b26\u5408\u6761\u4ef6\u7684\u5b57\u7b26\u4e32</p> <p></p>"},{"location":"lab/lab1/#pipe","title":"| (pipe)\u64cd\u4f5c\u7b26","text":"<p>\u5c06|\u7b26\u53f7\u524d\u547d\u4ee4\u7684\u8f93\u51fa\u4f5c\u4e3a|\u7b26\u53f7\u540e\u547d\u4ee4\u7684\u8f93\u5165</p> <p></p>"},{"location":"lab/lab1/#_1","title":"&gt; , &gt;&gt;, &lt; \u64cd\u4f5c\u7b26","text":"<p>\u91cd\u5b9a\u5411\u8f93\u5165\u8f93\u51fa</p> <p></p> <p>&gt;\u53ef\u4ee5\u5c06\u8f93\u51fa\u91cd\u5b9a\u5411\u5230\u6587\u4ef6\uff0c\u4e0a\u56fe\u4e2d\u5373\u5c06ls\u6307\u4ee4\u7684\u7ed3\u679c\u8f93\u51fa\u5230test\u6587\u4ef6\u4e2d</p> <p>\u8bf7\u5c1d\u8bd5&gt;&gt;, &lt;\u64cd\u4f5c\u7b26\u7684\u529f\u80fd</p>"},{"location":"lab/lab1/#step-4-sudo-chmod","title":"Step 4. \u5e38\u7528\u6307\u4ee4: sudo, chmod","text":""},{"location":"lab/lab1/#sudo","title":"sudo\u6307\u4ee4","text":"<p>\u4f7f\u7528\u7ba1\u7406\u5458\u6743\u9650\u6267\u884c\u540e\u9762\u7684\u547d\u4ee4</p> <p></p> <p>\u5f53\u6211\u4eec\u9700\u8981\u6267\u884c\u4e00\u4e9b\u6307\u4ee4\uff0c\u4f46\u662f\u6ca1\u6709\u7ba1\u7406\u5458\u6743\u9650\u65e0\u6cd5\u6267\u884c\u65f6\uff0c\u53ef\u4f7f\u7528sudo\u6307\u4ee4</p> <p>\u8bf7\u5c3d\u91cf\u4e0d\u8981\u5c1d\u8bd5\"sudo rm -rf /*\"</p>"},{"location":"lab/lab1/#chmod","title":"chmod\u6307\u4ee4","text":"<p>\u4fee\u6539\u6587\u4ef6\u6216\u6587\u4ef6\u5939\u7684\u6743\u9650</p> <p>\u901a\u8fc7\u201cls -l\u201d\u6307\u4ee4\u53ef\u4ee5\u67e5\u770b\u6587\u4ef6\u7684\u6743\u9650</p> <p></p> <p>\u4e0a\u56fe\u4e2d\u6587\u4ef6/\u6587\u4ef6\u5939\u6700\u524d\u65b9\u7684drwxrwxr-x\u4ee3\u8868\u8be5\u6587\u4ef6/\u6587\u4ef6\u5939\u7684\u6587\u4ef6\u6743\u9650\u3002\u5176\u6240\u4ee3\u8868\u7684\u542b\u4e49\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p>\u9700\u8981\u4fee\u6539\u6743\u9650\u53ef\u4ee5\u901a\u8fc7chmod\u547d\u4ee4</p> <p></p> <p>\u5982\u4e0a\u56fe\u6240\u793a\uff0cu\\g\\o\u5206\u522b\u4ee3\u8868user\\group\\other\u7c7b\u522b\u7528\u6237\uff0c+\u3001-\u3001=\u5206\u522b\u4ee3\u8868\u589e\u52a0\u3001\u51cf\u5c11\u3001\u8bbe\u7f6e\u4e3a\u76f8\u5e94\u7684\u6743\u9650\u3002</p> <p>chmod 775\u5219\u53ef\u4ee5\u5c06\u6240\u6709\u7ec4\u522b\u7684\u6743\u9650\u4e00\u6b21\u8bbe\u7f6e\u5b8c\u6210\uff0c\u6570\u5b577\u548c5\u5206\u522b\u4ee3\u8868\u4e8c\u8fdb\u5236111\u548c101\uff0c\u4e8c\u8fdb\u5236\u4f4d\u4e0a\u7684\u6570\u5b57\u5206\u522b\u4ee3\u8868rwx\u7684\u76f8\u5e94\u6743\u9650\uff0c\u5982101\u5373\u4ee3\u8868\"1\u53efr+0\u4e0d\u53efw+1\u53efx\"\uff0c\u56e0\u6b64chmod 775\u5373\u4ee3\u8868\u5c06\u8be5\u6587\u4ef6\u6743\u9650\u6539\u4e3auser\u7ec4\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c\uff0cgroup\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c\uff0cother\u53ef\u8bfb\u4e0d\u53ef\u5199\u53ef\u6267\u884c\u3002</p>"},{"location":"lab/lab1/#step-5-vim","title":"Step 5. \u5b89\u88c5vim","text":"<p>Vim \u662f\u4e00\u4e2a\u9ad8\u5ea6\u53ef\u914d\u7f6e\u7684\u6587\u672c\u7f16\u8f91\u5668\uff0c\u5e7f\u6cdb\u7528\u4e8e\u7f16\u7a0b\u548c\u6587\u672c\u7f16\u8f91\u3002\u5b83\u662f Vi \u7f16\u8f91\u5668\u7684\u6539\u8fdb\u7248\u672c\uff08Vi IMproved \u7684\u7f29\u5199\uff09\uff0c\u5728\u53ef\u4ee5\u5728\u7ec8\u7aef\u4e2d\u5bf9\u6587\u672c\u8fdb\u884c\u7f16\u8f91\u3002</p> <p>\u901a\u8fc7<code>apt-get install vim</code>\u6307\u4ee4\u5b89\u88c5vim\u8f6f\u4ef6</p> <p></p> <p>\u5b89\u88c5\u5b8c\u6210\u540e\u53ef\u4ee5\u901a\u8fc7vim\u6307\u4ee4\u521b\u5efa\u6216\u6253\u5f00\u6587\u4ef6</p> <p></p> <p></p> <p>\u901a\u8fc7vim\u6253\u5f00\u6587\u4ef6\u540e\u4f1a\u8fdb\u5165\u4e0a\u56fe\u7684Command mode\uff0cvim\u4e00\u5171\u6709\u4e09\u79cd\u6a21\u5f0f\uff1a</p> <ul> <li> <p>Command mode\uff1a\u7528\u6237\u6240\u6709\u7684\u8f93\u5165\u90fd\u662fcommand\u800c\u4e0d\u662f\u6587\u672c</p> </li> <li> <p>Insert mode\uff1a\u4eceCommand mode\u901a\u8fc7\u70b9\u51fbi\u952e\u8fdb\u5165Insert mode\uff0c\u8fdb\u5165\u540e\u53ef\u4ee5\u8fdb\u884c\u6587\u672c\u8f93\u5165\uff1b\u901a\u8fc7Esc\u6309\u94ae\u9000\u51faInsert mode\u56de\u5230Command mode</p> </li> <li> <p>Last line mode\uff1a\u4eceCommand mode\u901a\u8fc7\u8f93\u5165\u5192\u53f7\uff08shift+;\uff09\u8fdb\u5165\uff0cterminal\u6700\u540e\u4e00\u884c\u5de6\u4fa7\u4f1a\u51fa\u73b0\u201c:\u201d\uff0c\u6b64\u65f6\u53ef\u4ee5\u8f93\u5165\u7279\u6b8a\u6307\u4ee4\uff0c\u5982\"wq\"\u5373\u5199\u5165\uff08\u4fdd\u5b58\uff09\u540e\u9000\u51fa\uff08write and quit)</p> </li> </ul> <p></p>"},{"location":"lab/lab1/#step-6-gccc","title":"Step 6. \u901a\u8fc7gcc\u8fd0\u884c\u4e00\u4e2ac\u7a0b\u5e8f","text":""},{"location":"lab/lab1/#vim-helloc","title":"vim hello.c","text":"<p>\u901a\u8fc7vim\u521b\u5efa\u5e76\u5b8c\u6210\u4e00\u4e2a\u7b80\u5355\u7684\u6b7b\u5faa\u73af\u4ee3\u7801</p> <p></p> <p>\u4fdd\u5b58\u5e76\u9000\u51fa</p> <p></p>"},{"location":"lab/lab1/#gcc-helloc","title":"gcc hello.c","text":"<p>\u901a\u8fc7gcc\u6307\u4ee4\u5bf9\u8be5\u6587\u4ef6\u8fdb\u884c\u7f16\u8bd1\u5e76\u4ea7\u751f\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u672a\u6307\u5b9a\u8f93\u51fa\u6587\u4ef6\u540d\u7684\u60c5\u51b5\u4e0b\u53ef\u6267\u884c\u6587\u4ef6\u9ed8\u8ba4\u6587\u4ef6\u540d\u4e3aa.out\u3002\u66f4\u5177\u4f53\u7684gcc\u64cd\u4f5c\u8fc7\u7a0b\u5c06\u5728\u4e0b\u4e00\u6b21\u5b9e\u9a8c\u8bfe\u8fdb\u884c\u7ec3\u4e60\u3002\u672c\u8282\u8bfe\u6211\u4eec\u53ea\u9700\u8981\u80fd\u8fd0\u884c\u8d77\u4e00\u4e2a\u6700\u7b80\u5355\u7684c\u8bed\u8a00\u7a0b\u5e8f\u3002</p> <p></p>"},{"location":"lab/lab1/#aout","title":"./a.out","text":"<p>\u901a\u8fc7\"./a.out\"\u6307\u4ee4\u8fd0\u884ca.out\u6587\u4ef6\uff0c\u5176\u4e2d.\u7b26\u53f7\u4ee3\u8868\u5f53\u524d\u8def\u5f84</p> <p></p> <p>\u7531\u4e8e\u6211\u4eec\u5199\u7684\u662f\u4e00\u4e2a\u6b7b\u5faa\u73af\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u89c2\u5bdf\u5230\u7a0b\u5e8f\u6267\u884c\u540e\u8fdb\u5165\u4e86\u6b7b\u5faa\u73af\u3002</p>"},{"location":"lab/lab1/#step-7-ps-kill-pstree","title":"Step 7. \u5e38\u7528\u6307\u4ee4: ps, kill, pstree","text":""},{"location":"lab/lab1/#ps","title":"ps\u547d\u4ee4","text":"<p>\u6253\u5f00\u53e6\u4e00\u4e2aterminal\uff0c\u6267\u884cps\u6307\u4ee4\uff0c\u53ef\u4ee5\u67e5\u770b\u5f53\u524d\u4f1a\u8bdd\u4e2d\u7684\u8fdb\u7a0b\u5217\u8868</p> <p></p> <p>\u7531\u4e8e\u4e4b\u524d\u8fd0\u884c\u7684\u7a0b\u5e8f\u548c\u65b0\u7684terminal\u4e0d\u5728\u4e00\u4e2a\u4f1a\u8bdd\u7ec4\uff0c\u56e0\u6b64\u4e0a\u56fe\u4e2d\u6ca1\u6709\u663e\u793a\uff0c\u53ef\u4ee5\u901a\u8fc7\"ps -a\"\u6307\u4ee4\u67e5\u770b</p> <p></p> <p>\u8be5\u5217\u8868\u4e2dPID\u4e3aProcess ID\u5373\u8fdb\u7a0b\u53f7\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u62e5\u6709\u4e0d\u540c\u7684\u8fdb\u7a0b\u53f7\uff0c\u4e00\u822c\u4e3a\u589e\u5e8f\u987a\u5e8f\u5206\u914d\u3002\u4f46\u8fdb\u7a0b\u53f7\u7684\u6570\u91cf\u662f\u6709\u9650\u7684\uff0c\u5e76\u4e14\u4f1a\u56de\u6536\u518d\u5229\u7528\u3002</p>"},{"location":"lab/lab1/#pstree","title":"pstree\u547d\u4ee4","text":"<p>\u53ef\u4ee5\u67e5\u770b\u8fdb\u7a0b\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\"pstree -p\"\u53ef\u4ee5\u663e\u793a\u5e26\u8fdb\u7a0b\u53f7\u7684\u8fdb\u7a0b\u6811</p> <p></p>"},{"location":"lab/lab1/#kill","title":"kill\u547d\u4ee4","text":"<p>\u53ef\u4ee5\u5411\u8fdb\u7a0b\u53d1\u9001\u4e2d\u65ad\uff0c\u5176\u4e2d\u201ckill -9 \u8fdb\u7a0b\u53f7\u201d\u53d1\u9001\u7684\u662f\u5f3a\u5236\u7ec8\u6b62\u7684\u4fe1\u53f7\uff08SIGKILL\uff09\u53ef\u4ee5\u7528\u6765\u6740\u6b7b\u8be5\u8fdb\u7a0b\u53f7\u4ee3\u8868\u7684\u8fdb\u7a0b\uff08\u5f3a\u5236\u7ed3\u675f\u8fdb\u7a0b\uff09</p> <p></p>"},{"location":"lab/lab1/#step-8-ctrlc-ctrlz-fg","title":"Step 8. \u5e38\u7528\u6307\u4ee4: ctrl+c, ctrl+z, fg","text":"<p>\u5f53\u6211\u4eec\u8fd0\u884c\u4e86\u4e00\u4e2a\u7a0b\u5e8f\u65e0\u6cd5\u9000\u51fa\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u901a\u8fc7\u5176\u4ed6terminal\u53d1\u9001\u4fe1\u53f7\u6765\u505c\u6b62\u8be5\u8fdb\u7a0b\u3002</p>"},{"location":"lab/lab1/#ctrlc","title":"ctrl+c","text":"<p>\u7ec8\u6b62\u524d\u53f0\u8fdb\u7a0b</p> <p></p>"},{"location":"lab/lab1/#ctrlz","title":"ctrl+z","text":"<p>\u6682\u505c\u524d\u53f0\u8fdb\u7a0b</p> <p></p> <p></p> <p>\u6682\u505c\u7684\u524d\u53f0\u8fdb\u7a0b\u5e76\u6ca1\u6709\u88ab\u6740\u6b7b\uff0c\u53ea\u662f\u8fdb\u5165\u4e86T\u6682\u505c\u72b6\u6001\u3002\u540e\u9762\u7684\u8bfe\u7a0b\u4e2d\u6211\u4eec\u4f1a\u4e86\u89e3\u5230\u66f4\u591a\u8fdb\u7a0b\u7684\u72b6\u6001\u3002</p> <p></p> <p>\u8fdb\u7a0b\u6682\u505c\u65f6\u663e\u793a\u7684\u53f7\u7801\u4e3a\u8be5\u8fdb\u7a0b\u7684job\u53f7</p>"},{"location":"lab/lab1/#fg","title":"fg\u547d\u4ee4","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u201cfg job\u53f7\u201d\u547d\u4ee4\u5c06\u6682\u505c\u7684\u8fdb\u7a0b\u6062\u590d\u5230\u524d\u53f0\u8fd0\u884c\u3002</p> <p></p> <p>Note</p> <p>\u5728\u4e0b\u4e00\u6b21\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u5bf9c\u8bed\u8a00\u7f16\u7a0b\uff0c\u5d4c\u5165\u5f0f\u6c47\u7f16\u53camakefile\u8fdb\u884c\u4ecb\u7ecd\u3002\u4e0b\u5468\u9700\u8981\u63d0\u4ea4\u5b9e\u9a8c\u62a5\u544a\uff0c\u56e0\u6b64\u8bf7\u5927\u5bb6\u5e26\u6839\u7b14\u3002</p>"},{"location":"lab/lab2/","title":"C \u8bed\u8a00\u57fa\u7840\u53caMakefile","text":"<p>C \u8bed\u8a00\u57fa\u7840</p> <p>\u5982\u679c\u4f60\u6ca1\u6709\u5b66\u4e60\u8fc7 C \u8bed\u8a00\uff0c\u6211\u4eec \u975e\u5e38\u5efa\u8bae \u4f60\u63d0\u524d\u89c2\u770b\u4e8e\u8001\u5e08\u7684 C/C++ \u8bfe\u7a0b https://www.bilibili.com/video/BV1Vf4y1P7pq \uff0c\u89c2\u770b\u5230\u7b2c 6.5 \u7ae0\u8282\u6709\u52a9\u4e8e\u4f60\u4e86\u89e3\u57fa\u672c\u7684 C \u8bed\u8a00\u8bed\u6cd5\u3002</p> <p>RISC-V \u6c47\u7f16</p> <p>\u6211\u4eec\u671f\u671b\u4f60\u5df2\u7ecf\u5b8c\u6210\u4e86\u300a\u8ba1\u7b97\u673a\u7ec4\u6210\u539f\u7406\u300b\u8bfe\u7a0b\uff0c\u5e76\u4e86\u89e3 RISC-V \u6c47\u7f16\u7684\u57fa\u7840\u77e5\u8bc6\u3002</p> <p>\u6b64\u5916\uff0c\u8bf7\u5e38\u5907 \u300aThe RISC-V Instruction Set Manual, Volume I: User-Level ISA, Version 2.1\u300b(riscv-spec-v2.1.pdf) \u4e0e \u300aThe RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document Version 20211203\u300b(riscv-privileged-20211203.pdf) \u4f5c\u4e3a\u53c2\u8003 RISC-V \u6c47\u7f16\u7684\u53c2\u8003\u624b\u518c\u3002</p>"},{"location":"lab/lab2/#_1","title":"\u7c7b\u578b","text":"<p>\u5728 C \u8bed\u8a00\u4e2d\uff0c\u6574\u6570\u7c7b\u578b\u6709 long, int, short, char \u7b49\u3002 \u5728\u7edd\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0cint \u7c7b\u578b\u4e3a 32 \u4f4d\u957f\uff0c\u800c long \u7c7b\u578b\u7684\u957f\u5ea6\u53d6\u51b3\u4e8e ABI\uff08Application Binary Interface\uff0c\u5728\u7f16\u8bd1\u65f6\u7531\u7528\u6237\u6307\u5b9a\uff09\u3002 \u4e3a\u4e86\u907f\u514d\u7f16\u8bd1\u76ee\u6807\u67b6\u6784\u7684\u4e0d\u540c\u800c\u5bfc\u81f4 long\u3001int \u7b49\u7c7b\u578b\u5b9e\u9645\u957f\u5ea6\u4e0e\u6211\u4eec\u9884\u60f3\u7684\u4e0d\u4e00\u81f4\uff0c\u5728\u7cfb\u7edf\u7f16\u7a0b\u4e2d\uff0c\u6211\u4eec\u4f1a\u4f7f\u7528\u5b9a\u957f\u7684\u6574\u5f62\uff0c\u5982 uint64_t, int32_t \u7b49\u3002 \u5728\u4e0d\u540c\u7684ABI/\u7f16\u8bd1\u5668\u73af\u5883\u4e0b\uff0c\u4f7f\u7528\u8fd9\u4e00\u4e9b\u7c7b\u578b\u4fdd\u8bc1\u4e86\u5b83\u4eec\u7edd\u5bf9\u662f\u6307\u5b9a\u957f\u5ea6\u7684\u3002</p> <p>\u4f8b\u5982\uff0c\u5728 <code>os/types.h</code> \u4e2d\uff1a</p> os/types.h<pre><code>typedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef unsigned char uchar;\ntypedef unsigned char uint8;\ntypedef unsigned short uint16;\ntypedef unsigned int uint32;\ntypedef unsigned long uint64;\n</code></pre> <p>\u6211\u4eec\u5b9a\u4e49\u4e86 <code>uint64</code>, <code>uint32</code> \u7b49\u7c7b\u578b\u5206\u522b\u4e3a <code>unsigned long</code> \u548c <code>unsigned int</code>\u3002 \u7531\u4e8e\u6211\u4eec\u9762\u5411 riscv64 \u67b6\u6784\u8fdb\u884c\u7f16\u7a0b\uff0c\u6211\u4eec\u53ef\u4ee5\u786e\u4fdd\u5728\u6211\u4eec\u7684 XV6 \u4e2d\uff0c\u5b83\u4eec\u662f 64 / 32 \u4f4d\u7684\u3002</p> <p>unsigned</p> <p>\u6ce8\u610f\u5728C\u8bed\u8a00\u4e2d\u503c\u5728int\u7c7b\u578b\u53d6\u503c\u8303\u56f4\u5185\u7684\u6574\u6570\u5b57\u9762\u91cf\u7684\u9ed8\u8ba4\u7c7b\u578b\u662fint\u3002</p> <p>\u5f53unsigned int\u4e0e\u6709\u7b26\u53f7\u6574\u6570\uff08\u5982int\uff09\u6bd4\u8f83\u65f6\uff0c\u6709\u7b26\u53f7\u6574\u6570\u4f1a\u88ab\u63d0\u5347\u4e3aunsigned int\u3002\u5982\u679c\u5e38\u6570\u4e3a\u8d1f\u6570\uff0c\u63d0\u5347\u540e\u53ef\u80fd\u53d8\u6210\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u65e0\u7b26\u53f7\u503c\uff0c\u5bfc\u81f4\u6bd4\u8f83\u7ed3\u679c\u4e0e\u9884\u671f\u4e0d\u7b26\u3002</p> <p>\u53ef\u4ee5\u5c1d\u8bd5\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\uff0c\u89c2\u5bdf\u7ed3\u679c\uff1a</p> <p></p>"},{"location":"lab/lab2/#_2","title":"\u6307\u9488","text":"<p>\u6307\u9488\u662f\u7f16\u7a0b\u8bed\u8a00\u4e2d\u4e00\u79cd\u53d8\u91cf\u7c7b\u578b\uff0c\u5b83\u5b58\u50a8\u4e86\u53e6\u4e00\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5730\u5740\u3002\u901a\u8fc7\u6307\u9488\uff0c\u53ef\u4ee5\u95f4\u63a5\u8bbf\u95ee\u548c\u64cd\u4f5c\u5176\u4ed6\u53d8\u91cf\u7684\u503c\u3002\u6307\u9488\u901a\u5e38\u7528\u4e8e\u52a8\u6001\u5185\u5b58\u5206\u914d\u3001\u51fd\u6570\u53c2\u6570\u4f20\u9012\u3001\u6570\u636e\u7ed3\u6784\uff08\u5982\u94fe\u8868\u3001\u6811\u7b49\uff09\u7684\u5b9e\u73b0\u7b49\u573a\u666f\u3002</p> <ol> <li> <p>\u6307\u9488\u7684\"\u5185\u5bb9\"\uff1a\u5b83\u5b58\u50a8\u7684\u662f\u5185\u5b58\u5730\u5740\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u5b58\u50a8\u6570\u636e\u503c\u3002\u4f8b\u5982\uff0c\u6307\u9488 p \u53ef\u4ee5\u5b58\u50a8\u4e00\u4e2a\u53d8\u91cf x \u7684\u5185\u5b58\u5730\u5740\uff0c\u800c\u4e0d\u662f x \u7684\u503c\u3002</p> </li> <li> <p>\u6307\u9488\u7684\u7c7b\u578b\uff1a\u6307\u9488\u6709\u4e00\u4e2a\u7c7b\u578b\uff0c\u8868\u793a\u5b83\u6307\u5411\u7684\u662f\u54ea\u79cd\u7c7b\u578b\u7684\u53d8\u91cf\u3002\u4f8b\u5982\uff0c<code>int* p</code> \u8868\u793a p \u662f\u4e00\u4e2a\u6307\u5411 int \u7c7b\u578b\u7684\u6307\u9488\u3002</p> </li> <li> <p>\u89e3\u5f15\u7528\uff1a\u901a\u8fc7\u6307\u9488\u8bbf\u95ee\u5176\u6307\u5411\u7684\u53d8\u91cf\u7684\u8fc7\u7a0b\u53eb\u505a\u89e3\u5f15\u7528\uff0c\u5728 C \u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7 * \u64cd\u4f5c\u7b26\u6765\u89e3\u5f15\u7528\u4e00\u4e2a\u6307\u9488\uff0c\u83b7\u53d6\u6307\u9488\u6240\u6307\u5411\u7684\u503c\u3002</p> </li> <li> <p>\u53d6\u5730\u5740\uff1a\u6240\u6709\u4fdd\u5b58\u5728\u5185\u5b58\u4e0a\u7684\u53d8\u91cf\u53ef\u4ee5\u88ab\u53d6\u5730\u5740\uff0c\u6211\u4eec\u4f7f\u7528 <code>&amp;</code> \u6765\u8868\u793a\u53d6\u4e00\u4e2a\u53d8\u91cf\u7684\u5730\u5740\u3002</p> </li> </ol> <p>\u4f8b\u5982\uff1a</p> <pre><code>int a = 10;     // \u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf a\uff0c\u521d\u59cb\u5316\u4e3a 10\u3002\nint *p = &amp;a;    // \u53d6\u53d8\u91cf a \u7684\u5185\u5b58\u5730\u5740\uff0c\u653e\u5165\u6307\u9488 p \u4e2d\n*p = 20;        // \u5c06 p \u6307\u5411\u7684\u5185\u5b58\u5730\u5740\u4fee\u6539\u4e3a 20\n\nint b = 30;\nint **pp = &amp;p;  // \u53d6\u53d8\u91cf p \u7684\u5730\u5740\uff0c\u653e\u5165\u6307\u9488 pp \u4e2d\n*pp = &amp;b;       // \u5c06\u6307\u9488 p \u7684\u5185\u5bb9(\u5176\u6307\u5411\u7684\u5730\u5740)\uff0c\u6539\u4e3a\u53d8\u91cf b \u7684\u5730\u5740\u3002\n**pp = 50;      // \u4e24\u6b21\u89e3\u5f15\u7528\u3002\n\nprintf(\"a: %d, b:%d\\n\", a, b);  // \u8f93\u51fa: a:20, b:50.\n</code></pre> <p>\u4e00\u5f20\u56fe\u7406\u89e3\u6307\u9488\uff1a</p> <p></p>"},{"location":"lab/lab2/#_3","title":"\u7ed3\u6784\u4f53","text":"<p>\u6211\u4eec\u4f7f\u7528 <code>struct</code> \u5173\u952e\u5b57\u8868\u660e\u8be5\u7c7b\u578b\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53\u3002 \u7ed3\u6784\u4f53\u662f\u4e00\u5806\u6253\u5305\u5728\u4e00\u8d77\u7684\u6570\u636e\u3002</p> <p>\u4f8b\u5982\uff0c\u6211\u4eec\u58f0\u660e\u7ed3\u6784\u4f53 <code>struct proc</code>\uff0c\u5b83\u7684\u5b57\u6bb5\u5982\u4e0b\uff1a</p> <pre><code>struct proc {\n    int pid;\n    char* name;\n    void* chan;\n    uint64 krkr;\n    uint8 dkdk;\n};\n</code></pre> <p>\u6211\u4eec\u4f7f\u7528 <code>.</code> \u64cd\u4f5c\u7b26\u8bbf\u95ee\u4e00\u4e2a\u7ed3\u6784\u4f53\u53d8\u91cf\u7684\u5b57\u6bb5\uff0c\u4f7f\u7528 <code>-&gt;</code> \u64cd\u4f5c\u7b26\u89e3\u5f15\u7528\u4e00\u4e2a\u7ed3\u6784\u4f53\u6307\u9488\u7684\u5b57\u6bb5\u3002</p> <pre><code>struct proc p1;\np1.pid = 1234;\n\nstruct proc *pProc = &amp;p1;\npProc-&gt;name = \"proc 1234\";\n</code></pre>"},{"location":"lab/lab2/#_4","title":"\u7f16\u8bd1\u7cfb\u7edf","text":"<p>\u5728\u8ba1\u7b97\u673a\u7ec4\u6210\u539f\u7406\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u7b80\u8981\u7684\u4ecb\u7ecd\u4e86 C \u8bed\u8a00\u7684\u7f16\u8bd1\u7cfb\u7edf\u3002\u901a\u5e38\u6765\u8bf4\uff0c\u7f16\u8bd1\u4e00\u4e2a\u7a0b\u5e8f\u5206\u4e3a\u4ee5\u4e0b\u51e0\u6b65\uff1a</p> <p></p> <ol> <li>\u6e90\u4ee3\u7801 .c \u6587\u4ef6\u7ecf\u8fc7 Pre-processor \u9884\u5904\u7406 cpp \u5f97\u5230 .i \u6587\u4ef6</li> </ol> <p>.i \u6587\u4ef6\u662f GCC \u9884\u5904\u7406\u9636\u6bb5\u751f\u6210\u7684\u4e2d\u95f4\u6587\u4ef6\uff0c\u5305\u542b\u4e86\u5c55\u5f00\u7684\u5934\u6587\u4ef6\u3001\u5b8f\u5b9a\u4e49\u548c\u6761\u4ef6\u7f16\u8bd1\u540e\u7684\u4ee3\u7801\u3002\u4f7f\u7528 gcc -E \u53ef\u4ee5\u751f\u6210 .i \u6587\u4ef6\u3002</p> <ol> <li>.i \u6587\u4ef6\u901a\u8fc7\u7f16\u8bd1\u5668 cc1 \u7f16\u8bd1\u5668\u5f97\u5230\u6c47\u7f16\u6587\u4ef6 .s</li> </ol> <p>\u7f16\u8bd1\u5668\u5bf9.i\u6587\u4ef6\u8fdb\u884c\u8bed\u6cd5\u68c0\u67e5\uff0c\u68c0\u67e5\u65e0\u8bef\u540e\u5c06.i\u6587\u4ef6\u8f6c\u6362\u6210\u673a\u5668\u53ef\u4ee5\u7406\u89e3\u7684\u6c47\u7f16\u4ee3\u7801\uff08\u4eba\u7c7b\u53ef\u9605\u8bfb\u5f62\u5f0f\u7684\u673a\u5668\u4ee3\u7801\uff09\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u4f18\u5316\u5668\u53ef\u4ee5\u5bf9\u4ee3\u7801\u8fdb\u884c\u4f18\u5316\u3002</p> <ol> <li>.s \u6587\u4ef6\u901a\u8fc7\u6c47\u7f16\u5668 as \u5f97\u5230 Relocatable objects (\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6) .o</li> </ol> <p>\u5728\u6b64\u8fc7\u7a0b\u4e2d\uff0c\u6c47\u7f16\u5668\u5c06\u6c47\u7f16\u4ee3\u7801\u8f6c\u6362\u4e3a\u76ee\u6807\u4ee3\u7801\uff08\u673a\u5668\u4ee3\u7801-\u76f4\u63a5\u5728\u673a\u5668\u4e0a\u6267\u884c\u7684\u4ee3\u7801\uff0c\u4eba\u7c7b\u4e0d\u53ef\u8bfb\uff09\u3002</p> <ol> <li>\u94fe\u63a5\u5668 ld \u94fe\u63a5\u6240\u6709 .o \u6587\u4ef6\u5f97\u5230\u6700\u7ec8\u7684\u53ef\u6267\u884c\u6587\u4ef6</li> </ol> <p>\u5728 Linux \u7cfb\u7edf\u4e0a\uff0c\u76ee\u6807\u6587\u4ef6\u53ca\u53ef\u6267\u884c\u6587\u4ef6\u901a\u5e38\u4ee5 ELF (Executable and Linkable Format) \u6587\u4ef6\u683c\u5f0f\u5b58\u50a8\u3002    ELF \u6587\u4ef6\u5206\u4e3a\u4e0d\u540c\u7684\u6bb5 Section\uff0c\u7528\u4e8e\u5b58\u50a8\u7279\u5b9a\u7c7b\u578b\u7684\u6570\u636e\uff0c\u5982\u4ee3\u7801\uff08.text\uff09\u3001\u6570\u636e\uff08.data\uff09\u548c\u7b26\u53f7\u8868\uff08.symtab\uff09\uff0c\u6bcf\u4e2a\u6bb5\u90fd\u6709\u5176\u4e13\u95e8\u7684\u7528\u9014\u548c\u5c5e\u6027\u3002</p> <p>\u901a\u5e38\u6765\u8bf4\uff0c\u6211\u4eec\u4f1a\u7528\"\u7f16\u8bd1\u5668\"\u6765\u6307\u4ee3\u6574\u4e2a\u7f16\u8bd1\u4e0e\u94fe\u63a5\u8fc7\u7a0b\u4e2d\u7528\u5230\u7684\u6240\u6709\u5de5\u5177\uff0c\u5c3d\u7ba1\u7f16\u8bd1\u5668\u548c\u94fe\u63a5\u5668\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u7a0b\u5e8f\u3002\u7279\u522b\u7684\uff0c\u5f53\u6211\u4eec\u8ba8\u8bba\u7f16\u8bd1\u5668\u548c\u94fe\u63a5\u5668\u65f6\uff0c\u6211\u4eec\u4f1a\u5c06\u8fdb\u884c \u9884\u5904\u7406\u3001\u6c47\u7f16\u3001\u7f16\u8bd1 \u7b49\u6b65\u9aa4\u7684\u5de5\u5177\u96c6\u5408\u7edf\u79f0\u4e3a\u7f16\u8bd1\u5668\uff1b\u5c06\u6700\u540e\u7684\u94fe\u63a5\u6b65\u9aa4\u6240\u7528\u7684\u5de5\u5177\u79f0\u4e3a\u94fe\u63a5\u5668\u3002</p> \u5b9e\u9a8c\u6b65\u9aa41\uff1a\u89c2\u5bdfC\u8bed\u8a00\u7f16\u8bd1\u8fc7\u7a0b <p>\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u7684C\u8bed\u8a00\u4ee3\u7801\u793a\u4f8b\uff0c\u9002\u5408\u7528\u4e8e\u89c2\u5bdfGCC\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u7684 <code>.i</code>\u3001<code>.s</code>\u3001<code>.o</code> \u6587\u4ef6\uff1a</p> <pre><code>// main.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n    printf(\"Sum: %d\\n\", sum);\n    return 0;\n}\n</code></pre>"},{"location":"lab/lab2/#_5","title":"\u89c2\u5bdf\u7f16\u8bd1\u8fc7\u7a0b","text":"<ol> <li> <p>\u9884\u5904\u7406\uff08Preprocessing\uff09\uff1a\u751f\u6210 <code>.i</code> \u6587\u4ef6    <pre><code>gcc -E main.c -o main.i\n</code></pre>    \u8fd9\u4f1a\u751f\u6210 <code>main.i</code> \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e86\u9884\u5904\u7406\u540e\u7684\u4ee3\u7801\uff08\u5b8f\u5c55\u5f00\u3001\u5934\u6587\u4ef6\u5305\u542b\u7b49\uff09\uff0c\u53ef\u4ee5\u901a\u8fc7 <code>cat main.i</code> \u67e5\u770b\u5176\u5185\u5bb9\u3002</p> </li> <li> <p>\u7f16\u8bd1\uff08Compilation\uff09\uff1a\u751f\u6210 <code>.s</code> \u6587\u4ef6    <pre><code>gcc -S main.i -o main.s\n</code></pre>    \u8fd9\u4f1a\u751f\u6210 <code>main.s</code> \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e86\u6c47\u7f16\u4ee3\u7801\uff0c\u53ef\u4ee5\u901a\u8fc7 <code>cat main.s</code> \u67e5\u770b\u5176\u5185\u5bb9</p> </li> <li> <p>\u6c47\u7f16\uff08Assembly\uff09\uff1a\u751f\u6210 <code>.o</code> \u6587\u4ef6    <pre><code>gcc -c main.s -o main.o\n</code></pre>    \u8fd9\u4f1a\u751f\u6210 <code>main.o</code> \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e86\u76ee\u6807\u4ee3\u7801\uff08\u673a\u5668\u4ee3\u7801\uff09\uff0c\u53ef\u4ee5\u901a\u8fc7 <code>objdump</code> \u5de5\u5177\u6765\u5206\u6790 <code>main.o</code> \u7684\u5185\u5bb9\u3002\u4f8b\u5982\u4f7f\u7528 <code>objdump -d hello.o</code> \u53ef\u4ee5\u67e5\u770b\u673a\u5668\u7801\u53ca\u5176\u5bf9\u5e94\u7684\u6c47\u7f16\u6307\u4ee4\u3002 </p> </li> <li> <p>\u94fe\u63a5\uff08Linking\uff09\uff1a\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6    <pre><code>gcc main.o -o main\n</code></pre>    \u8fd9\u4f1a\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6 <code>main</code>\uff0c\u53ef\u4ee5\u901a\u8fc7 <code>file main</code> \u6765\u67e5\u770b <code>main</code> \u7684\u6587\u4ef6\u7c7b\u578b\u4e3aELF\u3002\u53ef\u4ee5\u901a\u8fc7GNU Binutils\u5de5\u5177\u96c6\u4e2d\u7684 <code>readelf</code> \u5de5\u5177\uff0c\u4f60\u53ef\u4ee5\u67e5\u770b ELF \u6587\u4ef6\u7684\u6587\u4ef6\u5934\u3001\u6bb5\u4fe1\u606f\u3001\u7b26\u53f7\u8868\u3001\u52a8\u6001\u6bb5\u4fe1\u606f\u7b49\u3002\u4f8b\u5982\u4f7f\u7528 <code>readelf -h main</code> \u53ef\u4ee5\u67e5\u770b <code>main</code> \u7684\u6587\u4ef6\u5934\u3002</p> </li> </ol>"},{"location":"lab/lab2/#definition-declaration","title":"Definition \u548c Declaration","text":"<p>Definition \uff08\u5b9a\u4e49\uff09 \u548c Declaration \uff08\u58f0\u660e\uff09 \u662f C \u8bed\u8a00\u4e2d\u975e\u5e38\u5bb9\u6613\u6df7\u6dc6\u7684\u4e24\u4e2a\u6982\u5ff5\u3002</p> <p>Declaration \u58f0\u660e\u4e86\u4e00\u4e2a\u7b26\u53f7\uff08\u53d8\u91cf\u3001\u51fd\u6570\u7b49\uff09\uff0c\u548c\u5b83\u7684\u7684\u4e00\u4e9b\u57fa\u7840\u4fe1\u606f\uff08\u5982\u53d8\u91cf\u7c7b\u578b\u3001\u51fd\u6570\u53c2\u6570\u7c7b\u578b\u3001\u51fd\u6570\u8fd4\u56de\u7c7b\u578b\u7b49\uff09\u3002\u8fd9\u4f7f\u5f97\u7f16\u8bd1\u5668 \u5728\u7f16\u8bd1\u9636\u6bb5 \u80fd\u4f7f\u7528\u8fd9\u4e9b\u7c7b\u578b\u4fe1\u606f\u8fdb\u884c\u4ee3\u7801\u751f\u6210 (Code Generation)\u3002</p> <p>\u800c Definition \u5b9e\u9645\u4e0a\u4f1a\u4e3a\u8be5\u7b26\u53f7\u5206\u914d\u5185\u5b58\u5730\u5740\u3002\u94fe\u63a5\u5668\u4f1a \u5728\u94fe\u63a5\u9636\u6bb5 \u4e3a\u8fd9\u4e9b\u7b26\u53f7 \u5206\u914d\u5730\u5740\uff08\u5982\u51fd\u6570\u5730\u5740\u3001\u5168\u5c40\u53d8\u91cf\u5730\u5740\uff09\u3002</p> <p>Symbol \uff08\u7b26\u53f7\uff09</p> <p>\u5728 C \u8bed\u8a00\u4e2d\uff0c\u7b26\u53f7\uff08Symbol\uff09\u662f\u7f16\u8bd1\u5668\u7528\u6765\u8868\u793a\u7a0b\u5e8f\u4e2d\u5404\u79cd\u5b9e\u4f53\uff08\u5982\u53d8\u91cf\u3001\u51fd\u6570\u3001\u5b8f\u3001\u7c7b\u578b\u540d\u7b49\uff09\u7684\u540d\u79f0\u3002\u6bcf\u4e2a\u7b26\u53f7\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u88ab\u5173\u8054\u5230\u7279\u5b9a\u7684\u5185\u5b58\u5730\u5740\u6216\u5176\u4ed6\u8d44\u6e90\u3002\u5f53\u7a0b\u5e8f\u88ab\u7f16\u8bd1\u65f6\uff0c\u7f16\u8bd1\u5668\u4f1a\u4e3a\u8fd9\u4e9b\u7b26\u53f7\u521b\u5efa\u7b26\u53f7\u8868 (Symbol Table)\uff0c\u8bb0\u5f55\u5b83\u4eec\u7684\u540d\u79f0\u3001\u7c7b\u578b\u3001\u4f5c\u7528\u57df\u4ee5\u53ca\u5bf9\u5e94\u7684\u5185\u5b58\u5730\u5740\u6216\u503c\u3002</p> <p>\u7b80\u800c\u8a00\u4e4b\uff0c\u7b26\u53f7\u662f\u7a0b\u5e8f\u4e2d\u4ee3\u8868\u5b9e\u4f53\u7684\u540d\u5b57\uff0c\u7f16\u8bd1\u5668\u901a\u8fc7\u7b26\u53f7\u8868\u6765\u7ba1\u7406\u548c\u89e3\u6790\u8fd9\u4e9b\u540d\u5b57\u3002</p> <p>\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1\u67d0\u4e2a <code>.c</code> \u6587\u4ef6\u65f6\uff0c\u5b83\u4f1a\u4e00\u884c\u4e00\u884c\u7684\u5904\u7406\u6e90\u4ee3\u7801\uff0c\u5e76\u7ef4\u62a4\u4e00\u4e2a\u7b26\u53f7\u8868\uff0c\u8868\u793a\u5f53\u524d\u6587\u4ef6\u4e2d\uff0c\u5230 \u76ee\u524d\u4e3a\u6b62 \u6240\u6709\u89c1\u8fc7\u7684\u7b26\u53f7\u3002\u5f53\u7f16\u8bd1\u5668\u9047\u5230\u5bf9\u4e00\u4e2a\u7b26\u53f7\u7684\u5f15\u7528\uff08\u53d8\u91cf\u5f15\u7528\u3001\u51fd\u6570\u8c03\u7528\uff09\u65f6\uff0c\u5b83\u4f1a\u67e5\u627e\u8fd9\u4e2a\u7b26\u53f7\u8868\uff1b\u5f53\u7f16\u8bd1\u5668\u9047\u5230\u4e00\u4e2a\u7b26\u53f7\u7684\u58f0\u660e\u6216\u5b9a\u4e49\u65f6\uff0c\u5b83\u4f1a\u5411\u7b26\u53f7\u8868\u4e2d\u4fdd\u5b58\u8fd9\u4e2a\u7b26\u53f7\u7684\u4fe1\u606f\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u8981\u4fdd\u8bc1\uff0c\u5728\u5f15\u7528\u4e00\u4e2a\u7b26\u53f7\u65f6\uff0c\u5b83\u8d77\u7801\u88ab\u58f0\u660e\u8fc7\uff0c\u5373\u88ab\u7f16\u8bd1\u5668\u770b\u5230\u8fc7\u3002\u540c\u65f6\uff0c\u5728\u540c\u4e00\u4e2a\u6587\u4ef6\u4e2d\uff0c\u5b9a\u4e49\u4e5f\u662f\u4e00\u79cd\u58f0\u660e\u3002</p> <p>\u5bf9\u4e8e\u7f16\u8bd1\u5668\u800c\u8a00\uff0c\u5982\u679c\u8be5 <code>.c</code> \u6587\u4ef6\u9700\u8981\u5f15\u7528\u5176\u5b83 <code>.c</code> \u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u6216\u8005\u53d8\u91cf\uff0c\u5219\u9700\u8981\u63d0\u524d \u58f0\u660e \u5b83\u3002\u5f53\u7f16\u8bd1\u5668\u9047\u5230\u4e86\u58f0\u660e (Declaration) \u8fc7\u4f46\u662f\u6ca1\u6709\u5728\u5f53\u524d\u6587\u4ef6\u4e2d\u88ab\u5b9a\u4e49 (Definition) \u8fc7\u7684\u7b26\u53f7\u65f6 (\u5982 printf)\uff0c\u7f16\u8bd1\u5668\u4f1a\u5047\u5b9a\u8be5\u7b26\u53f7\u4f1a\u5728\u5176\u4ed6 object \u6587\u4ef6\u4e2d\u88ab\u5b9a\u4e49\uff0c\u7559\u4e0b\u4e00\u4e9b\u4fe1\u606f\u540e\u4ea4\u7ed9\u94fe\u63a5\u5668\u5728\u94fe\u63a5\u9636\u6bb5\u5bfb\u627e\u8fd9\u4e2a\u7b26\u53f7\u3002</p> <p>\u4f8b\u5982\uff0c<code>a.c</code> \u5b9a\u4e49 \u4e86\u53d8\u91cf <code>int a</code>\u3002\u5982\u679c <code>main.c</code> \u60f3\u8981\u5f15\u7528\u5b83\uff0c\u5219\u9700\u8981\u4f7f\u7528 <code>extern int a</code> \u6765 \u58f0\u660e \u5b83\u3002</p> <pre><code>// a.c\nint a;\n\n// main.c\nextern int a;\nint main() {\n    printf(\"%d\\n\", a);\n}\n</code></pre> <p>\u7f16\u8bd1\u65f6\uff0c\u6211\u4eec\u5148\u5206\u522b\u7f16\u8bd1 <code>a.c</code> \u548c <code>main.c</code> \u5230 <code>a.o</code> \u548c <code>main.o</code>\uff1a<code>gcc -c a.c -o a.o</code>\u3001<code>gcc -c main.c -o a.o</code>\uff0c\u7136\u540e\u94fe\u63a5\u4e24\u4e2a .o \u6587\u4ef6\uff1a<code>gcc main.o a.o</code> \u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6 a.out\u3002</p> <p>\u7f16\u8bd1 <code>a.c</code> \u65f6\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684 <code>a.o</code> \u4f1a\u8868\u793a\u5b83\u6709\u4e00\u4e2a\u5168\u5c40\u53ef\u89c1\u7684\u7b26\u53f7\uff0c\u53eb <code>a</code>\u3002 \u7f16\u8bd1 <code>main.c</code> \u65f6\uff0c\u7f16\u8bd1\u5668\u662f\u4e0d\u77e5\u9053\u4efb\u4f55\u5173\u4e8e\u5176\u4ed6 .c \u6587\u4ef6\u7684\u4fe1\u606f\u7684\u3002\u4f46\u662f\u6211\u4eec\u5728\u7b2c\u4e00\u884c\u58f0\u660e\u4e86\u53d8\u91cf <code>a</code>\uff0c\u6240\u4ee5\u5b83\u77e5\u9053\u6700\u7ec8\u94fe\u63a5\u7684\u65f6\u5019\u4f1a\u6709\u4e00\u4e2a\u7b26\u53f7\u53eb <code>a</code>\u3002\u7f16\u8bd1\u5668\u4ea7\u751f\u7684 <code>main.o</code> \u4e2d\u4f1a\u8868\u793a\u5b83\u9700\u8981\u4e00\u4e2a\u7b26\u53f7\uff0c\u53eb <code>a</code>\u3002</p> <p>\u94fe\u63a5\u5668\u4f1a\u67e5\u627e\u6240\u6709 <code>.o</code> \u6587\u4ef6\u7684\u7b26\u53f7\u8868\uff0c\u5e76\u6839\u636e\u540d\u5b57\u548c\u53ef\u89c1\u6027\u5339\u914d\u7b26\u53f7\u3002</p> <p>\u4e3a\u4e86\u7ec4\u7ec7\u5927\u578b\u9879\u76ee\uff0c\u6211\u4eec\u4e0d\u4f1a\u5728\u6bcf\u4e2a <code>.c</code> \u6587\u4ef6\u4e2d\u624b\u52a8\u5bfc\u5165\u5176\u5b83 <code>.c</code> \u6587\u4ef6\u4e2d\u7684\u7b26\u53f7\uff0c\u800c\u662f\u4f1a\u4f7f\u7528\u5934\u6587\u4ef6\u6765\u58f0\u660e\u8fd9\u4e9b\u4f1a\u5728 <code>.c</code> \u4e2d\u5171\u4eab\u7684\u7b26\u53f7\u3002</p>"},{"location":"lab/lab2/#_6","title":"\u5934\u6587\u4ef6","text":"<p>\u5934\u6587\u4ef6\uff08Header File\uff09\u7684\u4f5c\u7528\u662f\u58f0\u660e\u51fd\u6570\u3001\u53d8\u91cf\u3001\u5b8f\u5b9a\u4e49\u3001\u5e38\u91cf\u3001\u7c7b\u578b\u7b49\u4fe1\u606f\uff0c \u4ee5\u4fbf\u5728\u591a\u4e2a\u6e90\u6587\u4ef6\u4e2d\u5171\u4eab\u3002\u6211\u4eec\u4f1a\u5728 <code>.c</code> \u7684\u5f00\u5934\u4f7f\u7528 <code>#include</code> \u5b8f\u5bfc\u5165\u5934\u6587\u4ef6\uff0c\u5b83\u7684\u8bed\u4e49\u662f\u5c06\u6587\u4ef6\u5185\u5bb9\u76f4\u63a5\u590d\u5236\u5230\u5f53\u524d\u6587\u4ef6\u4e2d\uff0c\u8fd9\u4e00\u6b65\u662f\u7531 preprocessor \u5b8c\u6210\u7684\u3002</p> <p>\u5982\u679c\u67d0\u4e2a <code>.c</code> \u6587\u4ef6\u4e2d\u6709\u4e9b\u7c7b\u578b\u3001\u51fd\u6570\u3001\u53d8\u91cf\u9700\u8981\u88ab\u5176\u4ed6 <code>.c</code> \u6587\u4ef6\u5f15\u7528\uff0c\u6211\u4eec\u4f1a\u521b\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u5934\u6587\u4ef6\u3002\u5728\u7ed9\u5934\u6587\u4ef6\u53d6\u540d\u4e0a\uff0c\u6211\u4eec\u4e00\u822c\u4f7f\u7528\u540c\u6837\u7684\u6587\u4ef6\u540d\uff0c\u4f46\u662f\u4f7f\u7528 <code>.h</code> \u540e\u7f00\uff1b\u4f8b\u5982\uff0c\u5bf9\u4e8e <code>a.c</code> \u91cc\u9762\u9700\u8981\u5171\u4eab\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u4f1a\u521b\u5efa\u4e00\u4e2a\u5b83\u7684\u5934\u6587\u4ef6 <code>a.h</code>\u3002</p> <p>\u5bf9\u4e8e\u9700\u8981\u5171\u4eab\u7684\u51fd\u6570\u3001\u53d8\u91cf\uff0c\u6211\u4eec\u901a\u5e38\u4f1a\u5728 <code>a.h</code> \u4e2d \u58f0\u660e\uff0c\u5728 <code>a.c</code> \u4e2d \u5b9a\u4e49\uff1a</p> <pre><code>// a.h\nextern int a;\nint add(int x, int y);\n\n// a.c\nint a;\n// or int a = 10;\nint add (int x, int y) {\n    return x + y;\n}\n</code></pre> <p>\u5047\u5982 <code>main.c</code> \u9700\u8981\u5f15\u7528 <code>a.c</code> \u4e2d\u63d0\u4f9b\u7684 <code>a</code> \u53d8\u91cf\u6216\u8005 <code>add</code> \u51fd\u6570\uff0c\u5219\u53ef\u4ee5\u5728\u5176\u5f00\u5934\u5f15\u5165 <code>a.h</code> \u5934\u6587\u4ef6\uff1a</p> <pre><code>// main.c\n#include \"a.h\"\n\nint main() {\n    a = 666;\n    int b = 123;\n    int c = add(a, b);\n}\n</code></pre> <p>Note</p> <ul> <li> <p>\u5728\u4e00\u4e2a <code>.c</code> \u6587\u4ef6\u4e2d\u58f0\u660e\u4e14\u5b9a\u4e49\u7684\u5168\u5c40\u53d8\u91cf\u5176\u4ed6 <code>.c</code> \u6587\u4ef6\u662f\u65e0\u6cd5 \u76f4\u63a5 \u4f7f\u7528\u7684\u3002\u4f8b\u5982\u4f60\u5728\u4e00\u4e2a <code>.c</code> \u6587\u4ef6\u4e2d <code>int a;</code> \uff0c\u5219\u5728\u53e6\u4e00\u4e2a\u6587\u4ef6\u4e2d\u9700\u8981 <code>extern int a;</code> \uff0c\u90a3\u4e48\u4e24\u4e2a\u6587\u4ef6\u624d\u662f\u5171\u4eab\u540c\u4e00\u4e2a <code>a</code> \u3002</p> </li> <li> <p>\u5728\u591a\u4e2a <code>.c</code> \u6587\u4ef6\u4e2d\u5b9a\u4e49\u5168\u5c40\u53d8\u91cf\u65f6\uff0c\u6211\u4eec\u8981\u786e\u4fdd\u53d8\u91cf\u540d\u662f\u552f\u4e00\u7684\u3002\u5426\u5219\u4f1a\u5bfc\u81f4\u591a\u91cd\u5b9a\u4e49\u3002</p> </li> <li> <p>\u5982\u679c\u6211\u4eec\u5e0c\u671b\u5b9a\u4e49\u4e00\u4e9b\u4ec5\u5f53\u524d <code>.c</code> \u53ef\u89c1\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>static</code> \u5173\u952e\u5b57\u3002</p> </li> <li> <p><code>.h</code> \u6587\u4ef6\u4e2d\u4ec5\u80fd\u58f0\u660e\u53d8\u91cf\uff0c\u5982\u679c <code>.h</code> \u5b9a\u4e49\u4e86\u4e00\u4e2a\u53d8\u91cf\u5e76\u4e14\u5b58\u5728\u4e24\u4e2a\u4ee5\u4e0a\u7684 <code>.c</code> \u6587\u4ef6 <code>#include</code> \u4e86\u8fd9\u4e2a <code>.h</code> \u6587\u4ef6\uff0c\u5219\u4e5f\u4f1a\u51fa\u73b0\u591a\u91cd\u5b9a\u4e49\uff0c\u56e0\u4e3a\u9884\u5904\u7406\u5668\u4f1a\u5c06\u88ab include \u7684\u5185\u5bb9\u76f4\u63a5\u590d\u5236\u5230\u5f53\u524d\u6587\u4ef6\u4e2d\uff0c\u8fd9\u6700\u7ec8\u4f1a\u5bfc\u81f4\u4e24\u4e2a <code>.c</code> \u90fd\u4f1a\u5bf9\u8fd9\u4e2a\u53d8\u91cf\u8fdb\u884c\u5b9a\u4e49\u3002</p> </li> <li> <p>\u5982\u679c\u4f60\u5e0c\u671b\u4e00\u4e2a\u53d8\u91cf\u7531\u591a\u4e2a <code>.c</code> \u5171\u4eab\u4f7f\u7528\uff0c\u53ef\u4ee5\u5728 <code>.h</code> \u6587\u4ef6\u4e2d\u58f0\u660e\u8fd9\u4e2a\u53d8\u91cf\u5e76\u4e14\u4f7f\u7528 <code>extern</code> \u5173\u952e\u5b57\u8fdb\u884c\u4fee\u9970\uff0c\u5e76\u5728\u4efb\u4f55\u4e00\u4e2a <code>.c</code> \u4e2d\u5b9a\u4e49\u5b83\u3002</p> </li> </ul>"},{"location":"lab/lab2/#readelf-symbol-table","title":"readelf \u8bfb\u53d6 Symbol Table","text":"<p>\u6211\u4eec\u518d\u6b21\u89e3\u91ca\u4e00\u4e0b Declaration \u548c Definition \u7684\u533a\u522b\uff1a</p> <ul> <li> <p>Definition \u662f\u5411\u94fe\u63a5\u5668\u8868\u793a\uff0c\u8fd9\u4e2a .o \u6587\u4ef6\u91cc\u9762\u6709\u4e00\u4e2a\u7b26\u53f7\uff0c\u94fe\u63a5\u5668\u9700\u8981\u4e3a\u5b83\u5206\u914d\u5185\u5b58\u5730\u5740\u3002\u5982\u679c\u5176\u4ed6 .o \u9700\u8981\u5f15\u7528\u8fd9\u4e2a\u7b26\u53f7\uff0c\u5219\u8981\u5224\u65ad\u8fd9\u4e2a\u7b26\u53f7\u662f\u5426\u5141\u8bb8\u88ab\u5916\u90e8\u8bbf\u95ee\uff0c\u5373\u58f0\u660e\u65f6\u662f\u5426\u4f7f\u7528\u4e86 static\u3002</p> </li> <li> <p>Declaration \u662f\u5411\u7f16\u8bd1\u5668\u4fdd\u8bc1\uff0c\u8fd9\u4e2a\u7b26\u53f7\u4f1a\u5728\u94fe\u63a5\u65f6\u88ab\u627e\u5230\uff0c\u4e0d\u8bba\u662f\u5f53\u524d <code>.c</code> \u6216\u5176\u4ed6 <code>.c</code> \u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\u3002\u7f16\u8bd1\u5668\u53ea\u8981\u6839\u636e\u58f0\u660e\u7684\u53d8\u91cf\u7c7b\u578b\u6216\u51fd\u6570\u539f\u578b\u8fdb\u884c\u4ee3\u7801\u751f\u6210\uff08\u5982\u53d8\u91cf\u8bbf\u5b58\u65f6\u7684\u5bbd\u5ea6 (lb, lw, ld)\uff0c\u51fd\u6570\u7684\u53c2\u6570\u4e2a\u6570\uff09\uff0c\u94fe\u63a5\u5668\u4f1a\u8d1f\u8d23\u53bb\u627e\u5230\u8fd9\u4e9b\u7b26\u53f7\u3002</p> </li> </ul> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 <code>llvm-readelf-19 --symbol &lt;file&gt;</code> \u67e5\u770b\u4e00\u4e2a ELF \u6587\u4ef6\u7684\u7b26\u53f7\u8868\uff0c\u91cc\u9762\u5b57\u6bb5\u7684\u610f\u4e49\u53ef\u4ee5\u53c2\u7167 https://docs.oracle.com/cd/E19455-01/816-0559/chapter6-79797/index.html</p> <pre><code>$ llvm-readelf-19 --symbols build/os/proc.o | grep -E \"FUNC|OBJECT|GLOBAL\"\nSymbol table '.symtab' contains 1240 entries:\n   Num:    Value          Size Type    Bind   Vis       Ndx Name\n     5: 0000000000000000    72 FUNC    LOCAL  DEFAULT     1 curr_proc\n    23: 0000000000000048   304 FUNC    LOCAL  DEFAULT     1 freeproc\n    97: 0000000000000178    92 FUNC    LOCAL  DEFAULT     1 first_sched_ret\n   128: 0000000000000000     4 OBJECT  LOCAL  DEFAULT     6 proc_inited.1\n   237: 0000000000000000     4 OBJECT  LOCAL  DEFAULT     7 PID.0\n   663: 0000000000000000    32 OBJECT  LOCAL  DEFAULT     4 pid_lock\n   664: 0000000000000020    32 OBJECT  LOCAL  DEFAULT     4 wait_lock\n   665: 0000000000000040   104 OBJECT  LOCAL  DEFAULT     4 proc_allocator\n  1201: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND push_off\n  1202: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND mycpu\n  1203: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND pop_off\n  1210: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND usertrapret\n  1211: 00000000000001d4   544 FUNC    GLOBAL DEFAULT     1 proc_init\n  1212: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND spinlock_init\n  1213: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND allocator_init\n  1214: 00000000000000a8  4096 OBJECT  GLOBAL DEFAULT     4 pool\n  1215: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kernel_pagetable\n  1216: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kallocpage\n  1217: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kalloc\n  1218: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND memset\n  1219: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kvmmap\n</code></pre> <p>Type \u5217\u8868\u793a\u8be5\u7b26\u53f7\u662f\u51fd\u6570 (FUNC) \u8fd8\u662f\u53d8\u91cf (OBJECT), Bind \u8868\u793a\u8fd9\u4e2a\u7b26\u53f7\u662f\u5426\u5141\u8bb8\u5176\u4ed6 .o \u627e\u5230 (LOCAL/GLOBAL)\u3002Ndx \u8868\u793a\u8fd9\u4e2a\u7b26\u53f7\u662f\u5426\u5b9a\u4e49\u5728\u8fd9\u4e2a .o \u91cc\u9762\uff0c<code>UND</code> \u8868\u793a\u5b83\u662f\u5916\u90e8\u7684 <code>.o</code>\uff0c\u5373\u9700\u8981\u4ece\u5176\u4ed6 .o \u5bfc\u5165\u7684\u7b26\u53f7\uff0c\u6240\u4ee5\u5b83\u7684 Type \u548c Size \u90fd\u662f\u672a\u77e5\u7684\u3002</p> <p>\u73b0\u5728\uff0c\u4f60\u662f\u5426\u7406\u89e3\u4e86\u94fe\u63a5\u4e2d\u5e38\u51fa\u73b0\u7684\u4e24\u79cd\u9519\u8bef\uff1amultiple definition \u548c undefined reference \u7684\u539f\u56e0\uff1f</p> <ul> <li><code>riscv64-unknown-elf-ld: build/os/proc.o:os/proc.c:14: multiple definition of 'idle'; build/os/main.o:os/main.c:7: first defined here</code><ul> <li>\u5728\u4e0d\u540c\u7684 .c \u6587\u4ef6\u4e2d\u5b9a\u4e49\u4e86\u591a\u6b21 <code>idle</code> \u53d8\u91cf\u3002</li> </ul> </li> <li><code>riscv64-unknown-elf-ld: build/os/proc.o: in function 'proc_init': os/proc.c:38:(.text+0xd0): undefined reference to 'idle'</code><ul> <li>\u5728\u5934\u6587\u4ef6\u4e2d\u58f0\u660e\u4e86 <code>idle</code> \u53d8\u91cf\uff0c\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5b83\u3002</li> </ul> </li> </ul>"},{"location":"lab/lab2/#make-makefile","title":"Make \u548c Makefile\u4ecb\u7ecd","text":"<p>\u8003\u8651\u4e00\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u7684\u5de5\u7a0b\u7a0d\u5fae\u5927\u4e00\u70b9\uff08\u6bd4\u5982\u5305\u542b\u591a\u4e2aC\u8bed\u8a00\u6587\u4ef6\uff09\uff0c\u6bcf\u6b21\u8fd0\u884c\u4e00\u6b21\u6211\u4eec\u90fd\u8981\u6267\u884c\u5f88\u591a\u6b21gcc\u547d\u4ee4\uff0c\u662f\u5426\u6709\u4e00\u79cd\u7f16\u8bd1\u5de5\u5177\u53ef\u4ee5\u7b80\u5316\u8fd9\u4e2a\u8fc7\u7a0b\u5462\uff1f\u63a5\u4e0b\u6765\u6211\u4eec\u4ecb\u7ecd\u81ea\u52a8\u5316\u7f16\u8bd1\u5de5\u5177make\u3002</p> <p><code>Makefile</code> \u662f\u4e00\u4e2a\u7528\u4e8e\u81ea\u52a8\u5316\u6784\u5efa\uff08\u7f16\u8bd1\u3001\u94fe\u63a5\u7b49\uff09\u7a0b\u5e8f\u7684\u914d\u7f6e\u6587\u4ef6\uff0c\u901a\u5e38\u7528\u4e8e\u7ba1\u7406\u5305\u542b\u591a\u4e2a\u6e90\u6587\u4ef6\u7684\u9879\u76ee\u3002\u5b83\u5b9a\u4e49\u4e86\u5982\u4f55\u4ece\u6e90\u4ee3\u7801\u751f\u6210\u76ee\u6807\u6587\u4ef6\uff08\u5982\u53ef\u6267\u884c\u6587\u4ef6\u3001\u5e93\u6587\u4ef6\u7b49\uff09\uff0c\u5e76\u786e\u4fdd\u53ea\u91cd\u65b0\u7f16\u8bd1\u90a3\u4e9b\u9700\u8981\u66f4\u65b0\u7684\u90e8\u5206\uff0c\u4ece\u800c\u63d0\u9ad8\u6784\u5efa\u6548\u7387\u3002</p> <p><code>Makefile</code> \u662f <code>make</code> \u5de5\u5177\u7684\u8f93\u5165\u6587\u4ef6\uff0c<code>make</code> \u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u6784\u5efa\u5de5\u5177\uff0c\u5e7f\u6cdb\u7528\u4e8e Unix/Linux \u7cfb\u7edf\u3002</p> \u5b9e\u9a8c\u6b65\u9aa42\uff1a\u4f7f\u7528makefile\u8fdb\u884c\u81ea\u52a8\u5316\u6784\u5efa <p>\u9996\u5148\u6211\u4eec\u521b\u5efa\u4e09\u4e2a\u6587\u4ef6</p> <pre><code>//print.h \u5934\u6587\u4ef6\n#include &lt;stdio.h&gt;\nvoid print(void);\n\n//print.c\n#include \"print.h\"\nvoid print(){\n    printf(\"Hello, World!\\n\");\n}\n\n//main.c\n#include \"print.h\"\nint main(){\n    print();\n    return 0;\n}\n</code></pre> <p>\u56e0\u4e3a\u6587\u4ef6\u4e2d\u7684\u4f9d\u8d56\u5173\u7cfb\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u8fd0\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u6211\u4eec\u9700\u8981\u4e3a\u6bcf\u4e2a.c\u6587\u4ef6\u751f\u6210.o\u76ee\u6807\u6587\u4ef6\uff0c\u7136\u540e\u628a\u4e24\u4e2a.o\u6587\u4ef6\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\uff1a</p> <pre><code>gcc -c main.c\ngcc -c print.c\ngcc -o main main.o print.o\n\n./main\n</code></pre> <p></p> <p></p> <p>\u7531\u6b64\u53ef\u89c1\uff0c\u5982\u679c\u6211\u4eec\u7684\u6587\u4ef6\u6570\u91cf\u5f88\u591a\uff0c\u6bcf\u6b21\u8fd0\u884c\u5c31\u4f1a\u53d8\u5f97\u5341\u5206\u7684\u590d\u6742\u3002\u4e3a\u4e86\u4f7f\u6574\u4e2a\u7f16\u8bd1\u8fc7\u7a0b\u66f4\u52a0\u5bb9\u6613\uff0c\u53ef\u4ee5\u4f7f\u7528Makefile\u3002</p> <p>\u63a5\u7740\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u6587\u672c\u6587\u4ef6\u5e76\u547d\u540d\u4e3aMakefile\u3002</p> <p>Makefile\u6587\u4ef6\u5185\u5bb9\uff1a</p> <pre><code>main : main.o print.o\n    gcc -o main main.o print.o\nmain.o : main.c print.h\n    gcc -c main.c\nprint.o : print.c print.h\n    gcc -c print.c\nclean:\n    rm main main.o print.o\n</code></pre> <p>Warning</p> <p>Makefile\u4e2d\u7684\u7f29\u8fdb\u53ea\u80fd\u662ftab\uff0c\u4e0d\u80fd\u662f\u82e5\u5e72\u7a7a\u683c\uff0c\u5426\u5219\u65e0\u6cd5\u6267\u884c\u3002</p> <p>\u6700\u540e\uff0c\u6211\u4eec\u53ea\u9700\u8981\u6267\u884c\u4e00\u53e5make\u547d\u4ee4\uff0c\u5c31\u53ef\u4ee5\u5b8c\u6210\u6574\u4e2a\u7f16\u8bd1\u8fc7\u7a0b\uff1a</p> <p></p>"},{"location":"lab/lab2/#makefile","title":"Makefile\u7684\u57fa\u672c\u7ed3\u6784","text":"<pre><code>target: dependencies\n[tab] system command\n</code></pre>"},{"location":"lab/lab2/#makefile_1","title":"Makefile\u5de5\u4f5c\u539f\u7406","text":"<p>\u5728\u9ed8\u8ba4\u7684\u65b9\u5f0f\u4e0b\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u53ea\u8f93\u5165 <code>make</code> \u547d\u4ee4\u3002\u90a3\u4e48\uff0c</p> <ol> <li>make\u4f1a\u5728\u5f53\u524d\u76ee\u5f55\u4e0b\u627e\u540d\u5b57\u53eb\u201cMakefile\u201d\u6216\u201cmakefile\u201d\u7684\u6587\u4ef6\u3002</li> <li>\u5982\u679c\u627e\u5230\uff0c\u5b83\u4f1a\u627e\u6587\u4ef6\u4e2d\u7684\u7b2c\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\uff08target\uff09\uff0c\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u4ed6\u4f1a\u627e\u5230\u201cmain\u201d\u8fd9\u4e2a\u6587\u4ef6\uff0c\u5e76\u628a\u8fd9\u4e2a\u6587\u4ef6\u4f5c\u4e3a\u6700\u7ec8\u7684\u76ee\u6807\u6587\u4ef6\u3002</li> <li>\u5982\u679cmain\u6587\u4ef6\u4e0d\u5b58\u5728\uff0c\u6216\u662fmain\u6240\u4f9d\u8d56\u7684\u540e\u9762\u7684 <code>.o</code> \u6587\u4ef6\u7684\u6587\u4ef6\u4fee\u6539\u65f6\u95f4\u8981\u6bd4 <code>main</code> \u8fd9\u4e2a\u6587\u4ef6\u65b0\uff0c\u90a3\u4e48\uff0c\u4ed6\u5c31\u4f1a\u6267\u884c\u540e\u9762\u6240\u5b9a\u4e49\u7684\u547d\u4ee4\u6765\u751f\u6210 <code>main</code> \u8fd9\u4e2a\u6587\u4ef6\u3002</li> <li>\u5982\u679c <code>main</code> \u6240\u4f9d\u8d56\u7684 <code>.o</code> \u6587\u4ef6\u4e5f\u4e0d\u5b58\u5728\uff0c\u90a3\u4e48make\u4f1a\u5728\u5f53\u524d\u6587\u4ef6\u4e2d\u627e\u76ee\u6807\u4e3a <code>.o</code> \u6587\u4ef6\u7684\u4f9d\u8d56\u6027\uff0c\u5982\u679c\u627e\u5230\u5219\u518d\u6839\u636e\u90a3\u4e00\u4e2a\u89c4\u5219\u751f\u6210 <code>.o</code> \u6587\u4ef6\u3002\uff08\u8fd9\u6709\u70b9\u50cf\u4e00\u4e2a\u5806\u6808\u7684\u8fc7\u7a0b\uff09</li> <li>\u5f53\u7136\uff0c\u4f60\u7684C\u6587\u4ef6\u548cH\u6587\u4ef6\u662f\u5b58\u5728\u7684\u5566\uff0c\u4e8e\u662fmake\u4f1a\u751f\u6210 <code>.o</code> \u6587\u4ef6\uff0c\u7136\u540e\u518d\u7528 <code>.o</code> \u6587\u4ef6\u751f\u6210make\u7684\u7ec8\u6781\u4efb\u52a1\uff0c\u4e5f\u5c31\u662f\u6267\u884c\u6587\u4ef6 <code>main</code> \u4e86\u3002</li> </ol>"},{"location":"lab/lab2/#make-clean","title":"make clean","text":"<p>\u901a\u8fc7\u4e0a\u8ff0\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u50cfclean\u8fd9\u79cd\uff0c\u6ca1\u6709\u88ab\u7b2c\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\u76f4\u63a5\u6216\u95f4\u63a5\u5173\u8054\uff0c\u90a3\u4e48\u5b83\u540e\u9762\u6240\u5b9a\u4e49\u7684\u547d\u4ee4\u5c06\u4e0d\u4f1a\u88ab\u81ea\u52a8\u6267\u884c\uff0c\u4e0d\u8fc7\uff0c\u6211\u4eec\u53ef\u4ee5\u663e\u5f0f\u8981make\u6267\u884c\u3002\u5373\u547d\u4ee4\u2014\u2014 <code>make clean</code> \uff0c\u4ee5\u6b64\u6765\u6e05\u9664\u6240\u6709\u7684\u76ee\u6807\u6587\u4ef6\uff0c\u4ee5\u4fbf\u91cd\u65b0\u7f16\u8bd1\u3002</p> <p>\u53c2\u8003\u53ca\u66f4\u591a\u5173\u4e8eMakefile\u7684\u77e5\u8bc6\u8bf7\u67e5\u770b\uff1a\uff08\u8ddf\u6211\u4e00\u8d77\u5199Makefile 1.0 \u6587\u6863 \uff09</p>"},{"location":"lab/linuxlab-fork/","title":"fork","text":"<p>fork &amp; exec &amp; wait</p> <p>argv, env</p> <p>how to check fork duplicate memory &amp; file?</p> <p>process tree, parent process, how does wait work</p> <p>reparent</p>"},{"location":"lab/xv6lab-baremetal/","title":"\u88f8\u673a\u7a0b\u5e8f - Bare Metal","text":"<p>\u5f53\u6211\u4eec\u5728\u4e3a Linux \u73af\u5883\u7f16\u7a0b\u65f6\uff0c\u7531\u4e8eLinux\u73af\u5883\u5df2\u7ecf\u63d0\u4f9b\u4e86libc\u51fd\u6570\u548c\u5bf9\u5e94\u7684\u5c01\u88c5\u597d\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u6211\u4eec\u901a\u5e38\u53ea\u9700\u8981\u8003\u8651\u7a0b\u5e8f\u7684\u903b\u8f91\u5c31\u53ef\u4ee5\u5b8c\u6210\u4e0e\u64cd\u4f5c\u7cfb\u7edf\u7684\u4ea4\u4e92\u3002\u4f8b\u5982\u5f53\u6211\u4eec\u4f7f\u7528 printf \u548c scanf \u5728\u6807\u51c6\u8f93\u5165\u8f93\u51fa\u6d41\u4e0a\u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u7528\u6237\u6001\u7684\u8fd0\u884c\u73af\u5883\u662f\u7531 libc \u63d0\u4f9b\u7684\uff0c\u800c\u5185\u6838\u73af\u5883\u662f\u7531 Linux Kernel \u63d0\u4f9b\u7684\u3002</p> <p>\u4f46\u662f\uff0c\u5f53\u6211\u4eec\u5728\u5199\u81ea\u5df1\u7684\u64cd\u4f5c\u7cfb\u7edf\u65f6\uff0c\u6211\u4eec\u5e76\u6ca1\u6709 Linux \u6216\u5176\u4ed6\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u8fd0\u884c\u73af\u5883\uff0c\u800c\u662f\u76f4\u63a5\u4e0e CPU \u548c\u786c\u4ef6\u4ea4\u4e92\u3002\u8fd9\u79cd\u76f4\u63a5\u4e0eCPU\u548c\u786c\u4ef6\u76f4\u63a5\u8fdb\u884c\u4ea4\u4e92\u7684\u7a0b\u5e8f\u88ab\u79f0\u4e3a\u88f8\u673a\u7a0b\u5e8f ( bare-metal program )\u3002</p> <p>\u4ec0\u4e48\u662f\u88f8\u673a\u7a0b\u5e8f</p> <p>A bare-metal program is a type of software that runs directly on the hardware of a device without relying on an underlying operating system (OS). Essentially, it's code that interacts with the hardware at the most fundamental level, controlling the processor, memory, input/output (I/O) devices, and other components directly.</p> <p>\u5728\u6211\u4eec\u7684 xv6 \u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u5728 RISC-V \u4f53\u7cfb\u67b6\u6784\u4e0a\u7f16\u5199\u64cd\u4f5c\u7cfb\u7edf\u7a0b\u5e8f\u3002</p> \u5b9e\u9a8c\u6b65\u9aa4 1 \uff1a\u8fd0\u884c\u7b2c\u4e00\u4e2a\u88f8\u673a\u7a0b\u5e8f <p>xv6-lab1 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab1</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab1 xv6lab1</code> \u4e0b\u8f7d xv6-lab1 \u4ee3\u7801\u3002</p> <p>\u5efa\u8bae\u6bcf\u6b21\u5b9e\u9a8c\u7684\u4ee3\u7801\u4e0b\u8f7d\u5728\u4e0d\u540c\u4f4d\u7f6e\u3002</p> <p>\u5728 git clone \u4e0a\u8ff0\u4ee3\u7801\u4ed3\u5e93\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u672c\u5730\u8fd0\u884c <code>make</code> \u6765\u7f16\u8bd1 xv6 \u5185\u6838\u3002\u5728 <code>make</code> \u7f16\u8bd1\u5185\u6838\u6210\u529f\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>make run</code> \u8c03\u7528 qemu \u6765\u8fd0\u884c\u6211\u4eec\u7684\u7b2c\u4e00\u4e2a xv6 \u64cd\u4f5c\u7cfb\u7edf\u3002</p> <p><code>make run</code> \u4f1a\u8c03\u7528\u4ee5\u4e0b\u547d\u4ee4\uff1a<code>qemu-system-riscv64 -nographic -machine virt -cpu rv64 -m 512 -kernel build/kernel</code>\uff0c\u8fd9\u8868\u793a\uff1a</p> <ul> <li>\u4f7f\u7528 <code>qemu-system-riscv64</code> \u6a21\u62df\u4e00\u4e2a RISC-V 64\u4f4d CPU</li> <li><code>-nographic</code>\uff1a\u7981\u7528\u56fe\u5f62\u8f93\u51fa</li> <li><code>-machine virt</code>\uff1a\u4f7f\u7528 <code>virt</code> \u673a\u5668\u6a21\u578b</li> <li><code>-cpu rv64</code>\uff1a\u4f7f\u7528 riscv64 \u4f4d CPU</li> <li><code>-m 512</code>\uff1a\u6307\u5b9a\u5185\u5b58\u5927\u5c0f 512MiB</li> <li><code>-kernel build/kernel</code>\uff1a\u6307\u5b9a\u52a0\u8f7d\u7684\u5185\u6838\u6587\u4ef6\u4e3a build/kernel</li> </ul> <p>\u4ec0\u4e48\u662fQEMU?</p> <p>QEMU\u662f\u4e00\u6b3e\u5f00\u6e90\u7684\u865a\u62df\u673a\u8f6f\u4ef6\uff0c\u5b83\u53ef\u4ee5\u6a21\u62df\u591a\u79cd\u4e0d\u540c\u7684\u786c\u4ef6\u5e73\u53f0\uff0c\u5305\u62ecx86\u3001ARM\u3001MIPS\u3001SPARC\u7b49\uff0c\u652f\u6301\u591a\u79cd\u64cd\u4f5c\u7cfb\u7edf\u7684\u8fd0\u884c\uff0c\u5982Linux\u3001Windows\u3001Mac OS X\u3001FreeBSD\u7b49\u3002QEMU\u53ef\u7528\u4e8e\u865a\u62df\u5316\u3001\u4eff\u771f\u3001\u8c03\u8bd5\u548c\u6d4b\u8bd5\u7b49\u591a\u79cd\u5e94\u7528\u573a\u666f\u3002\u5b83\u652f\u6301\u5168\u7cfb\u7edf\u4eff\u771f\u548c\u7528\u6237\u6a21\u5f0f\u4eff\u771f\uff0c\u5141\u8bb8\u7528\u6237\u5728\u4e00\u79cd\u67b6\u6784\u4e0a\u8fd0\u884c\u53e6\u4e00\u79cd\u67b6\u6784\u7684\u64cd\u4f5c\u7cfb\u7edf\u548c\u7a0b\u5e8f\u3002</p> <p>\u5728\u6211\u4eec\u7684\u64cd\u4f5c\u7cfb\u7edf\u8bfe\u7a0b\u4e2d\uff0c\u5176\u5b9e\u662f\u5728\u73b0\u6709\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u901a\u8fc7\u865a\u62df\u673a\u8f6f\u4ef6\u5b89\u88c5\u4e86linux\u7cfb\u7edf\uff0c\u518d\u5728\u865a\u62df\u673a\u7684linux\u7cfb\u7edf\u4e2d\u4f7f\u7528QEMU\u6a21\u62df\u4e00\u4e2aRISCV64\u67b6\u6784\u7684\u865a\u62df\u673a\uff0c\u6700\u540e\u5728\u8fd9\u53f0\u865a\u62df\u673a\u4e0a\u8fd0\u884c\u6211\u4eec\u7f16\u5199\u7684\u64cd\u4f5c\u7cfb\u7edf\u3002 </p> <p>\u8fd0\u884c\u6548\u679c\u5982\u4e0b\uff1a</p> <pre><code>$ make run\nqemu-system-riscv64 -nographic -machine virt -cpu rv64 -m 512 -kernel build/kernel \n\nOpenSBI v1.5\n   ____                    _____ ____ _____\n  / __ \\                  / ____|  _ \\_   _|\n | |  | |_ __   ___ _ __ | (___ | |_) || |\n | |  | | '_ \\ / _ \\ '_ \\ \\___ \\|  _ &lt; | |\n | |__| | |_) |  __/ | | |____) | |_) || |_\n  \\____/| .__/ \\___|_| |_|_____/|____/_____|\n        | |\n        |_|\n\nPlatform Name             : riscv-virtio,qemu\nPlatform Features         : medeleg\nPlatform HART Count       : 1\nPlatform IPI Device       : aclint-mswi\nPlatform Timer Device     : aclint-mtimer @ 10000000Hz\nPlatform Console Device   : uart8250\nPlatform HSM Device       : ---\nPlatform PMU Device       : ---\nPlatform Reboot Device    : syscon-reboot\nPlatform Shutdown Device  : syscon-poweroff\nPlatform Suspend Device   : ---\nPlatform CPPC Device      : ---\nFirmware Base             : 0x80000000\nFirmware Size             : 327 KB\nFirmware RW Offset        : 0x40000\nFirmware RW Size          : 71 KB\nFirmware Heap Offset      : 0x49000\nFirmware Heap Size        : 35 KB (total), 2 KB (reserved), 11 KB (used), 21 KB (free)\nFirmware Scratch Size     : 4096 B (total), 416 B (used), 3680 B (free)\nRuntime SBI Version       : 2.0\n\nDomain0 Name              : root\nDomain0 Boot HART         : 0\nDomain0 HARTs             : 0*\nDomain0 Region00          : 0x0000000000100000-0x0000000000100fff M: (I,R,W) S/U: (R,W)\nDomain0 Region01          : 0x0000000010000000-0x0000000010000fff M: (I,R,W) S/U: (R,W)\nDomain0 Region02          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()\nDomain0 Region03          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()\nDomain0 Region04          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()\nDomain0 Region05          : 0x000000000c400000-0x000000000c5fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region06          : 0x000000000c000000-0x000000000c3fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region07          : 0x0000000000000000-0xffffffffffffffff M: () S/U: (R,W,X)\nDomain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\nDomain0 SysReset          : yes\nDomain0 SysSuspend        : yes\n\nBoot HART ID              : 0\nBoot HART Domain          : root\nBoot HART Priv Version    : v1.12\nBoot HART Base ISA        : rv64imafdch\nBoot HART ISA Extensions  : sstc,zicntr,zihpm,zicboz,zicbom,sdtrig\nBoot HART PMP Count       : 16\nBoot HART PMP Granularity : 2 bits\nBoot HART PMP Address Bits: 54\nBoot HART MHPM Info       : 16 (0x0007fff8)\nBoot HART Debug Triggers  : 2 triggers\nBoot HART MIDELEG         : 0x0000000000001666\nBoot HART MEDELEG         : 0x0000000000f0b509\n\nclean bss: 0x0000000080207000 - 0x0000000080207000\nKernel booted.\nHello World!\nsysregs:\nsstatus : 0x8000000200006000\nscause  : 0x0000000000000000\nsepc    : 0x0000000000000000\nstval   : 0x0000000000000000\nsip     : 0x0000000000000000\nsie     : 0x0000000000000000\nsatp    : 0x0000000000000000\n0x00000000deadbeef\nkernel ends, parking...\n</code></pre> <p>\u5982\u4f55\u9000\u51faqemu</p> <p>\u540c\u65f6\u6309\u4e0b Ctrl \u548c A \u6309\u94ae\uff0c\u7136\u540e\u677e\u5f00\uff0c\u518d\u70b9\u51fb X \u6309\u94ae\u3002</p> <p>\u5982\u679c\u4f60\u5df2\u7ecf\u6309\u8fc7\u4e00\u4e9b\u6309\u94ae\u5bfc\u81f4\u4e0a\u8ff0\u65b9\u6cd5\u4e0d\u751f\u6548\uff0c\u53ef\u4ee5\u76f4\u63a5\u5173\u6389 Terminal\u3002</p> <p>\u5b9e\u9a8c\u6b65\u9aa4 1 \u7ed3\u675f</p> <p>\u4e0a\u8ff0\u5b9e\u9a8c\u8fc7\u7a0b\u6f14\u793a\u4e86\u4e00\u4e2a\u6700\u5c0f\u5316\u5185\u6838\u7684\u542f\u52a8\u8fc7\u7a0b\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u5c06\u4ece \u7279\u6743\u7ea7 \u7684\u89d2\u5ea6\u89e3\u91ca\u64cd\u4f5c\u7cfb\u7edf\u5982\u4f55\u542f\u52a8\u8fd0\u884c\u7684\u3002\u9996\u5148\uff0c\u4e86\u89e3\u4e00\u4e0b\u4ec0\u4e48\u662f\u7279\u6743\u7ea7\u3002</p>"},{"location":"lab/xv6lab-baremetal/#privilege-level","title":"\u7279\u6743\u7ea7 (Privilege Level)","text":"<p>Privilege Levels (riscv-privileged.pdf)</p> <p>\u7279\u6743\u7ea7\uff08Privilege Level\uff09\u662f\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\u7528\u4e8e\u5b9a\u4e49\u4e0d\u540c\u8fdb\u7a0b\u6216\u7528\u6237\u5728\u7cfb\u7edf\u4e2d\u6240\u62e5\u6709\u7684\u8bbf\u95ee\u63a7\u5236\u548c\u6743\u9650\u7684\u6982\u5ff5\u3002 \u7279\u6743\u7ea7\u7684\u5b58\u5728\u662f\u4e3a\u4e86\u4fdd\u62a4\u7cfb\u7edf\u8d44\u6e90\u3001\u786e\u4fdd\u5b89\u5168\u6027\uff0c\u5e76\u6839\u636e\u53ef\u4fe1\u5ea6\u548c\u529f\u80fd\u5bf9\u8fdb\u7a0b\u8fdb\u884c\u9694\u79bb\u3002</p> <p>At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode in one or more CSRs (control and status registers). </p> <p>Three RISC-V privilege levels are currently defined as shown in Table 1.1. </p> <p>Privilege levels are used to provide protection between different components of the software stack, and attempts to perform operations not permitted by the current privilege mode will cause an exception to be raised. </p> <p>These exceptions will normally cause traps into an underlying execution environment.</p> <p>\u7279\u6743\u7ea7\u662f CPU \u8fd0\u884c\u65f6\u7684\u4e00\u4e2a\u91cd\u8981\u7684\u72b6\u6001\uff0c\u5b83\u8868\u793a\u4e86\u5f53\u524d\u8fd0\u884c\u7684\u4ee3\u7801\u5177\u6709\u6709\u591a\u9ad8\u7684\u7279\u6743\u3002\u6700\u9ad8\u7279\u6743\u7684\u4ee3\u7801\u5141\u8bb8\u65e0\u9650\u5236\u7684\u8bbf\u95ee\u6240\u6709\u8d44\u6e90\uff0c\u4f8b\u5982\u6240\u6709\u7269\u7406\u5185\u5b58\u548c\u6240\u6709\u5916\u8bbe\uff1b\u800c\u9ad8\u7279\u6743\u53ef\u4ee5\u9650\u5236\u4f4e\u7279\u6743\u7684\u4ee3\u7801\u6240\u80fd\u8bbf\u95ee\u7684\u5185\u5bb9\u3002\u4f8b\u5982\uff0c\u4f4e\u7279\u6743\u72b6\u6001\u4e0d\u5141\u8bb8\u8bbf\u95ee\u9ad8\u7279\u6743\u6240\u62e5\u6709\u7684\u5185\u5b58\u548c CSR \u5bc4\u5b58\u5668\uff1b\u4f46\u662f CPU \u8fd0\u884c\u5728\u4f4e\u7279\u6743\u7ea7\u65f6\uff0c\u7a0b\u5e8f\u53ef\u4ee5\u4e3b\u52a8\u6216\u88ab\u52a8\u5730\u5207\u6362\u81f3\u9ad8\u7279\u6743\u7ea7\u5e76\u6267\u884c\u9884\u5b9a\u7684\u4ee3\u7801\u3002</p> <p>\u4e3a\u4ec0\u4e48\u9700\u8981\u7279\u6743\u7ea7</p> <p>CPU\u8bbe\u8ba1\u4e2d\u5f15\u5165\u7279\u6743\u7ea7\uff08Privilege Levels\uff09\u7684\u4e3b\u8981\u76ee\u7684\u662f\u4e3a\u4e86\u786e\u4fdd\u7cfb\u7edf\u7684\u5b89\u5168\u6027\u548c\u7a33\u5b9a\u6027\uff0c\u7279\u522b\u662f\u5728\u73b0\u4ee3\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u5bf9\u786c\u4ef6\u8d44\u6e90\u8fdb\u884c\u4e25\u683c\u7684\u7ba1\u7406\u548c\u63a7\u5236\u3002\u7279\u6743\u7ea7\u7684\u5f15\u5165\u53ef\u4ee5\u5e2e\u52a9\u64cd\u4f5c\u7cfb\u7edf\u4fdd\u62a4\u5185\u6838\uff08Kernel\uff09\u548c\u7528\u6237\u7a0b\u5e8f\u4e4b\u95f4\u7684\u9694\u79bb\uff0c\u9632\u6b62\u4e0d\u53d7\u4fe1\u4efb\u7684\u4ee3\u7801\u6216\u5e94\u7528\u7a0b\u5e8f\u5bf9\u7cfb\u7edf\u7684\u5173\u952e\u90e8\u5206\u8fdb\u884c\u4e0d\u5f53\u64cd\u4f5c\u3002</p> <p>\u4f8b\u5982\uff0cCPU \u65f6\u95f4\u662f\u4e00\u79cd\u91cd\u8981\u7684\u201c\u786c\u4ef6\u8d44\u6e90\u201d\u3002\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u901a\u8fc7\u8ba9\u591a\u4e2a\u7528\u6237\u7a0b\u5e8f\u8f6e\u6d41\u6267\u884c\u7684\u65b9\u5f0f\uff0c\u5b9e\u73b0\u6240\u6709\u7a0b\u5e8f\u201c\u770b\u8d77\u6765\u201d\u5728\u540c\u65f6\u6267\u884c\u7684\u5047\u8c61\u3002\u6211\u4eec\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\uff08\u9ad8\u7279\u6743\u7ea7\uff09\u6765\u5b9e\u73b0\u5bf9 CPU \u65f6\u95f4\u7684\u7ba1\u7406\uff0c\u5373\u5f3a\u5236\u8ba9\u5e94\u7528\u7a0b\u5e8f\u5728\u6267\u884c\u4e00\u6bb5\u65f6\u95f4\u540e\u6682\u505c\u6267\u884c\uff0c\u5e76\u5207\u6362\u5230\u4e0b\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7ee7\u7eed\u6267\u884c\u3002</p> <p>\u5982\u679c\u6211\u4eec\u4e0d\u4f7f\u7528\u7279\u6743\u7ea7\u6765\u5f3a\u5236\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u800c\u662f\u671f\u671b\u5e94\u7528\u7a0b\u5e8f\u4e3b\u52a8\u5730\u8ba9\u51fa CPU \u65f6\u95f4\uff0c\u90a3\u4e48\u6076\u610f\u7684\u5e94\u7528\u7a0b\u5e8f\u53ef\u4ee5\u4e00\u76f4\u5360\u7528 CPU \u65f6\u95f4\u800c\u4e0d\u91ca\u653e\uff0c\u5bfc\u81f4\u7cfb\u7edf\u4e0a\u6240\u6709\u5e94\u7528\u7a0b\u5e8f\u5747\u65e0\u54cd\u5e94\u3002</p> <p>\u7279\u6743\u7ea7\u7684\u533a\u5206\u662f \u5728 CPU \u786c\u4ef6\u7535\u8def\u4e0a\u5b9e\u73b0 \u7684\uff0c\u800c\u4e0d\u662f\u901a\u8fc7\u8f6f\u4ef6\u6a21\u62df\u7684\u3002\u5728 RISC-V \u4e0a\uff0c\u7279\u6743\u7ea7\u4f7f\u7528 2bit \u8fdb\u884c\u533a\u5206\uff0c\u5206\u4e3a M mode\uff0cS mode\uff0c\u548c U mode\u3002</p> <p></p> <p>The machine level has the highest privileges and is the only mandatory privilege level for a RISC-V hardware platform. Code run in machine-mode (M-mode) is usually inherently trusted, as it has low-level access to the machine implementation. M-mode can be used to manage secure execution environments on RISC-V. User-mode (U-mode) and supervisor-mode (S-mode) are intended for conventional application and operating system usage respectively.</p> <ul> <li>M mode \u4e3a RISC-V \u67b6\u6784\u4e2d\u7684\u6700\u9ad8\u7279\u6743\uff0c\u4e00\u822c\u8fd0\u884c OpenSBI \u56fa\u4ef6\u7a0b\u5e8f\uff0c\u62e5\u6709\u5bf9\u7269\u7406\u5185\u5b58\u7684\u76f4\u63a5\u8bbf\u95ee\u6743\u9650\uff1b</li> <li>S mode \u662f\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u8bbe\u8ba1\u7684\u7279\u9009\u7b49\u7ea7\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u865a\u62df\u5185\u5b58\uff1b</li> <li>U mode \u662f\u4e3a\u7528\u6237\u7a0b\u5e8f\u8bbe\u8ba1\u7684\u7279\u6743\u7b49\u7ea7\uff0c\u62e5\u6709\u6700\u5c0f\u7684\u7279\u6743\uff0c\u4e5f\u9002\u7528\u4e8e\u865a\u62df\u5185\u5b58\u3002</li> </ul> <p>\u5728\u88f8\u673a\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u5b8c\u6210\u5bf9 CPU \u72b6\u6001\u7684\u521d\u59cb\u5316\uff0c\u5305\u62ec\u4e86\u9875\u8868\u3001\u4e2d\u65ad\u7b49\u57fa\u672c\u529f\u80fd\u3002 \u8fd9\u4e9b CPU \u7684\u72b6\u6001\u662f\u901a\u8fc7 CSR (Control and Status Registers) \u63a7\u5236\u7684\uff0c\u8fd9\u4e9b\u5bc4\u5b58\u5668\u4e00\u822c\u53ea\u5141\u8bb8\u9ad8\u7279\u6743\u7ea7\u7684\u7528\u6237\u8fdb\u884c\u8bbf\u95ee\u548c\u4fee\u6539\u3002</p>"},{"location":"lab/xv6lab-baremetal/#aarch64-x86","title":"AArch64 &amp; x86","text":"<p>\u73b0\u4ee3\u7684\u6307\u4ee4\u96c6\u67b6\u6784\u5747\u6709\u8bbe\u7f6e\u4e0d\u540c\u7684\u7279\u6743\u7ea7\u3002</p> <p>\u79fb\u52a8\u8bbe\u5907\u4e0a\u6700\u5e38\u4f7f\u7528\u7684 arm64 (AArch64) CPU \u67b6\u6784\u5b9a\u4e49\u4e86\u56db\u79cd\u7279\u6743\u7ea7(Exception Levels)\uff0c\u4ece\u4f4e\u5230\u9ad8\uff1a EL0\u3001EL1\u3001EL2\u548cEL3\u3002 \u4e0e RISC-V \u67b6\u6784\u7c7b\u4f3c\uff0c\u6700\u9ad8\u7279\u6743\u7ea7 EL3 \u8fd0\u884c\u6700\u5e95\u5c42\u7684\u56fa\u4ef6(Secure Monitor)\uff0cEL1 \u7279\u6743\u7ea7\u8fd0\u884c\u64cd\u4f5c\u7cfb\u7edf(OS)\uff0cEL0 \u7279\u6743\u7ea7\u8fd0\u884c\u7528\u6237\u7a0b\u5e8f\uff0c\u800cEL2\u7279\u6743\u7ea7\u8fd0\u884c\u865a\u62df\u673a\u7a0b\u5e8f(Hypervisor)\u3002</p> <p>\u800c x86 (IA32 &amp; AMD64) \u67b6\u6784\u5b9a\u4e49\u7279\u6743\u7ea7\u4e3a\u56db\u4e2a Ring \uff1aRing 0 \u4ee3\u8868\u6700\u9ad8\u7279\u6743\u7ea7\uff0c\u8fd0\u884c\u64cd\u4f5c\u7cfb\u7edf\uff1b\u800c Ring 3 \u4ee3\u8868\u6700\u4f4e\u7279\u6743\u7ea7\uff0c\u8fd0\u884c\u7528\u6237\u7a0b\u5e8f\u3002\u901a\u5e38\u6765\u8bf4\uff0cx86\u67b6\u6784\u4e0a\u53ea\u4f1a\u4f7f\u7528\u5230 Ring 0 \u548c Ring 3 \u4e24\u79cd\u7279\u6743\u7ea7\u3002</p> <p> \u2192</p>"},{"location":"lab/xv6lab-baremetal/#csr","title":"CSR","text":"<p>\u4e0d\u540c\u4e8e32\u4e2a\u901a\u7528\u5bc4\u5b58\u5668 (General Purpose Registers)\uff0cCSR \u662f\u4e00\u4e9b\u7279\u6b8a\u7684\u5bc4\u5b58\u5668\u3002(\u5982\u679c\u4f60\u4e0d\u77e5\u9053\u5bc4\u5b58\u5668\u662f\u4ec0\u4e48\uff0c\u4f60\u9700\u8981\u5b66\u4e60\u4e0b\u8ba1\u7ec4\u76f8\u5173\u77e5\u8bc6)</p> <p>CSR\uff08Control and Status Registers\uff0c\u63a7\u5236\u4e0e\u72b6\u6001\u5bc4\u5b58\u5668\uff09\u662f\u7528\u4e8e\u63a7\u5236 CPU \u884c\u4e3a\u3001\u5b58\u50a8\u7cfb\u7edf\u72b6\u6001\u3001\u7ba1\u7406\u5f02\u5e38\u548c\u4e2d\u65ad\u7684\u91cd\u8981\u5bc4\u5b58\u5668\u96c6\u3002CSR \u5bc4\u5b58\u5668\u9700\u8981\u7528\u7279\u6b8a\u7684\u6307\u4ee4\u6765\u8bbf\u95ee\u3002</p> <p>\u6bcf\u4e2a CSR \u5747\u6709\u7279\u6743\u7ea7\u9650\u5236\u3002\u4f8b\u5982\uff0c<code>time</code> \u548c <code>cycle</code> \u5bc4\u5b58\u5668\u53ef\u4ee5\u88ab U mode \u8bfb\u53d6\u4f46\u4e0d\u80fd\u4fee\u6539\u3002<code>sstatus</code> \u7b49 S mode CSR \u53ef\u4ee5\u88ab S/M mode \u8bfb\u5199\u3002<code>mstatus</code> \u7b49 M mode CSR \u53ea\u80fd\u88ab M mode \u8bfb\u5199\u3002\u5728\u4f4e\u7279\u6743\u7ea7\u8bbf\u95ee\u9ad8\u7279\u6743\u7ea7\u7684 CSR \u4f1a\u89e6\u53d1\u7a0b\u5e8f\u5f02\u5e38\u3002</p> <p>\u6bcf\u4e2a CSR \u4e2d\u4f1a\u5b9a\u4e49\u4e00\u4e9b\u5b57\u6bb5\uff08Field\uff09\uff0c\u5b83\u4eec\u5360\u636e\u4e00\u4e9b\u6bd4\u7279\uff0c\u8868\u793a\u4e00\u4e9b\u7279\u6b8a\u7684\u542b\u4e49\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u8bfe\u7a0b\u4e2d\u66f4\u591a\u7684\u63a5\u89e6 CSR\u3002</p>"},{"location":"lab/xv6lab-baremetal/#_1","title":"\u8fd0\u884c\u73af\u5883","text":"<p>\u5728 RISC-V \u7684\u4e09\u4e2a\u7279\u6743\u7ea7\u4e0a\uff0cRISC-V \u67b6\u6784\u5b9a\u4e49\u4e86\u4e09\u79cd\u8fd0\u884c\u72b6\u6001\uff1a\u5206\u522b\u662f \u56fa\u4ef6 (Machine mode) \u3001 \u64cd\u4f5c\u7cfb\u7edf (Supervisor mode) \u548c \u7528\u6237\u6001 (User mode) \u3002</p> <p>\u5728 RISC-V \u67b6\u6784\u4e2d\uff0c\u64cd\u4f5c\u7cfb\u7edf (Supervisor) \u5411\u5e94\u7528\u7a0b\u5e8f (Application) \u63d0\u4f9b\u7684\u8fd0\u884c\u73af\u5883\u88ab\u79f0\u4e3a ABI (Application Binary Interface)\uff0c\u800c\u56fa\u4ef6 (Machine, SEE) \u4e3a\u64cd\u4f5c\u7cfb\u7edf (Supervisor, OS) \u63d0\u4f9b\u7684\u8fd0\u884c\u73af\u5883\u5219\u88ab\u79f0\u4e3a Supervisor Binary Interface (SBI)\u3002</p> <p></p> <p>\u56fa\u4ef6 (OpenSBI) \u63d0\u4f9b\u4e86\u5bf9\u4e00\u4e9b \u57fa\u672c\u786c\u4ef6\u7684\u8bbf\u95ee\u63a5\u53e3 \uff0c\u5e76\u901a\u8fc7\u7c7b\u4f3c syscall \u7684\u65b9\u5f0f\u4e3a S Mode \u63d0\u4f9b\u670d\u52a1\uff0c\u5b83\u4eec\u88ab\u79f0\u4e3a SBI Call\u3002\u5176\u4e2d\u5c31\u5305\u542b\u4e86\u57fa\u672c\u7684\u4e32\u53e3\u8f93\u5165\u8f93\u51fa\u51fd\u6570\uff0c<code>sbi_console_putchar</code> \u548c <code>sbi_console_getchar</code>\u3002</p>"},{"location":"lab/xv6lab-baremetal/#_2","title":"\u542f\u52a8\u6d41\u7a0b\u6982\u8ff0","text":"<p>\u64cd\u4f5c\u7cfb\u7edf\u7684\u542f\u52a8\u6d41\u7a0b\u5373\u662f\u5bf9\u6bcf\u4e00\u7ea7\u8fd0\u884c\u73af\u5883\u7684\u521d\u59cb\u5316\u3002\u901a\u5e38\uff0c\u6211\u4eec\u4f1a\u4ece\u9ad8\u7279\u6743\u7ea7\u5f00\u59cb\u521d\u59cb\u5316\uff0c\u5e76\u4e00\u7ea7\u4e00\u7ea7\u5730\u964d\u7ea7\u5230\u4f4e\u7279\u6743\u7ea7\u4e0a\u7ee7\u7eed\u8fdb\u884c\u521d\u59cb\u5316\u3002</p> <p>\u4ece CPU \u4e0a\u7535\u590d\u4f4d\u7684\u90a3\u4e00\u523b\u8d77\uff0c\u4fbf\u5f00\u59cb\u6267\u884c\u7b2c\u4e00\u6761\u6307\u4ee4\u3002\u6b64\u65f6\uff0cCPU \u8fd0\u884c\u7684\u4ee3\u7801\u901a\u5e38\u6765\u81ea\u82af\u7247\u5185\u90e8\u6216\u5916\u90e8\u7684\u4e00\u5757\u5c0f\u578b ROM \u533a\u57df\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a Bootloader\u3002Bootloader \u53ef\u4ee5\u88ab\u89c6\u4e3a\u542f\u52a8\u7684\u7b2c 0 \u9636\u6bb5\uff0c\u5b83\u7684\u4e3b\u8981\u4efb\u52a1\u662f\u627e\u5230\u4e0b\u4e00\u9636\u6bb5\u7684\u955c\u50cf\u3001\u590d\u5236\u5230\u5185\u5b58\u4e2d\u3001\u5e76\u8df3\u8f6c\u3002</p> <p>\u5728 RISC-V \u5e73\u53f0\u4e0a\uff0c\u4e0b\u4e00\u9636\u6bb5\u662f SBI\uff08Supervisor Binary Interface\uff09 \u7684\u521d\u59cb\u5316\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 OpenSBI \u5b9e\u73b0\u8fd9\u4e2a\u521d\u59cb\u5316\u8fc7\u7a0b\u3002\u56e0\u6b64\uff0c\u5728\u7b2c0\u9636\u6bb5\uff0cOpenSBI \u955c\u50cf\u548c\u6211\u4eec\u7684\u5185\u6838\u955c\u50cf\u4f1a\u88ab\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u3002Bootloader \u8d1f\u8d23\u5c06 CPU \u8df3\u8f6c\u5230 OpenSBI \u7684\u52a0\u8f7d\u5730\u5740\uff0c\u5e76\u542f\u52a8\u5176\u4ee3\u7801\u6267\u884c\u3002\u6b64\u65f6\uff0c\u6211\u4eec\u8fdb\u5165\u4e86\u4e0b\u4e00\u9636\u6bb5\u3002</p> <p></p> <p>\u5728\u8fd9\u4e00\u9636\u6bb5\u4e2d\uff0c OpenSBI \u4f1a\u5bf9\u91cd\u8981\u7684\u7cfb\u7edf\u8bbe\u5907\u8fdb\u884c\u521d\u59cb\u5316\u3002\u5f53 OpenSBI \u5b8c\u6210 M \u6a21\u5f0f\uff08M mode\uff09 \u7684\u521d\u59cb\u5316\u540e\uff0c\u5b83\u4f1a\u5c06 CPU \u6743\u9650\u964d\u7ea7\u81f3 S \u6a21\u5f0f\uff08S mode\uff09\uff0c\u5e76\u8fdb\u5165\u5185\u6838\u7684\u5165\u53e3\u70b9\uff0c\u6b63\u5f0f\u5f00\u59cb\u6267\u884c\u5185\u6838\u4ee3\u7801\u3002</p> <p>\u4e0b\u9762\u6211\u4eec\u5c06\u5177\u4f53\u89e3\u91ca\u6bcf\u4e00\u9636\u6bb5\u7684\u5de5\u4f5c\uff1a</p>"},{"location":"lab/xv6lab-baremetal/#0-cpu","title":"\u7b2c0\u9636\u6bb5\uff1a\u4ece CPU \u4e0a\u7535\u5f00\u59cb\u5b9e\u9a8c\u6b65\u9aa4 2 \uff1aGDB\u8c03\u8bd5\uff0c\u89c2\u5bdf\u542f\u52a8\u8fc7\u7a0b","text":"<p>\u5728 CPU \u4e0a\u7535\u540e\uff0c\u5b83\u4f1a\u8fdb\u884c\u786c\u4ef6\u7ea7\u522b\u7684\u590d\u4f4d\uff0c\u53ef\u4ee5\u56de\u60f3\u4e00\u4e0b\u6211\u4eec\u5728\u6570\u5b57\u903b\u8f91\u8bfe\u7a0b\u4e2d\u5982\u4f55\u5bf9 reg \u53d8\u91cf\u5728 rst_n \u65f6\u8fdb\u884c\u590d\u4f4d\u3002</p> <p>\u590d\u4f4d\u4f1a\u5c06 PC \u8bbe\u7f6e\u5230\u4e00\u4e2a\u56fa\u5b9a\u503c\uff0c\u5b83\u88ab\u79f0\u4e3a Reset Vector\uff08\u590d\u4f4d\u5411\u91cf\uff09\uff0c\u8fd9\u662f CPU \u4e0a\u7535\u540e\u6267\u884c\u7684\u7b2c\u4e00\u4e2a\u4ee3\u7801\u7684\u5730\u5740\u3002 Reset Vector \u6307\u5411\u7684\u5730\u5740\u7a7a\u95f4\u4e00\u822c\u662f\u7531 RISC-V \u7247\u4e0a\u7684 Block ROM \u63d0\u4f9b\u7684\uff0c\u8fd9\u4e00\u7247\u4ee3\u7801\u533a\u57df\u662f\u4e0d\u53ef\u5199\u5165\u7684\u3002\u5728 Reset Vector \u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u5b83\u4f1a\u5c06\u63a7\u5236\u6d41\u8df3\u8f6c\u5230\u4e0b\u4e00\u9636\u6bb5. \u5728 QEMU \u4e2d\uff0c\u4e0b\u4e00\u9636\u6bb5\u5373\u662f M mode \u7684 OpenSBI\u3002</p> <p>\u4ec0\u4e48\u662f\u5b9e\u73b0\u5b9a\u4e49\u884c\u4e3a</p> <p>\u6bcf\u4e2a RISC-V \u786c\u4ef6\u7684 Reset Vector \u503c\u662f\u7531\u5b83\u5b9e\u73b0\u6240\u8bbe\u7f6e\u7684\uff0c\u800c RISC-V \u624b\u518c\u5e76\u6ca1\u6709\u89c4\u5b9a RISC-V \u786c\u4ef6\u7684 Reset Vector \u8be5\u662f\u591a\u5c11\uff0c\u6211\u4eec\u5c06\u8fd9\u79cd\u503c\u79f0\u4e3a Implementation-Defined \u3002</p> <p>GDB \u8c03\u8bd5</p> <p>GDB\uff08GNU Debugger\uff09\u662f\u4e00\u4e2a\u529f\u80fd\u5f3a\u5927\u7684\u5f00\u6e90\u8c03\u8bd5\u5de5\u5177\uff0c\u4e3b\u8981\u7528\u4e8e\u8c03\u8bd5\u7528C\u3001C++\u7b49\u7f16\u7a0b\u8bed\u8a00\u7f16\u5199\u7684\u7a0b\u5e8f\u3002\u5b83\u53ef\u4ee5\u5e2e\u52a9\u5f00\u53d1\u8005\u67e5\u627e\u548c\u4fee\u590d\u7a0b\u5e8f\u4e2d\u7684\u9519\u8bef\uff0c\u652f\u6301\u591a\u79cd\u8c03\u8bd5\u529f\u80fd\uff0c\u5982\u8bbe\u7f6e\u65ad\u70b9\u3001\u5355\u6b65\u6267\u884c\u3001\u67e5\u770b\u53d8\u91cf\u503c\u3001\u68c0\u67e5\u5185\u5b58\u72b6\u6001\u7b49\u3002</p> <p>\u901a\u8fc7GDB\u8c03\u8bd5\u5de5\u5177\uff0c\u6211\u4eec\u53ef\u4ee5\u5728QEMU\u8fd0\u884c\u64cd\u4f5c\u7cfb\u7edf\u65f6\u6253\u65ad\u70b9\uff0c\u89c2\u5bdf\u64cd\u4f5c\u7cfb\u7edf\u7684\u8fd0\u884c\u8fc7\u7a0b\u3002</p> <p>\u9996\u5148\uff0c\u5c06 <code>set auto-load safe-path /</code> \u8fd9\u4e00\u884c\u52a0\u5165\u5230 <code>~/.gdbinit</code> \u4e0b\u9762\uff0c\u4ee5\u5141\u8bb8 gdb \u81ea\u52a8\u52a0\u8f7d\u5f53\u524d\u76ee\u5f55\u4e0b\u7684<code>.gdbinit</code> \u6587\u4ef6\u3002</p> <p>\u5728\u4e00\u4e2a\u7ec8\u7aef\u4e2d\u6267\u884c <code>make debug</code>\uff0c\u5b83\u4f1a\u542f\u52a8 <code>qemu-system-riscv64</code>\uff0c\u4f46\u662f\u4f1a\u52a0\u4e0a\u53c2\u6570 <code>-S -gdb tcp::3333</code>\uff0c\u8fd9\u8868\u793a\u5b83\u4f1a\u7b49\u5f85\u8c03\u8bd5\u5668\u9644\u52a0\u3002 \u63a5\u7740\uff0c\u5728\u53e6\u4e00\u4e2a\u7ec8\u7aef\uff08\u786e\u4fdd\u5b83\u7684 PWD \u548c\u4e0a\u4e00\u4e2a\u7ec8\u7aef\u4e00\u81f4\uff09\u8fd0\u884c <code>gdb-multiarch</code>\uff0c\u5b83\u4f1a\u542f\u52a8 GDB \u8c03\u8bd5\u5668\u5e76\u81ea\u52a8\u52a0\u8f7d\u5f53\u524d\u76ee\u5f55\u4e0b\u9762\u7684 <code>.gdbinit</code> \u6587\u4ef6\u3002</p> <p>\u5982\u679c\u4e00\u5207\u6b63\u5e38\uff0cgdb \u4f1a\u505c\u7559\u5728\u5730\u5740 <code>0x1000</code> \u4e0a\uff0c\u8fd9\u5373\u662f QEMU \u5e73\u53f0\u7684 Reset Vector \u5730\u5740\u3002</p> <p></p> <p>\u4f7f\u7528 <code>x/10i $pc</code> \u6307\u4ee4\u53ef\u4ee5\u6253\u5370\u5f53\u524d PC \u6307\u9488\u6240\u6307\u5411\u7684 10 \u6761\u6307\u4ee4\u3002</p> <p>Lab \u5b9e\u9a8c\u62a5\u544a 1</p> <p>\u8bf7\u4f60\u627e\u51fa QEMU \u7684 Bootloader \u6267\u884c\u5b8c\u6bd5\u540e\u5c06\u8df3\u8f6c\u7684\u4e0b\u4e00\u9636\u6bb5\u7684\u6307\u4ee4\u5730\u5740\u3002</p> <p>\u4f7f\u7528 <code>si</code> \u53ef\u4ee5\u6267\u884c\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c\u5f53\u4f60\u6267\u884c\u5230 <code>jr t0</code> \u65f6\uff0c\u4f7f\u7528 <code>print $t0</code> \u6253\u5370 t0 \u5bc4\u5b58\u5668\u7684\u503c\u3002</p> <p>\u7136\u540e\uff0c\u5c06t0\u5bc4\u5b58\u5668\u7684\u503c\u5199\u5728\u5b9e\u9a8c\u62a5\u544a\u4e2d\u3002</p> <p>Lab \u5b9e\u9a8c\u62a5\u544a 2</p> <p>\u8bf7\u4f60\u627e\u51fa QEMU \u5728\u542f\u52a8\u65f6\u5f80\u5185\u5b58\u4e2d\u52a0\u8f7d\u4e86\u54ea\u4e9b\u5185\u5bb9\u3002</p> <p>\u53c2\u7167 \u5b9e\u9a8c\u62a5\u544a 1\uff0c\u6253\u5f00\u4e00\u4e2a GDB \u7ec8\u7aef\uff0c\u6267\u884c\u547d\u4ee4 <code>monitor info roms</code>\uff0c\u5c06\u8f93\u51fa\u4fe1\u606f\u586b\u5165\u62a5\u544a\u7eb8\u4e0a\u9762\u7684\u8868\u683c\u4e2d\u3002</p> <p>\u6bcf\u6761\u8f93\u51fa\u4fe1\u606f\u4e2d\uff0caddr \u8868\u793a\u52a0\u8f7d\u7684\u8d77\u59cb\u5730\u5740\uff0csize \u8868\u793a\u52a0\u8f7d\u7684\u5185\u5bb9\u957f\u5ea6\uff0cmem=rom/ram \u8868\u793a\u8fd9\u4e00\u6bb5\u5185\u5bb9\u662f\u4e0d\u53ef\u4fee\u6539\u7684 ROM \u8fd8\u662f\u53ef\u4fee\u6539\u7684\u5185\u5b58 RAM\u3002</p> <p>\u5b9e\u9a8c\u6b65\u9aa4 2 \u7ed3\u675f</p>"},{"location":"lab/xv6lab-baremetal/#opensbi","title":"\u4e0b\u4e00\u9636\u6bb5\uff1aOpenSBI","text":"<p>\u5728\u8ba1\u7b97\u673a\u4e2d\uff0c\u56fa\u4ef6(firmware)\u662f\u4e00\u79cd\u7279\u5b9a\u7684\u8ba1\u7b97\u673a\u8f6f\u4ef6\uff0c\u5b83\u4e3a\u8bbe\u5907\u7684\u7279\u5b9a\u786c\u4ef6\u63d0\u4f9b\u4f4e\u7ea7\u63a7\u5236\uff0c\u4e5f\u53ef\u4ee5\u8fdb\u4e00\u6b65\u52a0\u8f7d\u5176\u4ed6\u8f6f\u4ef6\u3002\u56fa\u4ef6\u53ef\u4ee5\u4e3a\u8bbe\u5907\u66f4\u590d\u6742\u7684\u8f6f\u4ef6\uff08\u5982\u64cd\u4f5c\u7cfb\u7edf\uff09\u63d0\u4f9b\u6807\u51c6\u5316\u7684\u64cd\u4f5c\u73af\u5883\u3002 \u5bf9\u4e8e\u4e0d\u592a\u590d\u6742\u7684\u8bbe\u5907\uff0c\u56fa\u4ef6\u53ef\u4ee5\u76f4\u63a5\u5145\u5f53\u8bbe\u5907\u7684\u5b8c\u6574\u64cd\u4f5c\u7cfb\u7edf\uff0c\u6267\u884c\u6240\u6709\u63a7\u5236\u3001\u76d1\u89c6\u548c\u6570\u636e\u64cd\u4f5c\u529f\u80fd\u3002  \u5728\u57fa\u4e8e x86 \u7684\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d, BIOS \u6216 UEFI \u662f\u56fa\u4ef6\uff1b\u5728\u57fa\u4e8e riscv \u7684\u8ba1\u7b97\u673a\u7cfb\u7edf\u4e2d\uff0cOpenSBI \u662f\u56fa\u4ef6\u3002OpenSBI\u8fd0\u884c\u5728M\u6001\uff08M-mode\uff09\uff0c\u56e0\u4e3a\u56fa\u4ef6\u9700\u8981\u76f4\u63a5\u8bbf\u95ee\u786c\u4ef6\u3002</p> <p>\u5728\u8fd9\u4e2a\u9636\u6bb5\uff0cOpenSBI \u4f1a\u5bf9\u91cd\u8981\u7684\u7cfb\u7edf\u8bbe\u5907\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a Platform-level \u7684\u8bbe\u5907\u3002\u5b83\u4eec\u662f\u6574\u4e2a\u7cfb\u7edf\u5171\u4eab\u7684\uff0c\u5373\u591a\u4e2a CPU \uff08\u4e5f\u88ab\u79f0\u4e3a Hart\uff09\u6240\u770b\u5230\u7684\u8bbe\u5907\u662f\u540c\u4e00\u4e2a\u3002</p> <p></p> <pre><code>Platform Name             : riscv-virtio,qemu\nPlatform Features         : medeleg\nPlatform HART Count       : 1\nPlatform IPI Device       : aclint-mswi\nPlatform Timer Device     : aclint-mtimer @ 10000000Hz\nPlatform Console Device   : uart8250\nPlatform HSM Device       : ---\nPlatform PMU Device       : ---\nPlatform Reboot Device    : syscon-reboot\nPlatform Shutdown Device  : syscon-poweroff\nPlatform Suspend Device   : ---\n</code></pre> <p>\u968f\u540e\uff0cOpenSBI \u6307\u5b9a\u4e0b\u4e00\u9636\u6bb5\u7684\u542f\u52a8\u662f\u6211\u4eec\u7684\u5185\u6838\uff1a</p> <pre><code>Domain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\n</code></pre> <p>\u5e76\u521d\u59cb\u5316 Hart \u76f8\u5173\u7684\u914d\u7f6e\uff1a</p> <pre><code>Boot HART ID              : 0\nBoot HART Domain          : root\nBoot HART Priv Version    : v1.12\nBoot HART Base ISA        : rv64imafdch\n</code></pre>"},{"location":"lab/xv6lab-baremetal/#kernel","title":"\u4e0b\u4e0b\u9636\u6bb5\uff1aKernel \u542f\u52a8","text":"<p>\u5728 OpenSBI \u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0cOpenSBI \u4f1a\u964d\u7ea7\u5230 S-mode \u5e76\u5c06 PC \u6307\u9488\u6307\u5411\u6211\u4eec\u7684\u5185\u6838\u8d77\u59cb\u5730\u5740 0x80200000\u3002\u8be5\u5730\u5740\u4e0a\u4fdd\u5b58\u7740\u5185\u6838\u7684\u7b2c\u4e00\u4e2a\u5165\u53e3 _entry \u7684\u4ee3\u7801\uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u64cd\u4f5c\u7cfb\u7edf\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\uff0c\u81f3\u6b64\uff0cCPU \u63a7\u5236\u6743\u6765\u5230\u6211\u4eec\u7684 xv6 \u5185\u6838\u3002</p> <p>_entry \u7684\u4ee3\u7801\u5728 <code>entry.S</code> \u6587\u4ef6\u4e2d\u3002\u4f46\u662f\uff0c \u8fd9\u4e2a\u4ee3\u7801\u662f\u5982\u4f55\u653e\u5230\u5185\u6838\u8d77\u59cb\u5730\u5740 0x80200000 \u5904\u7684\u5462\uff1f</p>"},{"location":"lab/xv6lab-baremetal/#_3","title":"\u7f16\u8bd1\u8fc7\u7a0b","text":"<p>\u9996\u5148\u89c2\u5bdf\u5185\u6838\u4ee3\u7801\u7684\u7f16\u8bd1\u8fc7\u7a0b\uff1a</p> <pre><code>$ /d/o/SUSTech-OS-2025 (xv6-lab1)&gt; make\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/console.c -o build/os/console.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/main.c -o build/os/main.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/printf.c -o build/os/printf.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/sbi.c -o build/os/sbi.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/string.c -o build/os/string.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/entry.S -o build/os/entry.o\nriscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/printf.o build/os/sbi.o build/os/string.o build/os/entry.o\nriscv64-unknown-elf-objdump -S build/kernel &gt; build/kernel.asm\nriscv64-unknown-elf-objdump -t build/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; build/kernel.sym\nBuild kernel done\n</code></pre> <p>\u5c1d\u8bd5\u7406\u89e3\u4e0a\u8ff0\u7f16\u8bd1\u53c2\u6570\uff1a</p> <p>gcc \u662f\u6211\u4eec\u5e38\u7528\u7684 C \u8bed\u8a00\u7f16\u8bd1\u5668\uff0c\u800c <code>riscv64-unknown-elf-gcc</code> \u5219\u8868\u793a\u4f7f\u7528 RISC-V 64 \u4f4d\u3001\u9762\u5411\u672a\u77e5\u5e73\u53f0\u3001\u4ea7\u51fa ELF \u683c\u5f0f\u7684 gcc \u5957\u4ef6\u3002</p> <p>\u5176\u4f59\u7684\u7f16\u8bd1\u53c2\u6570\u6211\u4eec\u53ef\u4ee5\u5206\u5f00\u7406\u89e3\uff1a</p> <ul> <li> <p><code>-march=rv64g -mcmodel=medany -mno-relax</code></p> <p>\u8fd9\u8868\u793a\u6211\u4eec\u7684\u76ee\u6807\u67b6\u6784\u662f rv64g\uff0c\u5bfb\u5740\u6a21\u578b\u662f <code>medany</code>\uff0c\u5e76\u4e14\u94fe\u63a5\u5668\u4e0d\u8981\u8fdb\u884c Relax\u3002</p> <p>See also: https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html</p> </li> <li> <p><code>-ffreestanding -fno-common -nostdlib</code></p> <p>\u8fd9\u8868\u793a\u6211\u4eec\u4e0d\u4f7f\u7528\u6807\u51c6\u5e93\u51fd\u6570\uff0c\u4e5f\u4e0d\u5047\u8bbe\u4e00\u4e9b\u901a\u7528\u51fd\u6570\uff08\u5982 memset\uff09\u7684\u5b9a\u4e49\u4e0e\u6807\u51c6\u51fd\u6570\u5e93\u5b9a\u4e49\u4e00\u81f4\u3002</p> </li> <li> <p><code>-fno-pie -no-pie -fno-plt -fno-omit-frame-pointer -fno-stack-protector</code></p> <p>\u8fd9\u8868\u793a\u751f\u6210\u7684 ELF \u6587\u4ef6\u4e0d\u8981\u4f7f\u7528\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801 (Position-Independent Executable)\uff0c\u56e0\u4e3a\u8fd9\u4f1a\u5bfc\u81f4\u751f\u6210 got \u548c plt \u6bb5\uff0c\u6211\u4eec\u7684\u5185\u6838\u8fd8\u6682\u65f6\u65e0\u6cd5\u5904\u7406\u5982\u6b64\u590d\u6742\u7684\u7ed3\u6784\u3002 <code>-fno-omit-frame-pointer -fno-stack-protector</code> \u8868\u793a\u4fdd\u7559 frame-pointer\uff0c\u7981\u7528\u6808\u4fdd\u62a4\u3002</p> </li> <li> <p><code>-Wall -Wno-unused-variable -Werror -ggdb</code></p> <p>\u8fd9\u8868\u793a\u663e\u793a\u6240\u6709\u8b66\u544a\u3001\u4f46\u662f\u4e0d\u63d0\u793a\u672a\u4f7f\u7528\u7684\u53d8\u91cf\u8b66\u544a\u3001\u5e76\u5c06\u6240\u6709 warning \u5f53\u4f5c error\u3002\u6700\u540e <code>-ggdb</code> \u8868\u793a\u4f7f\u7528 gdb \u8c03\u8bd5\u3002</p> </li> <li> <p><code>-Ios -std=gnu17 -O2 -c os/entry.S -o build/os/entry.o</code></p> <p>\u8868\u793a\u4f7f\u7528 os \u76ee\u5f55\u4f5c\u4e3a include \u76ee\u5f55\uff0c\u4f7f\u7528 gnu17 C\u6807\u51c6\uff0c\u542f\u7528 O2 \u4f18\u5316\u3002</p> <p>\u7f16\u8bd1 (<code>-c</code>) \u539f\u6587\u4ef6 <code>os/entry.S</code>\uff0c\u8f93\u51fa\u5230 <code>build/os/entry.o</code> \u4e2d\u3002</p> </li> </ul> <p>ld \u8868\u793a\u94fe\u63a5\u5668\uff0c\u6211\u4eec\u4f7f\u7528 ld \u5c06\u6240\u6709\u7f16\u8bd1\u5668\u4ea7\u751f\u7684 .o \u6587\u4ef6\u94fe\u63a5\u4e3a\u6700\u7ec8\u7684 kernel ELF \u6587\u4ef6\u3002</p> <p><code>riscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/printf.o build/os/sbi.o build/os/string.o build/os/entry.o</code></p> <p>\u8fd9\u4e00\u4e32\u547d\u4ee4\u8868\u793a\uff1a</p> <ul> <li>\u4f7f\u7528 os/kernel.ld \u4f5c\u4e3a\u94fe\u63a5\u811a\u672c</li> <li>\u8f93\u51fa\u4e3a <code>build/kernel</code></li> <li>\u8f93\u5165\u4e3a\u6240\u6709 .o \u6587\u4ef6</li> </ul>"},{"location":"lab/xv6lab-baremetal/#linker-script","title":"Linker Script","text":"<p>kernel.ld \u662f\u94fe\u63a5\u811a\u672c\uff0c\u94fe\u63a5\u811a\u672c\u5c06\u544a\u77e5\u94fe\u63a5\u5668\u5e94\u8be5\u5982\u4f55\u6392\u5217\u6240\u6709 .o \u6587\u4ef6\u4e2d\u7684\u6bb5\uff08Section\uff09\uff0c\u5373\u5185\u5b58\u5e03\u5c40 (Memory Layout)\uff0c\u5e76\u6307\u660e\u4ea7\u751f\u7684 ELF \u6587\u4ef6\u5e94\u8be5\u5982\u4f55\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d (Program Header)\u3002</p> <p>\u5185\u5b58\u5e03\u5c40</p> <p>\u5185\u5b58\u5e03\u5c40\uff08Memory Layout\uff09\u662f\u6307\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\uff0c\u5176\u6570\u636e\u548c\u4ee3\u7801\u5728\u5185\u5b58\u4e2d\u7684\u7ec4\u7ec7\u65b9\u5f0f\u548c\u5b58\u50a8\u7ed3\u6784\u3002</p> <p>\u901a\u8fc7\u9605\u8bfb <code>kernel.ld</code> \u6211\u4eec\u53ef\u4ee5\u83b7\u5f97xv6\u7684\u5185\u5b58\u5e03\u5c40\uff1a</p> <pre><code>OUTPUT_ARCH(riscv)\nENTRY(_entry)\nBASE_ADDRESS = 0x80200000;\n\nSECTIONS\n{\n    . = BASE_ADDRESS;\n    skernel = .;\n\n    s_text = .;\n    .text : {\n        *(.text.entry)\n        *(.text .text.*)\n        . = ALIGN(4K);\n        e_text = .;\n    }\n\n    . = ALIGN(4K);\n    s_rodata = .;\n    .rodata : {\n        *(.rodata .rodata.*)\n    }\n\n    . = ALIGN(4K);\n    e_rodata = .;\n    s_data = .;\n    .data : {\n        *(.data.apps)\n        *(.data .data.*)\n    }\n\n    . = ALIGN(4K);\n    e_data = .;\n    .bss : {\n        *(.bss.stack)\n        s_bss = .;\n        *(.bss .bss.*)\n    }\n\n    . = ALIGN(4K);\n    e_bss = .;\n    ekernel = .;\n\n    /DISCARD/ : {\n        *(.eh_frame)\n    }\n}\n</code></pre> <p>\u5f00\u5934\u7684 <code>OUTPUT_ARCH</code> \u8868\u793a\u751f\u6210\u7684 ELF \u6587\u4ef6\u9002\u7528\u4e0e RISC-V \u67b6\u6784\uff0c<code>ENTRY</code> \u8868\u793a ELF \u7684\u5165\u53e3\u70b9\u4e3a\u7b26\u53f7 <code>_entry</code>\u3002\u7136\u540e\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5e38\u91cf\u4e3a <code>BASE_ADDRESS</code> \u4f7f\u5b83\u7b49\u4e8e 0x80200000\uff0c\u8fd9\u4e5f\u662f\u6211\u4eec\u5185\u6838\u7684\u8d77\u59cb\u5730\u5740\u3002</p> <p>\u5728 <code>SECTIONS</code> \u4e2d\uff0c\u6211\u4eec\u9996\u5148\u5b9a\u4e49\u5f53\u524d\u5730\u5740 (<code>.</code> \u7b26\u53f7) (\u60f3\u8c61\u94fe\u63a5\u5668\u6b63\u5728\u4ece\u67d0\u4e2a\u5730\u5740\u5f00\u59cb\u7ed9\u6240\u6709 section \u5b89\u6392\u4f4d\u7f6e) \u4e3a 0x80200000\uff0c\u5e76\u5bfc\u51fa <code>skernel</code> \u548c <code>s_text</code> \u7b26\u53f7\u7684\u503c\u4e3a\u5f53\u524d\u5730\u5740\u3002</p> <p>\u968f\u540e\uff0c\u6211\u4eec\u5b9a\u4e49 (.text) \u6bb5\uff0c\u8fd9\u901a\u5e38\u8868\u793a\u4ee3\u7801\u6bb5\uff1a</p> <pre><code>.text : {\n    *(.text.entry)\n    *(.text .text.*)\n    . = ALIGN(4K);\n    e_text = .;\n}\n</code></pre> <p>\u9996\u5148\u6392\u5217\u6240\u6709\u4f4d\u4e8e <code>.text.entry</code> \u7684\u7b26\u53f7\uff0c\u968f\u540e\u6392\u5217\u6240\u6709\u4f4d\u4e8e <code>.text</code> \u7684\u7b26\u53f7\u3002</p> <p>\u6211\u4eec\u5728 <code>.text</code> \u6bb5\u4e2d\u9996\u5148\u5305\u542b\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684 Section <code>.text.entry</code>\uff0c\u8fd9\u4e2a section \u662f\u5728 <code>entry.S</code> \u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\uff1a</p> <pre><code>    .section .text.entry\n    .globl _entry\n_entry:\n</code></pre> <p>\u6211\u4eec\u5728 <code>entry.S</code> \u6587\u4ef6\u4e2d\u6307\u5b9a <code>_entry</code> \u7b26\u53f7\u5e94\u8be5\u88ab\u653e\u7f6e\u5230 <code>.text.entry</code> \u6bb5\uff0c\u5e76\u5728\u94fe\u63a5\u811a\u672c\u4e2d\u6307\u5b9a\u8fd9\u4e2a\u6bb5\u4e3a\u5185\u6838\u7684\u5f00\u59cb\u5730\u5740\u3002 \u8fd9\u6837\u6211\u4eec\u5373\u53ef\u786e\u4fdd _entry \u4f1a\u88ab\u653e\u7f6e\u5230\u5185\u6838\u8d77\u59cb\u5730\u5740\u3002\u5f53\u6211\u4eec\u542f\u52a8\u5185\u6838\u65f6\uff0c\u6211\u4eec\u4f1a\u4ece\u8fd9\u4e2a\u8d77\u59cb\u5730\u5740\u5f00\u59cb\u6267\u884c\uff0c\u4e5f\u5c31\u662f\u6267\u884c\u4e86\u5185\u6838\u7684\u7b2c\u4e00\u6761\u6307\u4ee4\u3002 </p> <p>\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u53cd\u6c47\u7f16 <code>build/kernel</code> \u6765\u89c2\u5bdf\u8fd9\u4e00\u70b9\uff1a</p> <pre><code>$ llvm-objdump-19 -d build/kernel | less\nbuild/kernel:   file format elf64-littleriscv\n\nDisassembly of section .text:\n\n0000000080200000 &lt;skernel&gt;:\n80200000: 00007117      auipc   sp, 0x7\n80200004: 00010113      mv      sp, sp\n80200008: 00000097      auipc   ra, 0x0\n8020000c: 174080e7      jalr    0x174(ra) &lt;main&gt;\n</code></pre> <p>\u7136\u540e\uff0c\u5c06\u5f53\u524d\u5730\u5740\u5bf9\u9f50\u5230 4K \u8fb9\u754c\uff0c\u5bfc\u51fa <code>e_text</code> \u7b26\u53f7\u3002</p> <p>\u5269\u4f59\u7684 <code>.rodata</code>, <code>.data</code> \u548c <code>.bss</code> \u5219\u8868\u793a\u6570\u636e\u6bb5\uff0c\u4f46\u662f\u7565\u6709\u4e0d\u540c\uff1a</p> <ul> <li><code>.rodata</code> \u8868\u793a\u53ea\u8bfb\u7684\u6570\u636e\u6bb5</li> <li><code>.data</code> \u8868\u793a\u53ef\u8bfb\u53ef\u5199\u7684\u6570\u636e\u6bb5</li> <li><code>.bss</code> \u8868\u793a\u5e94\u8be5\u5728\u7a0b\u5e8f\u542f\u52a8\u65f6\u88ab\u6e05\u96f6\u7684\u6570\u636e\u6bb5</li> </ul> <p>\u5f53\u7136\uff0c\u6240\u6709\u6570\u636e\u6bb5\u5747\u662f\u4e0d\u53ef\u6267\u884c\u7684\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u7528\u4ee5\u4e0b\u56fe\u7247\u6765\u8868\u793a Kernel \u955c\u50cf\u7684\u5185\u5b58\u5e03\u5c40\u7ed3\u6784\u3002</p> <p></p> <p>\u6700\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>readelf</code> \u5de5\u5177\u89c2\u5bdf\u6700\u540e\u4ea7\u51fa\u7684 kernel ELF \u6587\u4ef6\uff1a</p> <pre><code>$ /d/o/SUSTech-OS-2025 (xv6-lab1)&gt; llvm-readelf-19 -a build/kernel\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           RISC-V\n  Version:                           0x1\n  Entry point address:               0x80200000\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          29208 (bytes into file)\n  Flags:                             0x4, double-float ABI\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         4\n  Size of section headers:           64 (bytes)\n  Number of section headers:         19\n  Section header string table index: 18\nThere are 19 section headers, starting at offset 0x7218:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        0000000080200000 001000 001000 00  AX  0   0  4\n  [ 2] .rodata           PROGBITS        0000000080201000 002000 0001f0 00   A  0   0  8\n  [ 3] .data             PROGBITS        0000000080202000 003000 000008 00  WA  0   0  8\n  [ 4] .bss              NOBITS          0000000080203000 003008 004000 00  WA  0   0  1\n  [ 5] .debug_info       PROGBITS        0000000000000000 003008 0010c0 00      0   0  1\n  [ 6] .debug_abbrev     PROGBITS        0000000000000000 0040c8 0006e5 00      0   0  1\n  [ 7] .debug_loclists   PROGBITS        0000000000000000 0047ad 0004b5 00      0   0  1\n  [ 8] .debug_aranges    PROGBITS        0000000000000000 004c70 000130 00      0   0 16\n  [ 9] .debug_line       PROGBITS        0000000000000000 004da0 000fe7 00      0   0  1\n  [10] .debug_str        PROGBITS        0000000000000000 005d87 0003bc 01  MS  0   0  1\n  [11] .debug_line_str   PROGBITS        0000000000000000 006143 0000d3 01  MS  0   0  1\n  [12] .comment          PROGBITS        0000000000000000 006216 00001a 01  MS  0   0  1\n  [13] .riscv.attributes RISCV_ATTRIBUTES 0000000000000000 006230 000065 00      0   0  1\n  [14] .debug_frame      PROGBITS        0000000000000000 006298 0004c8 00      0   0  8\n  [15] .debug_rnglists   PROGBITS        0000000000000000 006760 00007f 00      0   0  1\n  [16] .symtab           SYMTAB          0000000000000000 0067e0 0006f0 18     17  31  8\n  [17] .strtab           STRTAB          0000000000000000 006ed0 000279 00      0   0  1\n  [18] .shstrtab         STRTAB          0000000000000000 007149 0000cc 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  R (retain), p (processor specific)\n\nElf file type is EXEC (Executable file)\nEntry point 0x80200000\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x006230 0x0000000000000000 0x0000000000000000 0x000065 0x000000 R   0x1\n  LOAD           0x001000 0x0000000080200000 0x0000000080200000 0x0011f0 0x0011f0 R E 0x1000\n  LOAD           0x003000 0x0000000080202000 0x0000000080202000 0x000008 0x005000 RW  0x1000\n  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10\n\n Section to Segment mapping:\n  Segment Sections...\n   00     .riscv.attributes \n   01     .text .rodata \n   02     .data .bss \n   03     \n   None   .debug_info .debug_abbrev .debug_loclists .debug_aranges .debug_line .debug_str .debug_line_str .comment .debug_frame .debug_rnglists .symtab .strtab .shstrtab\n</code></pre> <ul> <li>\u6700\u7ec8\u7684\u6587\u4ef6\u7c7b\u578b\u4e3a\uff1a<code>Type: EXEC (Executable file)</code></li> <li>\u5165\u53e3\u5730\u5740\u4e3a\uff1a <code>Entry point address: 0x80200000</code></li> <li>\u4e00\u5171\u6709 19 \u4e2a Sections\uff1a<ul> <li>Sections\u6709\u81ea\u5df1\u7684 Flags,\u5176\u4e2d A \u8868\u793a\u8fd9\u4e00\u4e2a Section \u5728\u52a0\u8f7d\u65f6\u5e94\u8be5\u88ab\u5206\u914d\u5185\u5b58\u7a7a\u95f4\uff0cW \u8868\u793a\u53ef\u4ee5\u5199\u5165\uff0cX \u8868\u793a\u53ef\u4ee5\u6267\u884c\u3002</li> </ul> </li> <li>\u4e00\u5171\u6709 4 \u4e2a Program Headers\uff0c\u5176\u4e2d\u6709\u4e24\u4e2a LOAD:<ul> <li>\u7b2c\u4e00\u4e2a LOAD \u8868\u793a\uff1a<ul> <li>\u5728\u865a\u62df\u5730\u5740 (VirtAddr) 0x80200000 \u5904\uff0c\u6620\u5c04\u7269\u7406\u5730\u5740 (PhysAddr) 0x80200000\uff0c\u5206\u914d 0x0011d0 \u5b57\u8282\u7684\u5185\u5b58\u7a7a\u95f4 (MemSiz)\uff0c\u8be5\u5185\u5b58\u6bb5\u7684\u6743\u9650\u4e3a RE (Read &amp; Executable)\u3002</li> <li>\u4ece\u8be5 ELF \u6587\u4ef6\u7684 (Offset) 0x001000 \u5904\u590d\u5236 0x0011d0 \u5b57\u8282 (FileSiz) \u5230\u4e0a\u8ff0\u5185\u5b58\u7a7a\u95f4\u3002</li> </ul> </li> <li>\u7b2c\u4e8c\u4e2a LOAD \u8868\u793a\uff1a<ul> <li>\u5728\u865a\u62df\u5730\u5740 0x80202000 \u5904\uff0c\u6620\u5c04\u7269\u7406\u5730\u5740 0x80202000\uff0c\u5206\u914d 0x005000 \u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u8be5\u5185\u5b58\u6bb5\u6743\u9650\u4e3a RW (Read &amp; Write)\u3002</li> <li>\u4ece\u8be5 ELF \u6587\u4ef6\u7684 0x3000 \u5904\uff0c\u590d\u5236 0x0008 \u5b57\u8282\u5230\u8be5\u5185\u5b58\u6bb5\u3002\u4f46\u662f\uff0c\u8be5\u5185\u5b58\u6bb5\u5206\u914d\u4e86 0x5000 \u7684\u7a7a\u95f4\uff0c \u8fd9\u8868\u793a\u5269\u4e0b\u672a\u88ab\u586b\u5145\u7684\u7a7a\u95f4\u5168\u90fd\u662f\u96f6\uff0c\u8fd9\u5373\u662f bss \u6bb5 \u3002</li> </ul> </li> </ul> </li> <li>\u5728 <code>Section to Segment mapping:</code> \u5904\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff1a<ul> <li>\u7b2c\u4e00\u4e2a Program Headers \u5305\u542b .text, .rodata \u4e09\u4e2a Sections\u3002</li> <li>\u7b2c\u4e8c\u4e2a Program Headers \u5305\u542b .data \u548c .bss \u6bb5\u3002</li> </ul> </li> </ul> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u7ee7\u7eed\u8fd0\u884c\u5185\u6838\u3002</p> <p>\u89c2\u5bdf\u5185\u6838\u8fd0\u884c\u7684\u9996\u51e0\u884c\u4ee3\u7801\uff1a</p> <pre><code>80200000: 00007117      auipc   sp, 0x7\n80200004: 00010113      mv      sp, sp\n80200008: 00000097      auipc   ra, 0x0\n8020000c: 174080e7      jalr    0x174(ra) &lt;main&gt;\n</code></pre> <p>\u6e90\u4ee3\u7801\uff08<code>entry.S</code>\uff09\uff1a</p> <pre><code>    .section .text.entry\n    .globl _entry\n_entry:\n    lla sp, boot_stack_top\n    call main\n\n    .section .bss.stack\n    .globl boot_stack\nboot_stack:\n    .space 4096 * 4\n    .globl boot_stack_top\nboot_stack_top:\n</code></pre> <p>\u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff1a</p> <ul> <li>\u6211\u4eec\u4f7f\u7528 <code>auipc</code> \u548c <code>addi</code> \u6307\u4ee4\uff0c\u5c06\u6808\u6307\u9488\u6307\u5411 <code>boot_stack_top</code>\uff0c\u8fd9\u662f\u6211\u4eec\u63d0\u524d\u4e3a\u7b2c\u4e00\u4e2a\u5185\u6838\u5165\u53e3\u5f00\u8f9f\u7684\u6808\u3002</li> <li>\u6211\u4eec\u901a\u8fc7 <code>auipc</code> \u548c <code>jalr</code> \u6307\u4ee4\uff0c\u8df3\u8f6c\u5230 main \u51fd\u6570\u7ee7\u7eed\u6267\u884c\u3002</li> </ul> <p>\u4e3a\u4ec0\u4e48\u9700\u8981\u4f7f\u7528\u6c47\u7f16\u4f5c\u4e3a\u5185\u6838\u5165\u53e3</p> <p>\u56e0\u4e3a\u5728\u5185\u6838\u5165\u53e3\u5904\uff0cOpenSBI \u6ca1\u6709\u4e3a\u6211\u4eec\u8bbe\u7f6e sp \u6808\u6307\u9488\uff0c\u800c C \u8bed\u8a00\u7684\u8fd0\u884c\u73af\u5883\u8981\u6c42\u6709\u6808\u4f5c\u4e3a\u4fdd\u5b58\u6808\u4e0a\u53d8\u91cf\u548c\u51fd\u6570\u8c03\u7528\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u5730\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u9700\u8981\u4f7f\u7528\u6c47\u7f16\u521d\u59cb\u5316 sp \u5bc4\u5b58\u5668\u3002</p> <p>\u8fd0\u884c\u5b8c\u4e0a\u8ff0\u6c47\u7f16\u4ee3\u7801\u540e\uff0c\u5185\u6838\u8df3\u8f6c\u5230 main \u51fd\u6570\uff1a</p> <p>\u89c2\u5bdf main.c \u4e2d\u7684 main \u51fd\u6570\uff1a</p> <pre><code>void main() {\n    printf(\"\\n\");\n    printf(\"clean bss: %p - %p\\n\", s_bss, e_bss);\n    memset(s_bss, 0, e_bss - s_bss);\n    printf(\"Kernel booted.\\n\");\n    printf(\"Hello World!\\n\");\n\n    printf(\"sysregs:\\n\");\n    print_sysregs();\n    printf(\"%d\\n\", global_variable);\n\n    printf(\"kernel ends, parking...\\n\");\n    while (1);\n}\n</code></pre> <ul> <li>\u9996\u5148\u6e05\u7a7a .bss \u6bb5\uff08\u5728 Linux \u64cd\u4f5c\u7cfb\u7edf\u4e0a\uff0c\u8fd9\u4e00\u6b65\u662f Linux Kernel \u5b9e\u73b0\u7684\uff0c\u4f46\u662f\u73b0\u5728\u6211\u4eec\u5c31\u662f Kernel\uff0c\u6240\u4ee5\u8fd9\u4ef6\u4e8b\u60c5\u5f97\u81ea\u5df1\u5e72\uff09</li> <li>\u7136\u540e\u7528 printf \u6253\u5370\u4e00\u4e9b\u4fe1\u606f\uff0c\u968f\u540e\u5f00\u59cb\u6b7b\u5faa\u73af\u3002</li> </ul> <pre><code>clean bss: 0x0000000080207000 - 0x0000000080207000\nKernel booted.\nHello World!\n</code></pre> <p>Lab \u5b9e\u9a8c\u62a5\u544a 3</p> <p>\u5c1d\u8bd5\u8bfb\u53d6 CSR <code>mvendorid</code>\u3002</p> <p>\u5728 <code>main.c</code> \u4e2d\uff0c\u5728 <code>while(1);</code> \u6b7b\u5faa\u73af\u524d\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>uint64 x;\nasm volatile(\"csrr %0, mvendorid\" : \"=r\"(x));\nprintf(\"csr: %p\\n\", x);\n</code></pre> <p><code>make run</code> \u7f16\u8bd1\u5e76\u8fd0\u884c\uff0c\u4f60\u7684\u7a0b\u5e8f\u80fd\u6b63\u5e38\u8bfb\u53d6\u5230 CSR mvendorid \u7684\u503c\u5417\uff1f</p> <p>\u9605\u8bfb RISC-V Privilege \u624b\u518c (riscv-privilege.pdf) \u7ae0\u8282 2.1  CSR Address Mapping Conventions \u4ee5\u53ca 2.2 CSR Listing\uff0c\u731c\u6d4b\u4e3a\u4ec0\u4e48\u4f60\u7684\u7a0b\u5e8f\u4f1a\u65e0\u9650\u91cd\u542f\u3002</p>"},{"location":"lab/xv6lab-baremetal/#sbi-call","title":"SBI Call","text":"<p>\u5728\u8fd9\u4e2a lab \u7684\u5185\u6838\u4e2d\uff0c<code>printf</code> \u4f1a\u8c03\u7528 <code>consputc</code> \u6765\u5411\u63a7\u5236\u53f0\u6253\u5370\u4e00\u4e2a\u5b57\u7b26\uff0c\u800c\u8fd9\u4e2a\u51fd\u6570\u6700\u7ec8\u4f1a\u8c03\u7528 <code>sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0)</code>\u3002</p> <p>\u5728\u6211\u4eec\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u5982\u679c\u9700\u8981\u8bbf\u95ee\u786c\u4ef6\u63d0\u4f9b\u7684\u529f\u80fd\uff08\u5305\u62ec\u5bf9\u4e32\u53e3\u8f93\u5165\u8f93\u51fa\u7684\u8bbf\u95ee\u51fd\u6570<code>sbi_console_putchar</code> \u548c <code>sbi_console_getchar</code>\uff09\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u8bbe\u7f6e a0\u3001a1 \u7b49\u5bc4\u5b58\u5668\uff0c\u7136\u540e\u901a\u8fc7 <code>ecall</code> \u6307\u4ee4\u5411 M Mode \u7684\u7a0b\u5e8f\uff0c\u5373 OpenSBI\uff0c\u53d1\u8d77\u8bf7\u6c42\u3002OpenSBI \u5728\u5b8c\u6210\u8bf7\u6c42\u540e\u4f1a\u8fd4\u56de\u3002</p> <p>\u5185\u8054\u6c47\u7f16</p> <p>ecall (environment call)\uff0c\u5f53\u6211\u4eec\u5728 S \u6001\u6267\u884c\u8fd9\u6761\u6307\u4ee4\u65f6\uff0c\u4f1a\u89e6\u53d1\u4e00\u4e2a ecall-from-s-mode-exception\uff0c\u4ece\u800c\u8fdb\u5165 M \u6a21\u5f0f\u4e2d\u7684\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b\uff08\u5982\u8bbe\u7f6e\u5b9a\u65f6\u5668\u7b49\uff09\uff1b\u5f53\u6211\u4eec\u5728 U \u6001\u6267\u884c\u8fd9\u6761\u6307\u4ee4\u65f6\uff0c\u4f1a\u89e6\u53d1\u4e00\u4e2a ecall-from-u-mode-exception\uff0c\u4ece\u800c\u8fdb\u5165 S \u6a21\u5f0f\u4e2d\u7684\u4e2d\u65ad\u5904\u7406\u6d41\u7a0b\uff08\u5e38\u7528\u6765\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\uff09\u3002</p> <p>\u6ce8\u610f\uff0cC\u8bed\u8a00\u5e76\u4e0d\u80fd\u76f4\u63a5\u8c03\u7528 <code>ecall</code> , \u9700\u8981\u901a\u8fc7\u5185\u8054\u6c47\u7f16\u6765\u5b9e\u73b0\u3002</p> <p>Calling Convention</p> <p>Calling Convention \u8868\u793a\u5728\u8fdb\u884c\u51fd\u6570\u8c03\u7528\u65f6\uff0c\u8c03\u7528\u8005 (Caller) \u548c \u88ab\u8c03\u7528\u8005 (Callee) \u6240\u9075\u5faa\u7684\u89c4\u8303\u3002</p> <p>\u8fd9\u901a\u5e38\u5305\u542b\u4e86\uff1a</p> <ol> <li>\u53c2\u6570\u4e0e\u8fd4\u56de\u503c\u662f\u5982\u4f55\u4f20\u9012</li> <li>Caller \u548c Callee \u9700\u8981\u4fdd\u5b58\u54ea\u4e9b\u5bc4\u5b58\u5668</li> </ol> <p>SBI \u7684 Calling Convention \u5b9a\u4e49\u5982\u4e0b (riscv-sbi.pdf)\uff1a</p> <p>All SBI functions share a single binary encoding, which facilitates the mixing of SBI extensions. The SBI specification follows the below calling convention.</p> <ul> <li>An ECALL is used as the control transfer instruction between the supervisor and the SEE.</li> <li>a7 encodes the SBI extension ID (EID),</li> <li>a6 encodes the SBI function ID (FID) for a given extension ID encoded in a7 for any SBI extension defined in or after SBI v0.2.</li> <li>All registers except a0 &amp; a1 must be preserved across an SBI call by the callee.</li> <li>SBI functions must return a pair of values in a0 and a1, with a0 returning an error code. </li> </ul> <p>\u800c\u6211\u4eec\u8981\u4f7f\u7528\u7684 putchar \u548c getchar \u662f\u6765\u81ea Legacy Extensions\uff1a</p> <ul> <li>Nothing is returned in a1 register.</li> <li>All registers except a0 must be preserved across an SBI call by the callee.</li> <li>The value returned in a0 register is SBI legacy extension specific.</li> </ul> <p>\u6309\u7167 RISC-V \u7684 Calling Convention\uff0c\u53c2\u6570\u662f\u901a\u8fc7 a \u7cfb\u5217\u5bc4\u5b58\u5668\u4f20\u9012\uff0c\u4ece a0 \u5f00\u59cb\u3002</p> <p>\u5728 <code>sbi_call_legacy</code> \u51fd\u6570\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u58f0\u660e\u4e864\u4e2a\u53d8\u91cf\uff0c\u5e76\u4e14\u6ce8\u660e\u4ed6\u4eec\u5e94\u8be5\u76f4\u63a5\u88ab\u5206\u914d\u5230\u76f8\u5e94\u7684\u5bc4\u5b58\u5668\u4e0a (<code>register</code>, <code>asm(\"a0\")</code>)\u3002</p> <p>\u968f\u540e\uff0c\u6211\u4eec\u5c06 a7 \u8d4b\u503c\u4e3a\u6211\u4eec\u8981\u8c03\u7528\u54ea\u4e2a SBI \u51fd\u6570\uff0c\u4e09\u4e2a\u53c2\u6570\u5206\u522b\u8d4b\u503c\u7ed9 a0, a1 \u548c a2\u3002</p> <p>\u7136\u540e\uff0c\u6211\u4eec\u4f7f\u7528 asm volatile \u8fdb\u884c ecall \u8c03\u7528\u3002</p> <p>\u6700\u540e\uff0c\u8fd4\u56de a0 \u5bc4\u5b58\u5668\u7684\u503c\u3002</p> <pre><code>const uint64 SBI_CONSOLE_PUTCHAR = 1;\nconst uint64 SBI_CONSOLE_GETCHAR = 2;\n\nstatic int inline sbi_call_legacy(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2)\n{\n    register uint64 a0 asm(\"a0\") = arg0;\n    register uint64 a1 asm(\"a1\") = arg1;\n    register uint64 a2 asm(\"a2\") = arg2;\n    register uint64 a7 asm(\"a7\") = which;\n    asm volatile(\"ecall\" : \"=r\"(a0) : \"r\"(a0), \"r\"(a1), \"r\"(a2), \"r\"(a7) : \"memory\");\n    return a0;\n}\n\nvoid console_putchar(int c) {\n    sbi_call_legacy(SBI_CONSOLE_PUTCHAR, c, 0, 0);\n}\n</code></pre> <p><code>asm volatile</code> \u8868\u793a\u5728 C \u4ee3\u7801\u4e2d\u76f4\u63a5\u63d2\u5165\u6c47\u7f16\u4ee3\u7801\uff08\u5185\u8054\u6c47\u7f16\uff09\uff0c\u5b83\u5206\u4e3a\u56db\u90e8\u5206\uff1a</p> <pre><code>asm asm-qualifiers ( AssemblerTemplate \n                 : OutputOperands \n                 [ : InputOperands\n                 [ : Clobbers ] ])\n</code></pre> <p>\u6211\u4eec\u4f7f\u7528 <code>volatile</code> \u4f5c\u4e3a asm-qualifiers \u8868\u793a\u7981\u6b62\u7f16\u8bd1\u5668\u5bf9\u8fd9\u4e00\u6bb5\u4ee3\u7801\u8fdb\u884c\u53ef\u80fd\u7684\u4f18\u5316\u3002</p> <p>AssemblerTemplate \u8868\u793a\u6c47\u7f16\u7684\u6a21\u677f\uff0cOutputOperands \u8868\u793a\u54ea\u4e9b C \u53d8\u91cf\u5e94\u8be5\u88ab\u662f\u4e3a\u8fd9\u4e00\u6bb5\u6c47\u7f16\u7684\u8f93\u51fa\uff0cInputOperands \u8868\u793a\u54ea\u4e9b C \u53d8\u91cf\u5e94\u8be5\u88ab\u89c6\u4e3a\u8fd9\u4e00\u6bb5\u6c47\u7f16\u7684\u8f93\u5165\uff0cClobbers \u8868\u793a\u54ea\u4e00\u4e9b\u5bc4\u5b58\u5668\u6216\u7cfb\u7edf\u72b6\u6001\u4f1a\u88ab\u8fd9\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801\u4fee\u6539\u3002</p> <p>See also: https://gcc.gnu.org/onlinedocs/gcc-12.1.0/gcc/Extended-Asm.html</p> <p>Lab \u5b9e\u9a8c\u62a5\u544a 4</p> <p>\u5c1d\u8bd5\u8c03\u7528\u65b0\u7248\u672c SBI \u7684 <code>sbi_get_spec_version()</code> \u65b9\u6cd5\u3002</p> <p>\u5728 <code>main.c</code> \u4e2d\uff0c\u5728 <code>while(1);</code> \u6b7b\u5faa\u73af\u524d\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>struct sbiret ret = sbi_call(?, ?, 0, 0, 0);\nprintf(\"sbicall: err: %d, ret: %p\\n\", ret.error, ret.value);\n</code></pre> <p>\u53c2\u7167 SBI \u624b\u518c riscv-sbi.pdf\uff0c\u586b\u5165 ? \u5e94\u8be5\u7684\u503c\u3002<code>make run</code> \u7f16\u8bd1\u5e76\u8fd0\u884c\uff0c\u89e3\u91ca\u8f93\u51fa\u7684\u503c\u3002</p>"},{"location":"lab/xv6lab-contextswitch/","title":"Context Switch","text":""},{"location":"lab/xv6lab-contextswitch/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u4e86\u89e3\u8fdb\u7a0b\u7ba1\u7406</li> <li>\u4e86\u89e3\u4e0a\u4e0b\u6587\u5207\u6362</li> <li>\u638c\u63e1XV6\u8fdb\u884c\u591a\u6838\u8fdb\u7a0b\u5207\u6362\u7684\u6d41\u7a0b</li> </ol> <p>xv6-lab3 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab3</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab3 xv6lab3</code> \u4e0b\u8f7d xv6-lab3 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make runsmp</code> \u4f7f\u7528\u591a\u6838\u5fc3\uff084\u4e2a\uff09 \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u4f60\u5e94\u8be5\u4f1a\u770b\u5230\uff1a</p> <pre><code>Boot another cpus.\n...\nSystem has 4 cpus online\n...\nkthread: all threads exited, count 6288388\n[INFO  1,1] init: kthread: init ends!\n[PANIC 1,1] os/proc.c:225: init process exited\n[PANIC 0,-1] os/trap.c:41: other CPU has panicked\n[PANIC 2,-1] os/trap.c:41: other CPU has panicked\n[PANIC 3,-1] os/trap.c:41: other CPU has panicked\n</code></pre> <p>\u4e0a\u4e0b\u6587\u5207\u6362 (Context Switch) \u662f\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u6982\u5ff5\uff0c\u672c\u7ae0\u6211\u4eec\u5c06\u96c6\u4e2d\u4e8e Context Switch \u5728\u6280\u672f\u4e0a\u7684\u5b9e\u73b0\uff0c\u548c xv6 \u4e2d\u8c03\u5ea6\u5668 (scheduler) \u7684\u8bbe\u8ba1\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#_2","title":"\u5b9e\u9a8c\u573a\u666f","text":"<p>\u672c\u6b21\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u5728\u62e5\u67094\u4e2a\u6838\u7684 riscv CPU \u4e0a\u8fd0\u884c\u6211\u4eec\u7684XV6\u64cd\u4f5c\u7cfb\u7edf\u3002</p> <p>\u5f53\u64cd\u4f5c\u7cfb\u7edf\u542f\u52a8\u540e\uff0c\u6211\u4eec\u4f1a\u521b\u5efa\u5e76\u8fd0\u884c <code>init</code> \u8fdb\u7a0b\u3002<code>init</code>\u8fdb\u7a0b\u4f1a\u521b\u5efa8\u4e2a\u5185\u6838\u7ebf\u7a0b <code>worker</code> \u653e\u5165\u8c03\u5ea6\u961f\u5217\u3002\u63a5\u7740\uff0c\u56db\u4e2a\u6838\u4f1a\u8f6e\u6d41\u8fd0\u884c\u8fd98\u4e2a <code>worker</code> \u76f4\u5230exit\u3002\u800c\u7236\u8fdb\u7a0b <code>init</code> \u4f1a\u5728 wait \u5b8c8\u4e2a\u5b50\u8fdb\u7a0b\u540e\u8fd0\u884c\u7ed3\u675f\u3002</p> <p>\u672c\u6b21\u7684\u5b9e\u9a8c\u573a\u666f\u5c31\u662f\u5bf9\u4e8e\u4ee5\u4e0a9\u4e2a\u7ebf\u7a0b\u7684\u8c03\u5ea6\u548c\u5207\u6362\u8fc7\u7a0b\u3002\u4ee5\u4e0b\u662f <code>init</code> \u548c <code>worker</code> \u6267\u884c\u5185\u5bb9\u3002\u5728\u4e4b\u540e\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u4f1a\u9010\u6b65\u89e3\u91ca\u8fdb\u7a0b\u5207\u6362\u6240\u6d89\u53ca\u5230\u7684\u77e5\u8bc6\u70b9\u548c\u5177\u4f53\u6d41\u7a0b\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#init","title":"init()","text":"<p>code: nommu_init.c</p> <p><code>init</code> \u8fdb\u7a0b\u4f1a\u6267\u884c init \u65b9\u6cd5\uff0c\u5b83\u4f1a\u521b\u5efa 8 \u4e2a\u5185\u6838\u7ebf\u7a0b\uff0c\u5747\u6267\u884c <code>worker</code> \u65b9\u6cd5\u3002\u8fd9 8 \u4e2a\u5185\u6838\u7ebf\u7a0b\u4f1a\u5bf9\u5171\u4eab\u53d8\u91cf <code>count</code> \u8fdb\u884c\u7d2f\u52a0\uff0c\u5e76\u4e14\u6bcf\u7d2f\u52a0 1000 \u6b21\u8c03\u7528 <code>yield</code> \u4e00\u6b21\u3002</p> <p><code>init</code> \u65b9\u6cd5\u4f1a\u8c03\u7528 <code>wait</code> \u7b49\u5f85\u6240\u6709\u521b\u5efa\u7684\u5185\u6838\u7ebf\u7a0b\u9000\u51fa\uff0c\u5e76\u6700\u7ec8\u6253\u5370\u5171\u4eab\u53d8\u91cf <code>count</code> \u7684\u503c\u3002</p> <pre><code>#define NTHREAD 8\n\nvolatile uint64 count = 0;\n\nvoid worker(uint64 id) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        count++;\n        if (i % 1000 == 0) {\n            infof(\"thread %d: count %d, yielding\", id, count);\n            yield();\n        }\n    }\n    exit(id + 114514);\n}\n\nvoid init(uint64) {\n    infof(\"kthread: init starts!\");\n    int pids[NTHREAD];\n    for (int i = 0; i &lt; NTHREAD; i++) {\n        pids[i]        = create_kthread(worker, i);\n    }\n    int retcode;\n    for (int i = 0; i &lt; NTHREAD; i++) {\n        int pid = wait(pids[i], &amp;retcode);\n        infof(\"thread %d exited with code %d, expected %d\", pid, retcode, i + 114514);\n    }\n    printf(\"kthread: all threads exited, count %d\\n\", count);\n    infof(\"kthread: init ends!\");\n    exit(0);\n}\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#context","title":"\u4ec0\u4e48\u662f Context","text":"<p>\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0cContext (\u4e0a\u4e0b\u6587) \u662f\u6307\u5728\u67d0\u4e00\u65f6\u523b\u7a0b\u5e8f\u8fd0\u884c\u6240\u9700\u7684\u6240\u6709\u72b6\u6001\u4fe1\u606f\u7684\u96c6\u5408\u3002\u5728 xv6 \u7cfb\u7edf\u4e2d\uff0c\u6211\u4eec\u89c4\u5b9a\u6bcf\u4e2a Process \u662f\u4e00\u4e2a\u72ec\u7acb\u7684\u53ef\u88ab\u8c03\u5ea6\u7684\u5b9e\u4f53\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bcf\u4e2a Process \u62e5\u6709\u81ea\u5df1\u7684 Context\u3002</p> <p>\u7406\u89e3 Context \u7684\u91cd\u8981\u6027\u5728\u4e8e\uff1a\u5f53\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u5207\u6362\u6267\u884c\u4e0d\u540c\u7684\u8fdb\u7a0b\u65f6\uff0c\u5fc5\u987b\u4fdd\u5b58\u5f53\u524d\u8fdb\u7a0b\u7684 Context\uff0c\u5e76\u52a0\u8f7d\u8981\u5207\u6362\u5230\u7684\u8fdb\u7a0b\u7684 Context\u3002\u8fd9\u6837\u624d\u80fd\u786e\u4fdd\u8fdb\u7a0b\u5728\u4e0b\u6b21\u83b7\u5f97 CPU \u65f6\u80fd\u591f\u4ece\u4e4b\u524d\u7684\u72b6\u6001\u7ee7\u7eed\u6267\u884c\u3002\u8fd9\u4e2a\u4fdd\u5b58\u548c\u6062\u590d Context \u7684\u8fc7\u7a0b\u5c31\u662f Context Switch \u7684\u6838\u5fc3\u5185\u5bb9\u3002</p> <p>\u60f3\u8c61\u4e00\u4e0b\u4f60\u6b63\u5728\u8bfb\u4e00\u672c\u4e66\uff0c\u5f53\u4f60\u9700\u8981\u6682\u65f6\u53bb\u505a\u522b\u7684\u4e8b\u60c5\u65f6\uff0c\u4f60\u4f1a\u7528\u4e66\u7b7e\u6807\u8bb0\u5f53\u524d\u9605\u8bfb\u7684\u4f4d\u7f6e\u3002\u8fd9\u4e2a\u4e66\u7b7e\u5c31\u76f8\u5f53\u4e8e\u4fdd\u5b58\u4e86\u4f60\u7684\"\u9605\u8bfb\u4e0a\u4e0b\u6587\"\u3002\u5f53\u4f60\u56de\u6765\u7ee7\u7eed\u8bfb\u4e66\u65f6\uff0c\u901a\u8fc7\u4e66\u7b7e\u5c31\u80fd\u77e5\u9053\u4ece\u54ea\u91cc\u7ee7\u7eed\u8bfb\u8d77\u3002\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684 Context \u4f5c\u7528\u4e0e\u6b64\u7c7b\u4f3c\uff0c\u53ea\u662f\u9700\u8981\u4fdd\u5b58\u548c\u6062\u590d\u7684\u4fe1\u606f\u8981\u590d\u6742\u5f97\u591a\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#context-switch_1","title":"\u4e3a\u4ec0\u4e48\u8981 Context Switch","text":"<p>\u4ece\u8c03\u5ea6 (Scheduling) \u7684\u89d2\u5ea6\u6765\u770b\uff0cContext Switch \u662f\u5b9e\u73b0\u591a\u4efb\u52a1\u5904\u7406\u548c\u8d44\u6e90\u590d\u7528\u7684\u5173\u952e\u673a\u5236\uff1a</p> <ol> <li> <p>CPU \u8d44\u6e90\u7684\u65f6\u5206\u590d\u7528</p> <p>\u5f53\u7cfb\u7edf\u4e2d\u6709\u591a\u4e2a\u5c31\u7eea\u8fdb\u7a0b\u9700\u8981\u8fd0\u884c\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u8ba9\u5b83\u4eec\u8f6e\u6d41\u4f7f\u7528 CPU\u3002\u5373\u4f7f\u64cd\u4f5c\u7cfb\u7edf\u53ea\u6709\u5355\u4e2aCPU\uff0c\u901a\u8fc7\u65f6\u5206\u590d\u7528\u8f6e\u6d41\u8fd0\u884c\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u5b9e\u73b0\u6240\u6709\u8fdb\u7a0b\u597d\u50cf\u5728\u540c\u65f6\u8fd0\u884c\u7684\u6548\u679c\u3002\u8c03\u5ea6\u5668\u4f1a\u6839\u636e\u8c03\u5ea6\u7b56\u7565\uff08\u5982 Round Robin\u3001Priority Scheduling \u7b49\uff09\u51b3\u5b9a\u5728\u67d0\u4e2a\u65f6\u523b\u5e94\u8be5\u8fd0\u884c\u54ea\u4e2a\u8fdb\u7a0b\u3002\u4e3a\u4e86\u5207\u6362\u5230\u88ab\u8c03\u5ea6\u7684\u8fdb\u7a0b\uff0c\u5c31\u5fc5\u987b\u6267\u884c Context Switch\u3002</p> </li> <li> <p>\u63d0\u9ad8\u7cfb\u7edf\u541e\u5410\u91cf</p> <p>\u5f53\u4e00\u4e2a\u8fdb\u7a0b\u56e0\u4e3a I/O \u64cd\u4f5c\u800c\u963b\u585e\u65f6\uff0cCPU \u4f1a\u95f2\u7f6e\u3002\u901a\u8fc7 Context Switch\uff0c\u8c03\u5ea6\u5668\u53ef\u4ee5\u5207\u6362\u5230\u5176\u4ed6\u5c31\u7eea\u8fdb\u7a0b\uff0c\u8fd9\u6837 CPU \u5c31\u80fd\u5728\u7b49\u5f85 I/O \u7684\u540c\u65f6\u7ee7\u7eed\u6267\u884c\u5176\u4ed6\u4efb\u52a1\uff0c\u6700\u7ec8\u63d0\u9ad8\u4e86\u6574\u4e2a\u7cfb\u7edf\u7684\u8d44\u6e90\u5229\u7528\u7387\u548c\u541e\u5410\u91cf\u3002</p> </li> <li> <p>\u54cd\u5e94\u4ea4\u4e92\u5f0f\u4efb\u52a1</p> <p>\u7528\u6237\u4ea4\u4e92\u7a0b\u5e8f\u9700\u8981\u53ca\u65f6\u54cd\u5e94\u3002\u901a\u8fc7 Context Switch\uff0c\u8c03\u5ea6\u5668\u53ef\u4ee5\u6682\u505c\u5f53\u524d\u8fd0\u884c\u7684\u6279\u5904\u7406\u4efb\u52a1\uff0c\u8fc5\u901f\u5207\u6362\u5230\u9700\u8981\u7acb\u5373\u54cd\u5e94\u7684\u4ea4\u4e92\u5f0f\u4efb\u52a1\uff0c\u5b9e\u73b0\u66f4\u597d\u7684\u7528\u6237\u4f53\u9a8c\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-contextswitch/#context-switch_2","title":"\u4ec0\u4e48\u65f6\u5019\u8fdb\u884c Context Switch","text":"<p>\u901a\u5e38 Context Switch \u53d1\u751f\u5728\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5\uff1a</p> <ol> <li> <p>\u65f6\u95f4\u7247\u5230\u671f\u65f6\uff08Time Slice Expiration\uff09</p> <p>\u5728\u91c7\u7528\u65f6\u95f4\u7247\u8f6e\u8f6c\u8c03\u5ea6\u7b97\u6cd5\u65f6\uff0c\u5f53\u8fdb\u7a0b\u7528\u5b8c\u5206\u914d\u7684\u65f6\u95f4\u7247\uff0c\u7cfb\u7edf\u7684\u65f6\u949f\u4e2d\u65ad\u89e6\u53d1\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5f3a\u5236\u8fdb\u884c Context Switch\uff0c\u5207\u6362\u5230\u5176\u4ed6\u5c31\u7eea\u8fdb\u7a0b\u3002</p> </li> <li> <p>\u8fdb\u7a0b\u8fdb\u5165\u963b\u585e\u72b6\u6001\u65f6\uff08Process Blocking\uff09</p> <p>\u8fdb\u7a0b\u53d1\u8d77\u7cfb\u7edf\u8c03\u7528\u7b49\u5f85 I/O \u64cd\u4f5c\uff0c\u8fdb\u7a0b\u7b49\u5f85\u67d0\u4e2a\u4e8b\u4ef6\uff08\u5982\u4fe1\u53f7\u91cf\uff09\uff0c\u8fdb\u7a0b\u7533\u8bf7\u8d44\u6e90\u4f46\u65e0\u6cd5\u7acb\u5373\u83b7\u5f97\u3002</p> <p>\u6b64\u65f6\u8fdb\u7a0b\u4e3b\u52a8\u653e\u5f03 CPU\uff0c\u8c03\u5ea6\u5668\u9009\u62e9\u5176\u4ed6\u5c31\u7eea\u8fdb\u7a0b\u8fd0\u884c\u3002</p> </li> <li> <p>\u8fdb\u7a0b\u4e3b\u52a8\u8ba9\u51fa CPU \u65f6\uff08Voluntary Yield\uff09</p> <p>\u8fdb\u7a0b\u8c03\u7528 <code>yield</code> \u7cfb\u7edf\u8c03\u7528\uff0c\u4e3b\u52a8\u653e\u5f03\u5269\u4f59\u7684\u65f6\u95f4\u7247\uff0c\u901a\u5e38\u7528\u4e8e\u8fdb\u7a0b\u611f\u77e5\u5230\u81ea\u5df1\u77ed\u671f\u5185\u65e0\u4e8b\u53ef\u505a\u65f6\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-contextswitch/#xv6-process","title":"xv6 Process","text":"<p>Process, Thread \u548c Kernel Thread</p> <p>\u4ec0\u4e48\u662f\u8fdb\u7a0b (Process)\uff1a\u8fdb\u7a0b\u662f\u7a0b\u5e8f\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\u3001\u5185\u5b58\u3001\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49\u8d44\u6e90\u3002 \u800c\u7ebf\u7a0b (Thread) \u662f\u8fdb\u7a0b\u5185\u7684\u6267\u884c\u5355\u5143\uff0c\u662f CPU \u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\uff0c\u7ebf\u7a0b\u6709\u81ea\u5df1\u7684\u6808\u7a7a\u95f4\u548c\u5bc4\u5b58\u5668\u72b6\u6001\uff0c\u540c\u4e00\u8fdb\u7a0b\u7684\u7ebf\u7a0b\u5171\u4eab\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u548c\u5927\u90e8\u5206\u8d44\u6e90\u3002\u901a\u5e38\u6765\u8bf4\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u5185\u53ef\u4ee5\u6709\u591a\u4e2a\u7ebf\u7a0b\u3002</p> <p>\u5728\u6211\u4eec\u7684\u5b9e\u9a8c\u8bfe\u4e0a\uff0c\u6211\u4eec\u4f7f\u7528\u7684 xv6 \u4e3a\u4e86\u7b80\u5316\u5b9e\u73b0\uff0c\u505a\u51fa\u4e86\u5982\u4e0b\u89c4\u5b9a\uff1a</p> <ol> <li>\u6bcf\u4e2a\u8fdb\u7a0b\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u3002\u6240\u4ee5\uff0c\u5728 xv6 \u4e2d\uff0c\u8fdb\u7a0b\u5373\u662f CPU \u8c03\u5ea6\u7684\u57fa\u672c\u5355\u4f4d\u3002</li> <li>\u6bcf\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\u62e5\u6709\u4e24\u4e2a\u6267\u884c\u73af\u5883\uff1a\u5904\u4e8e\u7528\u6237\u6a21\u5f0f\uff08U mode\uff09\u7684\u7528\u6237\u73af\u5883\uff0c\u548c\u5904\u4e8e\u5185\u6838\uff08S mode\uff09\u7684\u5185\u6838\u73af\u5883\uff0c\u6211\u4eec\u5c06\u540e\u8005\u79f0\u4e3a\u5185\u6838\u7ebf\u7a0b\uff08Kernel Thread\uff09\u3002</li> </ol> <p>\u5728\u672c\u6b21 Lab \u4e2d\uff0c\u6211\u4eec\u8fd8\u5c1a\u672a\u8fdb\u5165\u7528\u6237\u6a21\u5f0f\uff0c\u6240\u4ee5\u6bcf\u4e2a\u8fdb\u7a0b\u4ec5\u6709\u5185\u6838\u7ebf\u7a0b\u3002\u6211\u4eec\u4f1a\u5728\u51e0\u5468\u540e\u7684\u5b9e\u9a8c\u8bfe\u4ecb\u7ecd\u7528\u6237\u7a7a\u95f4\u3002</p> <p>\u76f8\u5173\u4ee3\u7801\uff1a<code>os/proc.h</code>, <code>os/sched.c</code>, <code>os/smp.c</code></p> <p>\u5728 xv6 \u4e2d\uff0cProcess Control Block (PCB) \u88ab\u5b9a\u4e49\u5982\u4e0b\uff1a</p> <pre><code>enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\nstruct proc {\n    spinlock_t lock;\n    // p-&gt;lock must be held when accessing to these fields:\n    enum procstate state;  // Process state\n    int pid;               // Process ID\n    uint64 exit_code;\n    void *sleep_chan;\n    int killed;\n    struct proc *parent;    // Parent process\n    uint64 __kva kstack;    // Virtual address of kernel stack\n    struct context context; // swtch() here to run process\n\n    // Userspace: User Memory Management, not covered in today's lab\n    struct mm *mm;\n    struct vma *vma_brk;\n    struct trapframe *__kva trapframe;  // data page for trampoline.S\n};\n</code></pre> <p>\u6bcf\u4e2a Process \u6709\u81ea\u5df1\u7684 pid, \u8fdb\u7a0b\u72b6\u6001\u3001parent \u6307\u9488\u3001\u5185\u6838\u6808\u3001\u548c\u5185\u6838 Context\u3002</p> <p>\u5bf9\u4e8e\u6709\u7528\u6237\u6001\uff08\u672c\u6b21\u5b9e\u9a8c\u4ee3\u7801\u4e2d\u8fd8\u6ca1\u6709\uff09\u7684 Process\uff0cPCB \u4e2d\u8fd8\u6709\u8d1f\u8d23\u7ba1\u7406\u5185\u5b58\u7684 <code>struct mm</code>\uff0c\u548c\u4fdd\u5b58\u7528\u6237\u6a21\u5f0f\u4e0b Trap \u89e6\u53d1\u65f6\u6570\u636e\u7684 Trapframe\u3002</p> <p>\u9664\u6b64\u4e4b\u5916\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u4e00\u4e2a\u81ea\u65cb\u9501 <code>spinlock_t</code>\uff0c\u5c3d\u7ba1\u6211\u4eec\u76ee\u524d\u7406\u8bba\u8bfe\u8fd8\u6ca1\u6709\u63a5\u89e6\u5230\u9501\u548c\u5e76\u53d1\u7684\u76f8\u5173\u77e5\u8bc6\uff0c\u4f46\u662f\u6211\u4eec\u5728 xv6 \u4e2d\u89c4\u5b9a\uff1a\u8bbf\u95ee <code>struct proc</code> \u7684\u6240\u6709\u6210\u5458\u65f6\uff0c\u90fd\u9700\u8981\u5728\u6301\u6709 <code>p-&gt;lock</code> \u7684\u60c5\u51b5\u4e0b\u8fdb\u884c\u3002</p> <p>\u5077\u8dd1\uff1a\u4ec0\u4e48\u662f\u9501</p> <p>\u9501 (lock) \u662f\u4e00\u79cd\u63a7\u5236\u5e76\u53d1\u8bbf\u95ee\u7684\u57fa\u672c\u5de5\u5177\u3002</p> <p>\u6211\u4eec\u89c4\u5b9a\uff1a\u5728\u6211\u4eec\u6301\u6709 (holding) \u4e00\u628a\u81ea\u65cb\u9501\u65f6\uff1a1. \u8be5 CPU \u4e0d\u80fd\u88ab\u4e2d\u65ad\uff0c2. \u5176\u4ed6 CPU \u4e0d\u80fd\u540c\u65f6\u6301\u6709\u8fd9\u4e00\u628a\u9501\u3002</p> <p>\u6211\u4eec\u4f7f\u7528 <code>acquire</code> \u548c <code>release</code> \u539f\u8bed\u8868\u793a \u4e0a\u9501 \u548c \u89e3\u9501 \u7684\u52a8\u4f5c\u3002</p> <p>\u5982\u679c\u5728 <code>acquire</code> \u65f6\u62a2\u4e0d\u5230\u9501\uff0c\u90a3\u4e48\u8be5 CPU \u4f1a\u8fdb\u884c\u539f\u5730\u7a7a\u8f6c\u76f4\u5230\u62a2\u5230\u9501\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#struct-cpu","title":"<code>struct cpu</code>","text":"<p>\u5728 xv6 \u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 <code>struct cpu</code> \u63cf\u8ff0\u6bcf\u4e2a CPU \u7684\u72b6\u6001\uff0c\u5e76\u4e14\u53ef\u4ee5\u4f7f\u7528 <code>mycpu()</code> \u65b9\u6cd5\u83b7\u53d6\u5f53\u524d <code>cpu</code> \u5bf9\u8c61\u3002</p> <pre><code>struct cpu {\n    int mhart_id;                  // mhartid for this cpu, passed by OpenSBI\n    struct proc *proc;             // current process\n    struct context sched_context;  // scheduler context, swtch() here to run scheduler\n    int inkernel_trap;             // whether we are in a kernel trap context\n    int noff;                      // how many push-off\n    int interrupt_on;              // Is the interrupt Enabled before the first push-off?\n    uint64 sched_kstack_top;       // top of per-cpu sheduler kernel stack\n    int cpuid;                     // for debug purpose\n};\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#process","title":"Process \u521d\u59cb\u5316","text":"<p>\u4e3a\u4e86\u7b80\u5316\u5b9e\u73b0\uff0cxv6 \u9650\u5236\u4e86\u7cfb\u7edf\u4e2d\u8fdb\u7a0b\u6570\u91cf\u7684\u6700\u5927\u503c\u4e3a\u4e00\u4e2a\u56fa\u5b9a\u503c 512\uff0c\u5e76\u4f7f\u7528\u4e00\u4e2a\u6307\u9488\u6570\u7ec4\u6765\u7d22\u5f15\u6240\u6709\u8fdb\u7a0b\u3002</p> <p>\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\uff0cxv6 \u4f1a\u6267\u884c <code>proc_init</code> \u51fd\u6570\u6765\u521d\u59cb\u5316\u6240\u6709\u8fdb\u7a0b\u8d44\u6e90\uff0c\u5b83\u4f1a\u5148\u521d\u59cb\u5316 Process \u6a21\u5757\u6240\u9700\u8981\u7684\u81ea\u65cb\u9501\uff0c\u4ee5\u53ca <code>struct proc</code> \u7684\u5206\u914d\u6c60 <code>proc_allocator</code>\u3002\u968f\u540e\uff0c\u5b83\u4f1a\u521d\u59cb\u5316 512 \u4e2a\u8fdb\u7a0b\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u4ece <code>proc_allocator</code> \u5206\u914d PCB \u7ed3\u6784\u4f53 <code>struct proc*</code>\uff0c\u8fdb\u884c memset \u521d\u59cb\u5316\uff0c\u4ee5\u53ca\u5206\u914d\u4e00\u4e2a\u5185\u6838\u6808 <code>kstack</code>\u3002</p> <p>kalloc</p> <p><code>kalloc.c</code> \u6a21\u5757\u4e3b\u8981\u5b8c\u6210\u4ee5\u4e0b\u4e8b\u60c5\uff1a</p> <ol> <li>\u5206\u914d\u3001\u91ca\u653e\u4e00\u4e2a 4KiB \u9875\u9762\uff1a<code>kallocpage</code>\uff0c<code>kfreepage</code>\u3002</li> <li>\u5206\u914d\u3001\u91ca\u653e\u4e00\u4e2a\u56fa\u5b9a\u5927\u5c0f\u7684\u5bf9\u8c61\uff1a<code>allocator_init</code>, <code>kalloc</code>, <code>kfree</code>\u3002</li> </ol> <pre><code>struct proc *pool[NPROC];\n\n// initialize the proc table at boot time.\nvoid proc_init() {\n    // we only init once.\n    static int proc_inited = 0;\n    assert(proc_inited == 0);\n    proc_inited = 1;\n\n    spinlock_init(&amp;pid_lock, \"pid\");\n    spinlock_init(&amp;wait_lock, \"wait\");\n    allocator_init(&amp;proc_allocator, \"proc\", sizeof(struct proc), NPROC);\n\n    struct proc *p;\n    for (int i = 0; i &lt; NPROC; i++) {\n        p = kalloc(&amp;proc_allocator);\n        memset(p, 0, sizeof(*p));\n        spinlock_init(&amp;p-&gt;lock, \"proc\");\n        p-&gt;index = i;\n        p-&gt;state = UNUSED;\n\n        p-&gt;kstack = (uint64)kallocpage();\n        assert(p-&gt;kstack);\n\n        pool[i] = p;\n    }\n    sched_init();\n}\n</code></pre> <p>\u5728\u6211\u4eec\u9700\u8981\u4e00\u4e2a PCB \u65f6\uff0c<code>allocproc</code> \u4f1a\u5728 <code>pool</code> \u4e2d\u5bfb\u627e\u4e00\u4e2a\u672a\u88ab\u5206\u914d\u7684\u8fdb\u7a0b\uff0c\u8fdb\u884c\u6700\u7ec8\u7684\u521d\u59cb\u5316\u5e76\u8fd4\u56de\u3002\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u8bb2\u89e3 xv6 \u662f\u5982\u4f55\u521d\u59cb\u5316\u8fdb\u7a0b\u7684 Context\u3002</p> <pre><code>// Look in the process table for an UNUSED proc.\n// If found, initialize state required to run in the kernel.\n// If there are no free procs, or a memory allocation fails, return 0.\nstruct proc *allocproc() {\n    struct proc *p;\n    // find an UNUSED proc\n    for (int i = 0; i &lt; NPROC; i++) {\n        p = pool[i];\n        acquire(&amp;p-&gt;lock);\n        if (p-&gt;state == UNUSED) {\n            goto found;\n        }\n        release(&amp;p-&gt;lock);\n    }\n    return 0;\n\nfound:\n    // initialize a proc\n    tracef(\"init proc %p\", p);\n    p-&gt;pid        = allocpid();\n    p-&gt;state      = USED;\n    p-&gt;killed     = 0;\n    p-&gt;sleep_chan = NULL;\n    p-&gt;parent     = NULL;\n    p-&gt;exit_code  = 0;\n\n    memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));\n    memset((void *)p-&gt;kstack, 0, PGSIZE);\n\n    if (!init_proc)\n        init_proc = p;\n\n    assert(holding(&amp;p-&gt;lock));\n\n    return p;\n}\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#xv6-context-switch","title":"xv6 Context Switch","text":"<p>\u5bf9\u4e8e\u4e00\u4e2a\u7a0b\u5e8f\u800c\u8a00\uff0c\u5b83\u6240\u80fd\u770b\u5230\u548c\u4fee\u6539\u6240\u6709\u72b6\u6001\uff0c\u5373\u5b83\u7684\u6240\u6709\u5bc4\u5b58\u5668\u548c\u5185\u5b58\u7a7a\u95f4\u3002\u56e0\u4e3a\u5728\u5185\u6838\u7a7a\u95f4\u4e0b\uff0c\u6240\u6709\u5185\u6838\u7ebf\u7a0b\u6240\u770b\u5230\u7684\u5185\u5b58\u7a7a\u95f4\u662f\u540c\u4e00\u4e2a\uff08\u800c\u5bf9\u4e8e\u7528\u6237\u8fdb\u7a0b\u800c\u8a00\uff0c\u4e0d\u540c\u7684\u7a0b\u5e8f\u6709\u4e0d\u540c\u7684\u5185\u5b58\u7a7a\u95f4\uff09\u3002\u6240\u4ee5\uff0c\u5bf9\u4e8e\u5185\u6838\u8fdb\u7a0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u5b58\u5b83\u7684\u5bc4\u5b58\u5668\u72b6\u6001\u5373\u53ef\u3002\u56e0\u6b64\uff0c\u5728 xv6 \u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u8fdb\u7a0b\u7684 \u5185\u6838 Context \u4e3a\u5982\u4e0b\u7ed3\u6784\u3002</p> <pre><code>// Saved registers for kernel context switches.\nstruct context {\n    uint64 ra;\n    uint64 sp;\n\n    // callee-saved\n    uint64 s0;\n    uint64 s1;\n    uint64 s2;\n    uint64 s3;\n    uint64 s4;\n    uint64 s5;\n    uint64 s6;\n    uint64 s7;\n    uint64 s8;\n    uint64 s9;\n    uint64 s10;\n    uint64 s11;\n};\n</code></pre> <p>\u5728 <code>switch.S</code> \u6587\u4ef6\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\"\u51fd\u6570\" <code>swtch</code>\uff0c\u8be5\u51fd\u6570\u7684\u539f\u578b\u4e3a <code>void swtch(struct context *old, struct context *new)</code>\u3002</p> <pre><code># Context switch\n#   void swtch(struct context *old, struct context *new);\n# Save current registers in old. Load from new.\n\n.globl swtch\nswtch:\n    sd ra, 0(a0)\n    sd sp, 8(a0)\n    sd s0, 16(a0)\n    sd s1, 24(a0)\n    sd s2, 32(a0)\n    sd s3, 40(a0)\n    sd s4, 48(a0)\n    sd s5, 56(a0)\n    sd s6, 64(a0)\n    sd s7, 72(a0)\n    sd s8, 80(a0)\n    sd s9, 88(a0)\n    sd s10, 96(a0)\n    sd s11, 104(a0)\n\n    ld ra, 0(a1)\n    ld sp, 8(a1)\n    ld s0, 16(a1)\n    ld s1, 24(a1)\n    ld s2, 32(a1)\n    ld s3, 40(a1)\n    ld s4, 48(a1)\n    ld s5, 56(a1)\n    ld s6, 64(a1)\n    ld s7, 72(a1)\n    ld s8, 80(a1)\n    ld s9, 88(a1)\n    ld s10, 96(a1)\n    ld s11, 104(a1)\n\n    ret\n</code></pre> <p>\u5f53\u6211\u4eec\u9700\u8981\u8fdb\u884c\u4e0a\u4e0b\u6587\u5207\u6362\u65f6\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528 <code>swtch</code> \u51fd\u6570\uff0c\u5e76\u7ed9\u51fa\u4e24\u4e2a <code>struct context*</code> \u6307\u9488\uff0c\u5206\u522b\u8868\u793a\uff0c\u5f53\u524d\u7684 Context \u5e94\u8be5\u88ab\u4fdd\u5b58\u5230\u54ea\u91cc (old)\uff0c\u548c\u4e4b\u540e\u5e94\u8be5\u4ece\u54ea\u91cc\u7ee7\u7eed\u6267\u884c (new)\u3002</p> <p>\u7531\u4e8e\u6211\u4eec\u662f C \u8bed\u8a00\u4e2d\u5c1d\u8bd5\u53bb\u8c03\u7528\u4e00\u4e2a\u51fd\u6570 (<code>swtch</code>)\uff0c\u7f16\u8bd1\u5668\u4f1a\u6309\u7167 RISC-V \u7684 Calling Convention \u6784\u9020\u73af\u5883\uff0c\u4f8b\u5982\u8fd4\u56de\u5730\u5740\u4f1a\u88ab\u5199\u5165\u5728 <code>ra</code> \u5bc4\u5b58\u5668\u4e2d\uff0c\u6709\u4e00\u4e9b\u5bc4\u5b58\u5668\u4f1a\u88ab\u4fdd\u5b58\u5728\u6808\u4e0a\u3002</p> <p>\u6839\u636e RISC-V \u7684 Calling Convention\uff0c\u5bc4\u5b58\u5668\u5206\u4e3a\u4e24\u79cd\uff1aCaller-saved \u548c Callee-saved\u3002\u5bf9\u4e8e Caller-saved register\uff0c\u5982\u679c\u8c03\u7528\u8005\u60f3\u4fdd\u8bc1\u5b83\u4eec\u5728\u51fd\u6570\u8c03\u7528\u524d\u540e\u4e0d\u53d8\uff0c\u90a3\u4e48\u8c03\u7528\u8005\u9700\u8981\u81ea\u5df1\u8fdb\u884c\u4fdd\u5b58\uff0c\u88ab\u8c03\u7528\u8005\u5141\u8bb8\u968f\u610f\u4fee\u6539\u8fd9\u4e9b\u5bc4\u5b58\u5668\uff1b\u5bf9\u4e8e Callee-saved register\uff0c\u8c03\u7528\u8005\u53ef\u4ee5\u5047\u8bbe\u5b83\u4eec\u5728\u51fd\u6570\u8c03\u7528\u524d\u540e\u4e0d\u53d8\uff0c\u5982\u679c\u88ab\u8c03\u7528\u8005\u60f3\u8981\u4f7f\u7528\u8fd9\u4e9b\u5bc4\u5b58\u5668\uff0c\u90a3\u4e48\u88ab\u8c03\u7528\u8005\u9700\u8981\u81ea\u5df1\u8fdb\u884c\u4fdd\u5b58\u5e76\u6062\u590d\u3002\u5e76\u4e14\uff0c\u5bc4\u5b58\u5668\u662f\u5728\u6808\u5e27 (Stack Frame) \u4e0a\u4fdd\u5b58\u7684 (\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u8fdb\u884c\u7684)\u3002</p> <p>\u6240\u4ee5\uff0c<code>swtch</code> \u51fd\u6570\u53ea\u9700\u8981\u4fdd\u5b58 <code>sp</code>, <code>ra</code> \u548c\u6240\u6709\u5176\u4ed6\u7684 Callee-saved Register \u5230 <code>old</code> \u7ed3\u6784\u4f53\u4e2d\uff0c\u5c31\u53ef\u4ee5\u8bb0\u4f4f\u539f\u6765\u8c03\u7528\u8005\u7684\u7a0b\u5e8f\u6267\u884c\u72b6\u6001\u3002\u76f8\u53cd\u7684\uff0c\u4ece <code>new</code> \u4e2d\u6062\u590d\u53ea\u9700\u8981\u8bbe\u7f6e\u8fd9\u4e9b\u5bc4\u5b58\u5668\u5373\u53ef\u3002</p> <p></p> <p>\u4e0b\u56fe\u5c55\u793a\u4e86 P1 \u5207\u6362\u5230 P2 \u7684\u8fc7\u7a0b\uff0cP1 \u548c P2 \u6709\u5404\u81ea\u7684 Stack\uff0c\u6709\u5404\u81ea\u7684 Context \u7ed3\u6784\u4f53\u3002</p> <p></p> <p>P1 \u5728\u6267\u884c <code>P1</code> \u51fd\u6570\u65f6\uff0c\u4f1a\u5728\u51fd\u6570\u5f00\u5934 (prologue) \u4fdd\u5b58 <code>P1</code> \u7684\u8c03\u7528\u8005\u7684\u8fd4\u56de\u5730\u5740\uff0c\u540c\u65f6\u5728\u6808\u4e0a\u5f00\u8f9f\u5c40\u90e8\u53d8\u91cf\u3002\u5728 P1 \u8c03\u7528 <code>swtch</code> \u524d\uff0c\u7f16\u8bd1\u5668\u5728\u5df2\u7ecf\u5c06\u6240\u6709 Caller-Saved Registers \u4fdd\u5b58\u5728\u6808\u4e0a\uff0c\u7136\u540e\u751f\u6210\u6c47\u7f16 <code>jal swtch</code>\uff0c\u8fd9\u4e00\u6761\u6c47\u7f16\u6267\u884c\u65f6\u4f1a\u5c06 ra \u8bbe\u7f6e\u4e3a <code>P1</code> \u51fd\u6570\u4e2d <code>jal</code> \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c\u5373\u6211\u4eec\u5e38\u8bf4\u7684 pc+4\u3002</p> <p>\u5728\u8c03\u7528 <code>swtch</code> \u65f6\uff0c<code>a0</code> \u6307\u5411\u4e86 P1 \u7684 <code>struct context</code> \u7ed3\u6784\u4f53\uff0c<code>swtch</code> \u4f7f\u7528 <code>sd</code> \u6307\u4ee4\u4fdd\u5b58 ra, sp \u548c s0 - s11 \u5bc4\u5b58\u5668\u3002</p> <p>\u4e4b\u540e\uff0c<code>swtch</code> \u4ece <code>a1</code> \u52a0\u8f7d\u5373\u5c06\u6062\u590d\u7684 P2 \u7684 Context\uff0c\u4f7f\u7528 <code>ld</code> \u6307\u4ee4\u4ece <code>struct context</code> \u7ed3\u6784\u4f53\u4e2d\u8bfb\u53d6\u5c5e\u4e8e P2 \u7684 ra, sp \u548c s0 - s11 \u5bc4\u5b58\u5668\u3002</p> <p>\u5728 CPU \u6267\u884c\u5230 <code>ret</code> \u65f6\uff0cpc \u88ab\u6062\u590d\u4e3a ra \u5bc4\u5b58\u5668\u7684\u503c\uff0c\u6b64\u65f6\u5f00\u59cb\u6267\u884c\u4e0a\u6b21 P2 \u8c03\u7528 <code>swtch</code> \u65f6\u4fdd\u5b58\u7684\u8fd4\u56de\u5730\u5740\u3002</p> <p>\u81f3\u6b64\uff0c\u6210\u529f\u5b8c\u6210\u4e86\u4ece P1 \u5230 P2 \u7684\u5207\u6362\u3002\uff08\u6ce8\uff1aP1 \u4e0e P2 \u4e0d\u4e00\u5b9a\u6307\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u4e24\u4e2a\u8fdb\u7a0b\uff0c\u800c\u662f\u4efb\u610f\u7684\u4e24\u4e2a\u7a0b\u5e8f\uff09</p> <p>\u6b64\u5916\uff0c<code>swtch</code> \u65b9\u6cd5\u662f\u5929\u751f\u6210\u5bf9\u7684\uff1a\u5982\u679c\u4e0a\u6b21\u4f7f\u7528 swtch \u79bb\u5f00\u4e86\u5f53\u524d\u8fdb\u7a0b\uff0c\u90a3\u4e48\u4e0b\u6b21\u8fd4\u56de\u65f6\uff0c\u5fc5\u5b9a\u662f\u6709\u5176\u4ed6\u8fdb\u7a0b\u8c03\u7528\u4e86 swtch \u56de\u5230\u4e86\u8be5\u8fdb\u7a0b\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#lab-1","title":"Lab \u7ec3\u4e60 1","text":"<p>\u8bf7\u4f60\u4ece\u6c47\u7f16\u5c42\u9762\u7406\u89e3 <code>swtch</code> \u51fd\u6570\u3002</p> <p>\u5047\u8bbe\u4f60\u6709\u5982\u4e0b\u4e24\u4e2a <code>struct context</code> \u7ed3\u6784\u4f53\uff0c\u79f0\u4e3a <code>ctx_a</code> \u548c <code>ctx_b</code>\uff1a</p> <pre><code>struct context ctx_a = {\n    .ra = 0x0,\n    .sp = 0x0,\n};\nstruct context ctx_b = {\n    .ra = 0x802dead0,\n    .sp = 0x7fffB000,\n};\n</code></pre> <p>\u5047\u8bbe\u4f60\u6b63\u5728\u6267\u884c <code>swtch(&amp;ctx_a, &amp;ctx_b)</code>\uff0c\u8fd9\u4e00\u884c\u65b9\u6cd5\u8c03\u7528\u6240\u5bf9\u5e94\u7684\u6c47\u7f16\u4ee3\u7801\u5373\u5468\u56f4\u7684\u6c47\u7f16\u4ee3\u7801\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>// a0: address of ctx_a, a1: address of ctx_b\n    80205720:   05848593            addi    a1,s1,88\n    80205724:   00002097            auipc   ra,0x2\n    80205728:   1b4080e7            jalr    436(ra) # 802078d8 &lt;swtch&gt;\n    8020572c:   008ab503            ld  a0,8(s5)\n    80205730:   24951263            bne a0,s1,80205974 &lt;scheduler+0x304&gt;\n</code></pre> <p><code>swtch</code> \u7b26\u53f7\u7684\u5730\u5740\u4e3a <code>802078d8</code>\uff0c\u5176\u6c47\u7f16\u4e3a\uff1a</p> <pre><code>swtch:\n    802078d8:   00153023            sd  ra,0(a0)\n    802078dc:   00253423            sd  sp,8(a0)\n    // store s0 - s11, ignored.\n\n    80207910:   0005b083            ld  ra,0(a1)\n    80207914:   0085b103            ld  sp,8(a1)\n    // restore s0 - s11, ignored.\n\n    80207948:   00008067            ret\n</code></pre> <p>\u6b64\u65f6\uff0cPC \u5bc4\u5b58\u5668\u6307\u5411 0x80205728\uff0c\u8bf7\u4f60\u5728\u8868\u683c\u4e2d\u586b\u5199\u63a5\u4e0b\u6765\u6bcf\u4e00\u6b65\u6307\u4ee4\u6240\u4fee\u6539\u7684\u5bc4\u5b58\u5668\u6216\u5185\u5b58\u72b6\u6001\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#xv6-scheduler","title":"xv6 scheduler","text":"<p>xv6 \u4e2d\uff0c\u6bcf\u4e2a CPU \u90fd\u6709\u4e00\u4e2a\u81ea\u5df1\u7684 scheduler\u3002<code>scheduler</code> \u65b9\u6cd5\u4ece\u4e0d\u8fd4\u56de\u3002\u5b83\u662f\u4e00\u4e2a <code>while(1)</code> \u6b7b\u5faa\u73af\uff0c\u6bcf\u6b21\u5faa\u73af\u65f6\uff0cscheduler \u90fd\u5c1d\u8bd5\u83b7\u53d6\u4e00\u4e2a task\uff0c\u5982\u679c\u80fd\u6267\u884c\u5b83\uff0c\u90a3\u5c31 swtch \u5230\u8be5\u8fdb\u7a0b\u6267\u884c\u3002</p> <p>\u5982\u679c\u83b7\u53d6\u4e0d\u5230\uff0c\u5219\u68c0\u67e5\u662f\u5426\u6240\u6709\u8fdb\u7a0b\u90fd\u9000\u51fa\u4e86\u3002\u5982\u679c\u662f\uff0c\u5219\u8868\u660e\u7cfb\u7edf\u5e94\u8be5\u7ed3\u675f\u8fd0\u884c\u4e86\uff1b\u5982\u679c\u4e0d\u662f\uff0c\u5219\u8868\u793a\u53ef\u80fd\u6709\u7684\u8fdb\u7a0b\u6b63\u5728\u7761\u7720\u4ee5\u7b49\u5f85\u8d44\u6e90\uff0c\u6216\u8005\u6b63\u5728\u7531\u5176\u4ed6 CPU \u6267\u884c\u3002\u6211\u4eec\u4f7f\u7528 <code>wfi</code> (Wait For Interrupt) \u6307\u4ee4\u7b49\u5f85\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\uff0c\u8fd9\u4e00\u6b65\u7b49\u4ef7\u4e8e\u7528 <code>while(1);</code> \u4f7f CPU \u7a7a\u8f6c\u4e00\u6bb5\u65f6\u95f4\u3002</p> <p>\u5982\u679c\u6211\u4eec\u6210\u529f\u83b7\u53d6\u5230\u4e86\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5219\u5bf9\u8be5\u8fdb\u7a0b\u4e0a\u9501 <code>acquire(&amp;p-&gt;lock)</code>\uff0c\u5c06\u5176\u72b6\u6001\u8bbe\u7f6e\u4e3a <code>RUNNING</code>\uff0c\u5c06\u5f53\u524d cpu \u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\u8bbe\u4e3a\u8be5\u8fdb\u7a0b (<code>c-&gt;proc = p</code>)\u3002</p> <p>mycpu \u548c curr_proc</p> <p>\u5bf9\u4e8e\u5355\u5904\u7406\u5668\u7cfb\u7edf\uff0c\u5355\u4e2a CPU \u4e0a\u540c\u65f6\u53ea\u80fd\u6709\u4e00\u4e2a\u8fdb\u7a0b\u5728\u8fd0\u884c\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf <code>struct proc* curr_proc</code> \u8868\u793a\u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b(Current Process)\u3002\u800c\u5bf9\u4e8e\u591a\u5904\u7406\u5668\u7cfb\u7edf\uff0c\u5bf9\u4e8e\u6bcf\u4e2a CPU \u90fd\u6709\u4e00\u4e2a <code>curr_proc</code>\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528 <code>struct cpu</code> \u7ed3\u6784\u4f53\u6765\u8868\u793a\u6bcf\u4e2a CPU \u7684\u4fe1\u606f\u3002\u6211\u4eec\u6709\u4e00\u4e2a\u5168\u5c40\u6570\u7ec4 <code>struct cpu cpus[4]</code> \u8868\u793a\u7cfb\u7edf\u4e0a\u7684 4 \u4e2a CPU\uff0c\u5e76\u4f7f\u7528\u5bc4\u5b58\u5668 <code>tp</code> \u6765\u8868\u793a\u5f53\u524d\u8fd0\u884c\u5728\u54ea\u4e2a CPU \u4e0a\uff0c\u5373 <code>cpuid()</code>\uff0c\u5b83\u76f4\u63a5\u8bfb\u53d6\u5e76\u8fd4\u56de <code>tp</code> \u5bc4\u5b58\u5668\u7684\u503c\u3002</p> <p>\u968f\u540e\uff0c\u4f7f\u7528 <code>swtch</code> \u65b9\u6cd5\u8df3\u8f6c\u5230\u8be5\u8fdb\u7a0b\u4fdd\u5b58\u7684 Context \u4e2d\uff0c\u5e76\u4fdd\u5b58\u5f53\u524d Context \u5230 cpu-&gt;sched_context \u4e2d\u3002</p> <p>\u5bf9\u4e8e scheduler\uff0c\u6211\u4eec\u505a\u51fa\u5982\u4e0b\u89c4\u5b9a\uff1a</p> <ol> <li>\u8fdb\u7a0b\u53ea\u80fd\u901a\u8fc7 scheduler \u6765\u8fdb\u884c\u5207\u6362\uff0c\u5373 A \u8fdb\u7a0b\u4f1a\u5148\u5207\u6362\u5230 <code>scheduler</code> \u518d\u5207\u6362\u5230 B \u8fdb\u7a0b\uff0c\u800c\u4e0d\u80fd\u76f4\u63a5 A \u8fdb\u7a0b\u5207\u6362\u5230 B \u8fdb\u7a0b\u3002</li> <li>\u5207\u6362\u5230\u67d0\u8fdb\u7a0b <code>p</code> \u65f6\uff0c\u79bb\u5f00 scheduler \u524d\uff0c\u5f53\u524d CPU \u4f1a\u6301\u6709 <code>p-&gt;lock</code> \u8fd9\u628a\u9501\u3002\u800c\u6301\u6709\u9501\u6697\u542b\u7740\u5f53\u524d CPU \u4e2d\u65ad\u4e3a\u5173\u95ed\u3002</li> <li>\u4ece\u8fdb\u7a0b <code>p</code> \u5207\u6362\u56de scheduler \u65f6\uff0c\u5f53\u524d CPU \u4f1a\u6301\u6709 <code>p-&gt;lock</code> \u8fd9\u4e00\u628a\u9501\u3002</li> </ol> <pre><code>// Scheduler never returns.  It loops, doing:\n//  - choose a process to run.\n//  - swtch to start running that process.\n//  - eventually that process transfers control\n//    via swtch back to the scheduler.\nvoid scheduler() {\n    struct proc *p;\n    struct cpu *c = mycpu();\n\n    // We only get here once.\n    // After each cpu boots, it calls scheduler().\n    // If this scheduler finds any possible process to run, it will switch to it.\n    //  And the scheduler context is saved on \"mycpu()-&gt;sched_context\"\n\n    for (;;) {\n        // intr may be on here.\n\n        p = fetch_task();\n        if (p == NULL) {\n            // if we cannot find a process in the task_queue\n            //  maybe some processes are SLEEPING and some are RUNNABLE\n            if (all_dead()) {\n                panic(\"[cpu %d] scheduler dead.\", c-&gt;cpuid);\n            } else {\n                // nothing to run; stop running on this core until an interrupt.\n                intr_on();\n                asm volatile(\"wfi\");\n                intr_off();\n                continue;\n            }\n        }\n\n        acquire(&amp;p-&gt;lock);\n        assert(p-&gt;state == RUNNABLE);\n        infof(\"switch to proc %d(%d)\", p-&gt;index, p-&gt;pid);\n        p-&gt;state = RUNNING;\n        c-&gt;proc  = p;\n        swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context);\n\n        // When we get back here, someone must have called swtch(..., &amp;c-&gt;sched_context);\n        assert(c-&gt;proc == p);\n        assert(!intr_get());        // scheduler should never have intr_on()\n        assert(holding(&amp;p-&gt;lock));  // whoever switch to us must acquire p-&gt;lock\n        c-&gt;proc = NULL;\n\n        if (p-&gt;state == RUNNABLE) {\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n</code></pre> <p>\u5f53\u6211\u4eec\u4ece <code>swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context)</code> \u8fd9\u4e00\u884c\u8fd4\u56de\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u5bfc\u5f97\u51fa\u4ee5\u4e0b\u7ed3\u8bba\uff1a</p> <ol> <li>\u56e0\u4e3a <code>swtch</code> \u662f\u6210\u5bf9\u7684\uff0c\u6211\u4eec\u4e0a\u6b21\u4ece <code>swtch</code> \u79bb\u5f00\uff0c\u8fd9\u6b21\u80af\u5b9a\u662f\u6709\u8c01\u8c03\u7528\u4e86 <code>swtch(... , &amp;c-&gt;sched_context)</code></li> <li>\u8fd9\u662f\u4e2a per-cpu scheduler\uff0c\u800c\u5728\u79bb\u5f00\u65f6\u6211\u4eec\u5c06\u8be5 CPU \u7684\u63a7\u5236\u6743\u79fb\u4ea4\u7ed9\u4e86\u8fdb\u7a0b p\uff0c\u6240\u4ee5\u80af\u5b9a\u662f\u4ece\u8fdb\u7a0b p swtch \u56de\u6765\u7684\u3002</li> </ol> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u4e09\u884c assert \u6765\u786e\u4fdd\u6211\u4eec\u7684 scheduler \u673a\u5236\u8fd0\u884c\u6b63\u5e38\uff1a</p> <ol> <li>swtch \u8fd4\u56de\u65f6\uff0c\u4e2d\u65ad\u4e00\u5b9a\u662f\u5173\u95ed\u7684</li> <li>\u6211\u4eec\u4e00\u5b9a\u6301\u6709\u8005 <code>p-&gt;lock</code> \u8fd9\u628a\u9501</li> <li>\u5f53\u524d cpu \u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\u4e00\u5b9a\u662f p</li> </ol> <p>\u6700\u540e\uff0c\u6211\u4eec\u6e05\u9664 <code>c-&gt;proc</code>\u3002\u5982\u679c p \u8fd8\u80fd\u7ee7\u7eed\u8fd0\u884c (RUNNABLE)\uff0c\u5219\u5c06\u5176\u4e22\u56de\u961f\u5217\u3002\u91ca\u653e <code>p-&gt;lock</code> \u540e\uff0c<code>scheduler</code> \u8fdb\u5165\u4e0b\u4e00\u4e2a\u5faa\u73af\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#sched","title":"sched \u65b9\u6cd5","text":"<p><code>sched</code> \u65b9\u6cd5\u7528\u4e8e\u5c06 CPU \u63a7\u5236\u6743\u7531\u5f53\u524d\u5185\u6838\u8fdb\u7a0b\u4ea4\u8fd8\u7ed9 scheduler\u3002</p> <pre><code>// Switch to scheduler.  Must hold only p-&gt;lock\n// and have changed proc-&gt;state. Saves and restores\n// interrupt_on because interrupt_on is a property of this\n// kernel thread, not this CPU. It should\n// be proc-&gt;interrupt_on and proc-&gt;noff, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid sched() {\n    int interrupt_on;\n    struct proc *p = curr_proc();\n\n    if (!holding(&amp;p-&gt;lock))\n        panic(\"not holding p-&gt;lock\");\n    if (mycpu()-&gt;noff != 1)\n        panic(\"holding another locks\");\n    if (p-&gt;state == RUNNING)\n        panic(\"sched running process\");\n    if (mycpu()-&gt;inkernel_trap)\n        panic(\"sched should never be called in kernel trap context.\");\n    assert(!intr_get());\n\n    interrupt_on = mycpu()-&gt;interrupt_on;\n\n    infof(\"switch to scheduler %d(%d)\", p-&gt;index, p-&gt;pid);\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    infof(\"switch back from scheduler %d(%d)\", p-&gt;index, p-&gt;pid);\n\n    mycpu()-&gt;interrupt_on = interrupt_on;\n\n    // if scheduler returns here: p-&gt;lock must be holding.\n    if (!holding(&amp;p-&gt;lock))\n        panic(\"not holding p-&gt;lock after sched.swtch returns\");\n}\n</code></pre> <p>\u6211\u4eec\u89c4\u5b9a\u5728 sched \u65f6\uff1a</p> <ol> <li>\u6301\u6709 <code>curr_proc()-&gt;lock</code> \u8fd9\u628a\u9501\uff0c\u56e0\u4e3a\u8981\u64cd\u4f5c\u8be5 <code>struct proc</code> \u7ed3\u6784\u4f53\u3002</li> <li> <p>\u9664\u4e86 <code>curr_proc()-&gt;lock</code> \u8fd9\u628a\u9501\uff0c\u4e0d\u6301\u6709\u4efb\u4f55\u5176\u4ed6\u7684\u9501\uff0c\u9632\u6b62\u5185\u6838\u51fa\u73b0\u6b7b\u9501\u3002</p> <p>\u8fd9\u4e00\u6b65\u662f\u901a\u8fc7\u68c0\u67e5 <code>mycpu()-&gt;noff</code> \u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u6bcf\u6b21 <code>acquire</code> \u4f1a\u5c06\u5176\u589e\u52a01\uff0c\u6bcf\u6b21 release \u4f1a\u5c06\u5176\u51cf\u5c111\u3002</p> </li> <li> <p>\u5fc5\u987b\u5df2\u7ecf\u4fee\u6539 <code>p-&gt;state</code> \u4e3a\u975e RUNNING\u3002</p> </li> <li>\u7981\u6b62\u5728 kernel trap \u73af\u5883\u4e2d\u8c03\u7528 sched\u3002</li> </ol> <p>\u5982\u679c\u68c0\u67e5\u901a\u8fc7\uff0c\u5219\u4f7f\u7528 <code>swtch</code> \u5c06\u5f53\u524d\u8fdb\u7a0b\u72b6\u6001\u4fdd\u5b58\u5230 <code>p-&gt;context</code>, \u5e76\u8df3\u8f6c\u5230 scheduler \u7684 context (<code>&amp;mycpu()-&gt;sched_context</code>) \u4e0a\u9762\u3002</p> <p>\u540c\u7406\uff0c\u5982\u679c scheduler \u8fd8\u4f1a\u5207\u6362\u56de\u6765\uff0c\u6211\u4eec\u4e00\u6837\u8981\u6c42 scheduler \u5728\u7ed9\u4e88 CPU \u63a7\u5236\u6743\u65f6\u5c06 <code>p-&gt;lock</code> \u4e0a\u9501\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#-init","title":"\u7b2c\u4e00\u4e2a\u8fdb\u7a0b - init","text":"<p>\u76ee\u524d\uff0c\u6211\u4eec\u8bb2\u4e86 xv6 \u91cc\u9762\u7684 Process Control Block: <code>struct proc</code>\uff0cContext Switch \u7684\u539f\u7406\uff0c\u4ee5\u53ca\u8c03\u5ea6\u5668\u7684\u8bbe\u8ba1\u3002\u6211\u4eec\u5373\u5c06\u4ecb\u7ecd xv6 \u4e2d\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\uff08\u5185\u6838\u7ebf\u7a0b\uff09\u662f\u5982\u4f55\u8fd0\u884c\u8d77\u6765\u7684\u3002</p> <p>\u5728 <code>main.c</code> \u4e2d\u7684 <code>bootcpu_init</code> \u51fd\u6570\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u4e86\u7b2c\u4e00\u4e2a\u5185\u6838\u7ebf\u7a0b <code>init</code>\uff1a<code>create_kthread(init, 0x1919810);</code>\uff0c\u8fd9\u8868\u793a\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\u5c06\u6267\u884c <code>init()</code> \u65b9\u6cd5\uff0c\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u53c2\u6570\u3002</p> <p><code>create_kthread</code> \u4ece <code>allocproc()</code> \u5904\u5206\u914d\u5f97\u5230\u4e00\u4e2a PCB \u7ed3\u6784\u4f53\uff0c\u5e76\u521d\u59cb\u5316\u5b83\u7684 <code>struct context</code> \u7ed3\u6784\u4f53\uff0c\u5373\u7b2c\u4e00\u6b21\u88ab\u8c03\u5ea6\u540e\u7684\u6267\u884c\u73af\u5883\u3002\u968f\u540e\u5b83\u4f1a\u5c06\u8be5\u8fdb\u7a0b\u6807\u8bb0\u4e3a\u53ef\u6267\u884c\uff0c\u5e76\u52a0\u5165\u5230\u8c03\u5ea6\u5668\u7684\u961f\u5217\u4e2d\u3002</p> <pre><code>int create_kthread(void (*fn)(uint64), uint64 arg) {\n    struct proc *p = allocproc();\n    if (!p)\n        return -1;\n\n    // initialize process state\n    p-&gt;context.ra = (uint64)first_sched_ret;\n    p-&gt;context.sp = p-&gt;kstack + PGSIZE;\n    p-&gt;context.s1 = (uint64)fn;\n    p-&gt;context.s2 = arg;\n\n    p-&gt;state = RUNNABLE;\n    p-&gt;parent = init_proc;\n\n    int pid = p-&gt;pid;\n    add_task(p);\n    release(&amp;p-&gt;lock);\n\n    return pid;\n}\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#_3","title":"\u7b2c\u4e00\u6b21\u8c03\u5ea6","text":"<p>\u5728\u5185\u6838\u7ebf\u7a0b <code>init</code> \u7b2c\u4e00\u6b21\u88ab\u8c03\u5ea6\u5230\u65f6\uff0cscheduler \u4ece\u4efb\u52a1\u961f\u5217\u4e2d\u5c06\u5176\u53d6\u51fa\uff0c\u968f\u540e\uff0cscheduler \u4f1a\u6267\u884c <code>swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context)</code>\uff08\u6b64\u65f6p\u5c31\u662f<code>init</code>\uff09\u3002\u5728 <code>swtch</code> \u6267\u884c\u5230 ret \u540e\uff0cCPU \u4f1a\u5207\u6362\u5230 init \u7684\u5185\u6838\u6808 (<code>p-&gt;kstack + PGSIZE</code>) \u5e76\u6267\u884c <code>first_sched_ret</code> \u65b9\u6cd5\u3002\u8be5\u65b9\u6cd5\u4f1a\u4ece s1 \u548c s2 \u5bc4\u5b58\u5668\u4e2d\u8bfb\u51fa\u8be5\u5185\u6838\u8fdb\u7a0b\u5c06\u8981\u6267\u884c\u7684\u65b9\u6cd5\uff0c\u4ee5\u53ca\u4e00\u4e2a\u4efb\u610f\u7684\u53c2\u6570\u3002\u968f\u540e\uff0c\u4f9d\u7167 scheduler \u7684\u89c4\u8303\uff0c\u5b83\u4f1a\u91ca\u653e <code>p-&gt;lock</code>\uff0c\u7136\u540e\u542f\u7528\u4e2d\u65ad\u540e\u8df3\u8f6c\u5230 fn \u4e2d\u6267\u884c\u3002</p> <pre><code>static void first_sched_ret(void) {\n    // s0: frame pointer, s1: fn, s2: uint64 arg\n    void (*fn)(uint64);\n    uint64 arg;\n    asm volatile(\"mv %0, s1\":\"=r\"(fn));\n    asm volatile(\"mv %0, s2\":\"=r\"(arg));\n\n    release(&amp;curr_proc()-&gt;lock);\n    intr_on();\n    fn(arg);\n    panic(\"first_sched_ret should never return. You should use exit to terminate kthread\");\n}\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#_4","title":"\u7b2c\u4e00\u6b21\u88ab\u8c03\u5ea6\u65f6\u6267\u884c\u6d41\u7a0b\u56fe","text":""},{"location":"lab/xv6lab-contextswitch/#lab-2","title":"Lab \u7ec3\u4e60 2","text":"<p>\u8bf7\u4f60\u4eff\u7167\u4e0a\u56fe\uff0c\u7ed8\u5236\u4e24\u4e2a\u8fdb\u7a0b\u4e4b\u95f4\u5207\u6362\u7684\u6d41\u7a0b\u56fe\u3002\u5df2\u77e5 P1 \u548c P2 \u90fd\u5df2\u7ecf\u88ab\u8c03\u5ea6\u8fc7\u81f3\u5c11\u4e00\u6b21\uff0c\u5373\u5df2\u7ecf\u79bb\u5f00\u4e86 <code>first_sched_ret</code> \u9636\u6bb5\uff0c\u5b83\u4eec\u7684 context \u4e2d\u7684 ra \u6307\u5411 <code>sched</code> \u51fd\u6570\u4e2d <code>swtch</code> \u7684\u4e0b\u4e00\u884c\u3002</p> <p>\u9996\u5148\uff0c\u6d41\u7a0b\u4ece\u5de6\u4e0a\u89d2\u5f00\u59cb\uff0cscheduler \u4ece <code>fetch_task</code> \u4e2d\u53d6\u51fa P1\uff0c\u4f7f\u7528 <code>swtch</code> \u5207\u6362\u5230 P1 \u7684 Context \u4e2d\u4fdd\u5b58\u7684\u5730\u5740\uff0c\u5373 P1 \u4e0a\u6b21\u5207\u6362\u56de scheduler \u7684\u5730\u65b9\uff1aP1 \u91cc\u9762\u7684 <code>swtch</code> \u7684\u4e0b\u4e00\u884c <code>sched() ends</code>\u3002</p> <p>\u7b2c\u4e00\u4e2a\u7bad\u5934\u5df2\u4e3a\u4f60\u753b\u51fa\uff0c\u8bf7\u6309\u7167\u5982\u4e0b\u6d41\u7a0b\u753b\u51fa\u5269\u4e0b\u7684\u7bad\u5934\uff0c\u53ea\u9700\u8981\u753b\u51fa\u6bcf\u4e2a <code>swtch</code> \u4f1a\u5207\u6362\u5230\u54ea\u91cc\u5373\u53ef\u3002</p> <ol> <li>\u4ece scheduler \u5207\u6362\u5230 P1 \u540e\uff0cP1 \u8fdb\u5165\u4e0b\u4e00\u4e2a\u5de5\u4f5c\u5faa\u73af\uff0c\u968f\u540e P1 \u8c03\u7528 <code>yield</code>\uff0c<code>sched</code>\uff0c\u63a7\u5236\u6d41\u6765\u5230\u53f3\u4e0a\u89d2\u7684 <code>swtch</code> \u5904\uff0c\u8bf7\u4f60\u753b\u51fa\u8fd9\u4e2a <code>swtch</code> \u4f1a\u5c06\u63a7\u5236\u6d41\u5e26\u5411\u54ea\u91cc\u3002</li> <li>\u968f\u540e\uff0c\u63a7\u5236\u6d41\u56de\u5230 <code>scheduler</code>\uff0c<code>scheduler</code> \u8fdb\u5165\u4e0b\u4e00\u4e2a\u5de5\u4f5c\u5faa\u73af\uff0c\u5b83\u4ece <code>fetch_task()</code> \u4e2d\u83b7\u53d6\u5230 P2\uff0c\u63a7\u5236\u6d41\u6765\u5230\u5de6\u4e0b\u89d2\u7684 <code>swtch</code> \u5904\uff0c\u8bf7\u4f60\u753b\u51fa\u8fd9\u4e2a <code>swtch</code> \u4f1a\u5c06\u63a7\u5236\u6d41\u5e26\u5411\u54ea\u91cc\u3002</li> <li>\u4ece scheduler \u5207\u6362\u5230 P2 \u540e\uff0cP2 \u8fdb\u5165\u4e0b\u4e00\u4e2a\u5de5\u4f5c\u5faa\u73af\uff0c\u968f\u540e P2 \u8c03\u7528 <code>yield</code>\uff0c<code>sched</code>\uff0c\u63a7\u5236\u6d41\u6765\u5230\u53f3\u4e0b\u89d2\u7684 <code>swtch</code> \u5904\uff0c\u8bf7\u4f60\u753b\u51fa\u8fd9\u4e2a <code>swtch</code> \u4f1a\u5c06\u63a7\u5236\u6d41\u5e26\u5411\u54ea\u91cc\u3002</li> </ol>"},{"location":"lab/xv6lab-contextswitch/#worker","title":"worker","text":"<p>\u7b2c\u4e00\u6b21\u8c03\u5ea6\u5b8c\u6210\u540e\uff0c<code>init</code> \u4f1a\u6309\u7167\u4ee3\u7801\u521b\u5efa8\u4e2a\u5185\u6838\u7ebf\u7a0b <code>worker</code> \u653e\u5165\u5c31\u7eea\u961f\u5217\u4e2d\u3002\u6b64\u65f6\u6b63\u5728scheduler\u4e2d\u5faa\u73af\u7684\u7a7a\u95f2cpu\u6838\u53ef\u4ee5\u4ece\u961f\u5217\u4e2d\u53d6\u5f97\u67d0\u4e00\u4e2a <code>worker</code> \u8fdb\u884c\u6267\u884c\u3002\u800c <code>init</code> \u5728\u521b\u5efa\u5b8c <code>worker</code> \u4eec\u540e\uff0c\u4f1a\u56e0wait()\u800c\u9677\u5165\u7b49\u5f85\uff0c\u6545\u800c\u91ca\u653e\u51fa\u4e00\u4e2acpu\u6838\u7684\u8d44\u6e90\uff0c\u81ea\u6b64\u4e4b\u540e\u5219\u662f4\u4e2a cpu \u6838\u6267\u884c8\u4e2a <code>worker</code> \u7684\u8fc7\u7a0b\u3002</p> <p>\u8fd9 8 \u4e2a <code>worker</code> \u4f1a\u5bf9\u5171\u4eab\u53d8\u91cf <code>count</code> \u8fdb\u884c\u7d2f\u52a0\uff0c\u5e76\u4e14\u6bcf\u7d2f\u52a0 1000 \u6b21\u8c03\u7528 <code>yield</code> \u4e00\u6b21\u3002\u8c03\u7528 <code>yield</code> \u7684 <code>worker</code> \u4f1a\u56e0\u4e3a\u8c03\u7528 <code>yield</code> \u800c\u4e3b\u52a8\u91ca\u653e\u51fa\u81ea\u5df1\u6b63\u5728\u4f7f\u7528\u7684cpu\u6838\uff0c\u6b64\u65f6\u8be5 cpu \u6838\u5219\u5c06\u8c03\u5ea6\u5230\u4e0b\u4e00\u4e2a\u5c31\u7eea\u7684\u8fdb\u7a0b\u7ee7\u7eed\u6267\u884c\u3002 \u4e4b\u540e\u6211\u4eec\u4f1a\u901a\u8fc7\u4e00\u6b21\u76f8\u5173\u7684\u4f5c\u4e1a\u5bf9\u8fd9\u4e2a\u8fc7\u7a0b\u8fdb\u884c\u66f4\u6df1\u5165\u7684\u7406\u89e3\u3002</p>"},{"location":"lab/xv6lab-contextswitch/#_5","title":"\u8bfe\u540e\u9605\u8bfb","text":""},{"location":"lab/xv6lab-contextswitch/#_6","title":"\u5173\u4e2d\u65ad","text":"<p>\u5728\u5185\u6838\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u6709\u65f6\u4f1a\u5e0c\u671b\u5f53\u524d\u7684\u6267\u884c\u4e0d\u4f1a\u88ab\u6253\u65ad\u3001\u4e0d\u4f1a\u88ab\u5176\u4ed6\u4efb\u52a1\u62a2\u5360\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5173\u95ed\u4e2d\u65ad\u6765\u5b9e\u73b0\u8fd9\u4e00\u70b9\u3002\uff08\u5f53\u7136\uff0c\u5f02\u5e38\u8fd8\u662f\u4f1a\u76f4\u63a5\u8df3\u5165 Trap Handler \u7684\uff09</p> <p>\u6211\u4eec\u4f7f\u7528 <code>push_off()</code> \u548c <code>pop_off()</code> \u8868\u793a\u4e00\u5bf9 \u5173\u4e2d\u65ad/\u5f00\u4e2d\u65ad\u7684\u64cd\u4f5c\u3002\u7531\u4e8e\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u5d4c\u5957 <code>push_off</code> \u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5173\u4e2d\u65ad\u89c6\u4e3a\u4e00\u79cd\u201c\u538b\u6808\u201d\u64cd\u4f5c\uff0c\u5e76\u4e14\u5f53\u4e14\u4ec5\u5f53\u6808\u7a7a\u65f6\u624d\u5c06\u4e2d\u65ad\u6062\u590d\u539f\u6837\uff0c\u6211\u4eec\u5728 <code>struct cpu</code> \u4e2d\u8bb0\u5f55\u4e24\u4e2a\u53d8\u91cf\uff1a</p> <ol> <li> <p><code>noff</code>\uff1a\u6211\u4eec\u76ee\u524d <code>push_off</code>/<code>pop_off</code> \u7684\u6df1\u5ea6\u662f\u591a\u5c11\u3002</p> <p>\u4f8b\u5982 <code>push_off()</code>, <code>push_off()</code>, <code>pop_off()</code> \u5e8f\u5217\u540e\uff0c<code>noff</code> \u5e94\u8be5\u4e3a 1.</p> </li> <li> <p><code>interrupt_on</code>: \u5728\u7b2c\u4e00\u6b21 <code>push_off()</code> \u65f6\uff0c\u5373 <code>noff == 0</code> \u65f6\uff0cCPU \u7684\u4e2d\u65ad\u662f\u5f00\u7684\u8fd8\u662f\u5173\u7684\u3002</p> </li> </ol> <pre><code>void push_off(void) {\n    uint64 ra = r_ra();\n\n    int old = intr_get();\n    intr_off();\n\n    if (mycpu()-&gt;noff == 0) {\n        // warnf(\"intr on saved: %p\", ra);\n        mycpu()-&gt;interrupt_on = old;\n    }\n    mycpu()-&gt;noff += 1;\n}\n\nvoid pop_off(void) {\n    uint64 ra = r_ra();\n\n    struct cpu *c = mycpu();\n    if (intr_get())\n        panic(\"pop_off - interruptible\");\n    if (c-&gt;noff &lt; 1)\n        panic(\"pop_off - unpair\");\n    c-&gt;noff -= 1;\n    if (c-&gt;noff == 0 &amp;&amp; c-&gt;interrupt_on) {\n        if (c-&gt;inkernel_trap)\n            panic(\"pop_off-&gt;intr_on happens in kernel trap\");\n        // we only open the interrupt if: \n        //    1. the push-pop stack is cleared, and \n        //    2. the interrupt was on before the first push-off\n        intr_on();\n    }\n}\n</code></pre>"},{"location":"lab/xv6lab-contextswitch/#cpu-interrupt_on","title":"\u4e3a\u4ec0\u4e48\u9700\u8981\u4fdd\u5b58 <code>cpu-&gt;interrupt_on</code>","text":"<p>\u56e0\u4e3a\u8be5\u5c5e\u6027\u662f\u5f53\u524d\u5185\u6838\u8fdb\u7a0b\u7684\u5c5e\u6027\uff0c\u800c\u5e76\u4e0d\u662f\u5f53\u524d cpu \u7684\u5c5e\u6027\u3002\u56e0\u4e3a\u6211\u4eec\u4f1a\u5728\u6ca1\u6709 Process \u7684\u60c5\u51b5\u4e0b\u4f7f\u7528 push_off/pop_off\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5c06 <code>interrupt_on</code> \u6807\u5fd7\u653e\u7f6e\u5728 <code>struct cpu</code> \u4e2d\uff0c\u800c\u4e0d\u662f <code>struct proc</code> \u4e2d\uff0c\u5e76\u4e14\u5728 <code>sched</code> \u5207\u6362\u5185\u6838\u8fdb\u7a0b\u65f6\uff0c\u5c06\u8be5\u5c5e\u6027\u4fdd\u5b58\u5728\u8be5\u5185\u6838\u8fdb\u7a0b\u7684\u6808\u4e0a\u3002</p> <p>\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u4e0d\u9700\u8981\u4fdd\u5b58 noff\uff1a\u56e0\u4e3a\u6211\u4eec\u5f3a\u5236\u8981\u6c42\u5b83\u4e3a 1\u3002</p> <p>\u5982\u679c\u6211\u4eec\u6ce8\u91ca\u6389\u4fdd\u5b58 <code>interrupt_on</code> \u8fd9\u4e00\u884c\uff0c\u4e0b\u56fe\u5c55\u793a\u4e86 Kernel Process 1 (\u7ea2\u8272) \u7684 Interrupt On \u72b6\u6001\u662f\u5982\u4f55\u901a\u8fc7 sched \u548c scheduler (\u84dd\u8272) \u9519\u8bef\u5f71\u54cd\u5230 Kernel Process 2 (\u9ec4\u8272) \u7684\uff1a</p> <p>Kernel Process 2 \u5148\u8fd0\u884c\u4e86\u4e00\u6bb5\u65f6\u95f4\uff0c\u6b64\u65f6\u4e2d\u65ad\u4e3a\u5173\uff0c\u7136\u540e\u8c03\u7528 sched \u6682\u65f6\u79bb\u5f00(\u865a\u7ebf)\uff0c\u800c\u6b64\u65f6 Kernel Process 1 \u5f00\u59cb\u6267\u884c(\u5b9e\u7ebf)\u3002P1 \u6267\u884c\u65f6\uff0c\u4e2d\u65ad\u4e3a\u5f00\u3002\u5728 P1 \u8c03\u7528 sched \u5207\u6362\u5230 scheduler \u65f6\uff0c\u4e2d\u65ad\u72b6\u6001\u88ab <code>acquire-&gt;push_off</code> \u4fdd\u5b58\u5728 <code>cpu-&gt;interrupt_on</code> \u4e2d\uff0c\u968f\u540e scheduler \u9009\u62e9\u4e86 P2 \u7ee7\u7eed\u6267\u884c\u3002\u800c P2 \u5728\u9000\u51fa sched \u65f6\u8c03\u7528\u4e86 <code>release</code>-&gt;<code>pop_off</code> \u800c\u9519\u8bef\u6062\u590d\u4e86\u4e2d\u65ad\u5f00\u7684\u72b6\u6001\u3002\u5bf9\u4e8e P2 \u800c\u8a00\uff0c\u5b83\u5728\u88ab\u5207\u6362\u524d\u662f\u6267\u884c\u73af\u5883\u662f\u4e2d\u65ad\u5173\u7684\uff0c\u800c\u88ab\u5207\u6362\u540e\u5b83\u8fd0\u884c\u5728\u4e2d\u65ad\u5f00\u7684\u73af\u5883\u4e2d\uff0c\u8fd9\u663e\u7136\u8fdd\u53cd\u4e86 Context Switch \u4e0d\u4f1a\u6539\u53d8\u7a0b\u5e8f\u8fd0\u884c\u7684\u4e0a\u4e0b\u6587\u8fd9\u4e00\u89c4\u5219\u3002</p> <p></p>"},{"location":"lab/xv6lab-interrupts/","title":"Trap, Exception and Interrupt","text":""},{"location":"lab/xv6lab-interrupts/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u4e86\u89e3\u5f02\u5e38\u63a7\u5236\u6d41</li> <li>\u4e86\u89e3 RISC-V \u67b6\u6784\u662f\u5982\u4f55\u652f\u6301 CPU \u4e2d\u65ad\u7684</li> <li>\u638c\u63e1 Trap \u5904\u7406\u6d41\u7a0b</li> </ol> <p>xv6-lab2 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab2</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab2 xv6lab2</code> \u4e0b\u8f7d xv6-lab2 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u4f60\u5c06\u4f1a\u770b\u5230\u4e00\u6b21 Kernel Panic\u3002</p> <p>\u63a8\u8350\u9605\u8bfb</p> <p>CSAPP, Chapter 8, Exceptional Control Flow.</p> <p>https://csapp.cs.cmu.edu/2e/ch8-preview.pdf</p>"},{"location":"lab/xv6lab-interrupts/#exceptional-control-flow","title":"Exceptional Control Flow","text":"<p>\u5728\u6b63\u5e38\u7684\u7a0b\u5e8f\u8fd0\u884c\u72b6\u6001\u4e0b\uff0c\u63a7\u5236\u6d41 (\u53ef\u4ee5\u8ba4\u4e3a\u662f pc \u6307\u9488\u7684\u5e8f\u5217) \u662f\u6309\u7167\u7a0b\u5e8f\u6240\u9884\u5b9a\u7684\u987a\u5e8f\u4e00\u6b65\u6b65\u6267\u884c\u7684\u3002\u4f46\u662f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e0d\u53ef\u907f\u514d\u5730\u9700\u8981\u5904\u7406\u4e00\u4e9b\u5728\u201c\u9884\u5b9a\u4e4b\u5916\u7684\u201d\u60c5\u51b5\uff0c\u4f8b\u5982\u7a0b\u5e8f\u51fa\u9519\u3001\u6216\u8005\u5916\u90e8\u72b6\u6001\u6709\u6240\u6539\u53d8\uff0c\u6bd4\u5982\u6709\u6570\u636e\u5305\u62b5\u8fbe\u7f51\u5361\u3001\u7528\u6237\u6572\u51fb\u952e\u76d8\u7b49\u4e8b\u4ef6\u3002\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u901a\u8fc7\u6539\u53d8\u63a7\u5236\u6d41\u6765\u5904\u7406\u8fd9\u4e9b\u4e8b\u4ef6\uff0c\u6211\u4eec\u5c06\u8fd9\u79cd\u63a7\u5236\u6d41\u79f0\u4e3a Exceptional Control Flow (\u5f02\u5e38\u63a7\u5236\u6d41)\u3002</p>"},{"location":"lab/xv6lab-interrupts/#exceptions-traps-and-interrupts","title":"Exceptions, Traps, and Interrupts","text":"<p>\u5728 RISC-V \u4f53\u7cfb\u67b6\u6784\u4e2d\uff0c\u6211\u4eec\u5c06 Exception (\u5f02\u5e38)\u3001 Interrupt (\u4e2d\u65ad)\u548c Trap (\u9677\u9631\uff0c\u9677\u5165) \u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li>Exception: \u4e00\u79cd\u4e0d\u5bfb\u5e38\u7684\u60c5\u51b5\uff0c\u51fa\u73b0\u5728\u6307\u4ee4\u6267\u884c\u7684\u65f6\u523b\u3002</li> <li>Interrupt: \u4e00\u79cd\u5916\u90e8\u7684\u4e8b\u4ef6\uff0c\u4e0e\u5f53\u524d RISC-V \u6838\u5fc3\u6307\u4ee4\u6267\u884c\u662f\u5f02\u6b65\u7684\u3002</li> <li>Trap: \u4e00\u79cd\u540c\u6b65\u7684\u3001\u7531\u4e8e\u5f02\u5e38\u6216\u4e2d\u65ad\u5bfc\u81f4\u7684\u63a7\u5236\u6d41\u8f6c\u79fb\u3002\u6211\u4eec\u53ef\u4ee5\u5c06 Trap \u8ba4\u4e3a\u662f\u5bf9 Exception \u548c Interrupt \u7684\u5904\u7406\u884c\u4e3a\u3002</li> </ul> <p>\u4ec0\u4e48\u662f\u540c\u6b65/\u5f02\u6b65 (Synchronous / Asynchronous)</p> <p>\u56de\u60f3\u5728\u6570\u5b57\u903b\u8f91\u8bfe\u7a0b\u4e0a\u5b9e\u73b0\u7684\u5355\u5468\u671f RISC-V CPU\uff0c\u6211\u4eec\u6709\u65f6\u949f\u4fe1\u53f7 clk (clock)\uff0c\u6bcf(n)\u4e2a\u65f6\u949f\u5468\u671f\u6267\u884c\u4e00\u6761\u6307\u4ee4\u3002</p> <p>\u540c\u6b65\u7684\u5f02\u5e38\u662f\u7531\u4e8e\u6307\u4ee4\u6267\u884c\u65f6\u4ea7\u751f\u7684\uff0c\u6240\u4ee5\u5f02\u5e38\u7684\u4ea7\u751f\u662f\u4e0e clk \u5bf9\u9f50\u7684\uff1b\u800c\u5f02\u6b65\u7684\u5f02\u5e38\u5219\u5b8c\u5168\u4e0e\u5f53\u524d\u6307\u4ee4\u3001clk\u65e0\u5173\u3002</p> <p></p> <p>\u6240\u4ee5\uff0c\u5f88\u663e\u7136\u4e3a\u4ec0\u4e48 Trap \u6240\u6307\u7684\u63a7\u5236\u6d41\u8f6c\u79fb\u662f\u201c\u540c\u6b65\u201d\u7684\uff1a\u6211\u4eec\u8d77\u7801\u9700\u8981\u7b49\u5f85\u65f6\u949f\u5468\u671f\u6765\u4e34\u624d\u80fd\u8fdb\u884c\u63a7\u5236\u6d41\u8f6c\u79fb\u3002</p> <p>We use the term exception to refer to an unusual condition occurring at run time associated with an instruction in the current RISC-V thread. We use the term trap to refer to the synchronous transfer of control to a trap handler caused by an exceptional condition occurring within a RISC-V thread. Trap handlers usually execute in a more privileged environment.</p> <p>We use the term interrupt to refer to an external event that occurs asynchronously to the current RISC-V thread. When an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and subsequently experiences a trap.</p> <p>Source: riscv-spec-v2.1.pdf, Section 1.3 \"Exceptions, Traps, and Interrupts\".</p> <p>RISC-V \u4e0e x86 \u7684\u4e0d\u540c\uff1a</p> <p>\u5728\u4e0d\u540c\u7684\u6559\u6750\u4e2d\uff0c\u6211\u4eec\u5bf9 Exception (\u5f02\u5e38)\u3001Trap (\u9677\u9631) \u548c Interrupt (\u4e2d\u65ad) \u6709\u7740\u7c7b\u4f3c\u7684\u5b9a\u4e49\uff0c\u4f8b\u5982 CSAPP \u53c2\u7167 x86 \u6a21\u578b\u63cf\u8ff0\u4e86\u5982\u4e0b\u56db\u79cd\u7c7b\u578b\u7684\u63a7\u5236\u6d41\u4e2d\u65ad\uff1a\u4e3b\u8981\u533a\u522b\u5728\u4e8e\u5f02\u5e38\u63a7\u5236\u6d41\u4ea7\u751f\u662f\u5426\u4e0e\u6307\u4ee4\u6d41\u540c\u6b65\u3001\u4ee5\u53ca\u8df3\u8f6c\u81f3\u5f02\u5e38\u63a7\u5236\u6d41\u540e\u662f\u5426\u4f1a\u8fd4\u56de\u5230\u539f\u6765\u7a0b\u5e8f\u7684\u63a7\u5236\u6d41\u3002</p> <p></p> <p>\u4f8b\u5982\uff0cx86 \u4e2d\u7684\u5f02\u5e38\u7c7b\u578b\uff1a Page Fault (\u7f3a\u9875\u5f02\u5e38)\uff0cMachine Check (Abort) (\u5185\u5b58\u6216\u786c\u4ef6\u9519\u8bef)\u3002</p> <p>\u4f46\u662f\uff0c\u5728 RISC-V \u6a21\u578b\u4e0b\uff0c\u4e0a\u8ff0\u7684\u8fd4\u56de\u884c\u4e3a\u5747\u662f\u53ef\u4ee5\u901a\u8fc7\u8f6f\u4ef6\u6a21\u62df\u7684\uff0c\u6240\u4ee5\u5728 RISC-V \u786c\u4ef6\u6a21\u578b\u4e0a\uff0c\u5bfc\u81f4\u63a7\u5236\u6d41\u6539\u53d8\u7684\u539f\u56e0\u53ea\u6709\u4e24\u79cd\uff1a\u5f02\u5e38 (Exception) \u548c\u4e2d\u65ad (Interrupt)\u3002\u800c\u5bfc\u81f4\u63a7\u5236\u6d41\u6539\u53d8\u7684\u7ed3\u679c\u5c31\u662f\u8fdb\u5165 Trap\u3002</p> <p>Note: RISC-V \u786c\u4ef6\u5c42\u9762\u6709\u4e00\u79cd\u6781\u5176\u7cbe\u7b80\u7684\u8bbe\u8ba1\u8bed\u8a00\uff1a\u53ea\u8981\u8f6f\u4ef6\u80fd\u5904\u7406\u7684\u4e8b\u60c5\uff0c\u786c\u4ef6\u4e00\u6982\u4e0d\u7ba1\u3002</p>"},{"location":"lab/xv6lab-interrupts/#csr-mstatussstatus","title":"CSR: mstatus/sstatus","text":"<p>CSR</p> <p>\u5982\u679c\u4f60\u4e0d\u6e05\u695a CSR \u662f\u4ec0\u4e48\uff0c\u8bf7\u91cd\u65b0\u9605\u8bfb\u4e0a\u4e00\u8282 Lab \u8bfe\u7684\u8bfe\u4ef6\u3002</p> <p>\u4f60\u53ef\u80fd\u4f1a\u5bf9 CSR Field \u5b9a\u4e49\u4e2d\u7684 WPRI, WLRL, WARL \u7b49\u5173\u952e\u5b57\u611f\u5230\u8ff7\u60d1\uff0c\u8bf7\u67e5\u9605 riscv-privilege.pdf, Section 2.3 CSR Field Specifications\u3002\u4f60\u53ef\u4ee5\u76f4\u63a5\u8ba4\u4e3a\uff0c\u7531\u8fd9\u4e9b\u5173\u952e\u5b57\u5b9a\u4e49\u7684 Bit Fields \u662f\u6211\u4eec\u4e0d\u9700\u8981\u5173\u5fc3\u3001\u4fee\u6539\u7684\u5b57\u6bb5\u3002</p> <p>mstatus/sstatus: Machine/Supervisor Status Register. \u8be5\u5bc4\u5b58\u5668\u4fdd\u5b58\u7740 RISC-V \u6838\u5fc3\u7684\u63a7\u5236\u72b6\u6001\uff0csstatus \u5b9e\u9645\u4e0a\u662f mstatus \u7684\u4e00\u4e2a Restricted View.</p> <p></p> <p></p> <p>\u7531\u4e8e RISC-V \u7684\u624b\u518c\u5bf9 CSR \u5bc4\u5b58\u5668\u6bcf\u4e2a Field \u7684\u5b9a\u4e49\u5b9e\u5728\u662f\u592a\u96be\u627e\uff0c\u6211\u4eec\u5728\u6b64\u5904\u63d0\u4f9b\u4e00\u4e2a\u7528\u4e8e\u5feb\u901f\u67e5\u627e\u7684\u8868\uff1a</p> Field \u5168\u79f0 (\u731c\u7684) \u610f\u4e49 SPP Supervisor Previous Privilege \u8fdb\u5165 Supervisor mode \u524d\uff0cHart \u6240\u5904\u7684\u7279\u6743\u7ea7\u3002 SIE Supervisor Interrupt Enabled Supervisor \u4e0b\uff0c\u4e2d\u65ad\u542f\u7528\u6807\u5fd7\u4f4d\u3002 SPIE Supervisor Previous Interrupt Enabled \u8fdb\u5165 Supervisor \u524d\u7684\u4e2d\u65ad\u542f\u7528\u72b6\u6001\u3002 SUM Supervisor User-Memory \u5141\u8bb8 Supervisor \u6a21\u5f0f\u4e0b\u8bbf\u95ee\u5e26 U-bit \u7684\u9875\u9762 <p>\u5176\u4ed6\u6211\u4eec\u76ee\u524d\u7528\u4e0d\u5230\u7684\u5728\u6b64\u4e0d\u505a\u89e3\u91ca\u3002</p>"},{"location":"lab/xv6lab-interrupts/#trap","title":"Trap \u76f8\u5173\u5bc4\u5b58\u5668\uff1a","text":"<p>\u6211\u4eec\u9996\u5148\u5217\u4e3e\u4e00\u4e0b\u5728 Trap \u5904\u7406\u6d41\u7a0b\u4e2d\u7528\u5230\u7684\u5bc4\u5b58\u5668\uff1a</p> <ul> <li>stvec : Supervisor Trap Vector Base Address Register<ul> <li>\u5b58\u50a8 Trap \u5904\u7406\u51fd\u6570\u5730\u5740\u3002\u4e00\u822c\u79f0\u4e4b\u201c\u4e2d\u65ad\u5411\u91cf\u201d\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u8bb2\u89e3\u3002</li> </ul> </li> <li>sip : Supervisor Interrupt Pending<ul> <li>\u8868\u793a\u6709\u54ea\u4e9b\u4e2d\u65ad\u7b49\u5f85\u5904\u7406</li> </ul> </li> <li>sie : Supervisor Interrupt Enabled<ul> <li>\u8868\u793a\u53ef\u4ee5\u5904\u7406\u90a3\u4e9b\u4e2d\u65ad</li> <li>\u6ce8\u610f\u4e0d\u8981\u4e0e sstatus.SIE \u641e\u6df7\u3002</li> </ul> </li> <li>sepc: Supervisor Exception Program Counter<ul> <li>\u53d1\u751f\u4e2d\u65ad\u65f6\u7684 PC \u6307\u9488</li> </ul> </li> <li>scause: Supervisor Cause<ul> <li>\u53d1\u751f\u4e2d\u65ad\u7684\u539f\u56e0</li> </ul> </li> <li>stval: Supervisor Trap Value<ul> <li>\u53d1\u751f\u4e2d\u65ad\u7684\u989d\u5916\u4fe1\u606f</li> </ul> </li> </ul>"},{"location":"lab/xv6lab-interrupts/#stvec","title":"stvec","text":"<p>\u5728\u5f02\u5e38\u6216\u4e2d\u65ad\u4ea7\u751f\u540e\uff0c\u5e94\u8be5\u6709\u4e2a Trap \u5904\u7406\u7a0b\u5e8f \u6765\u5904\u7406\u8fd9\u4e9b\u5f02\u5e38\u548c\u4e2d\u65ad\u3002<code>stvec</code>(Supervisor Trap Vector Base Address Register)\u5373\u662f\u6240\u8c13\u7684<code>Trap\u5411\u91cf\u8868\u57fa\u5740</code>\u3002 \u5411\u91cf\u8868\u7684\u4f5c\u7528\u5c31\u662f\u628a\u4e0d\u540c\u79cd\u7c7b\u7684 Trap \u6620\u5c04\u5230\u5bf9\u5e94\u7684 Trap \u5904\u7406\u7a0b\u5e8f\u3002 \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u7a0b\u5e8f\uff0c\u90a3\u4e48\u53ef\u4ee5\u8ba9<code>stvec</code>\u76f4\u63a5\u6307\u5411\u90a3\u4e2a\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002</p> <p>stvec</p> <p>stvec \u89c4\u5b9a Trap \u5904\u7406\u51fd\u6570\u5165\u53e3\u4e00\u5b9a\u662f\u5bf9\u9f50\u5230 4 bytes (\u5373\u6700\u540e\u4e24 bit \u4e3a 0)\uff1b\u540c\u65f6\uff0c\u7528\u8fd9\u6700\u540e\u4e24\u4f4d\u8868\u793a\u4e24\u79cd\u6a21\u5f0f\uff1a</p> <ol> <li>Direct \u6a21\u5f0f\uff1a\u6240\u6709 Trap \u7684\u5165\u53e3\u5747\u4e3a pc &lt;= BASE</li> <li>Vectored \u6a21\u5f0f\uff1a\u5bf9\u4e8e\u5f02\u6b65\u7684\u4e2d\u65ad\uff0cpc &lt;= BASE + 4 * cause</li> </ol> <p>\u5728\u6211\u4eec\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 Direct \u6a21\u5f0f\u3002</p> <p></p>"},{"location":"lab/xv6lab-interrupts/#scause","title":"scause","text":"<p>\u5f53\u4e00\u4e2a\u9677\u9631\uff08trap\uff09\u88ab\u6355\u83b7\u5e76\u8fdb\u5165 S \u6a21\u5f0f\uff08Supervisor Mode\uff09\u65f6\uff0c<code>scause</code> \u5bc4\u5b58\u5668\u4f1a\u88ab\u5199\u5165\u4e00\u4e2a\u4ee3\u7801\uff0c\u8be5\u4ee3\u7801\u6307\u793a\u5bfc\u81f4\u9677\u9631\u7684\u4e8b\u4ef6\u3002</p> <p></p> <p></p>"},{"location":"lab/xv6lab-interrupts/#sie-sip","title":"sie &amp; sip","text":"<p><code>sip</code> \u5bc4\u5b58\u5668\u662f\u4e00\u4e2a 64 \u4f4d\u7684\u8bfb\u5199\u5bc4\u5b58\u5668\uff0c\u7528\u4e8e\u5b58\u50a8\u6709\u5173\u6302\u8d77\u4e2d\u65ad\u7684\u4fe1\u606f\uff0c\u800c <code>sie</code> \u5219\u662f\u76f8\u5e94\u7684 64 \u4f4d\u8bfb\u5199\u5bc4\u5b58\u5668\uff0c\u5305\u542b\u4e2d\u65ad\u4f7f\u80fd\u4f4d\u3002</p> <p>\u4e2d\u65ad\u539f\u56e0\u7f16\u53f7 <code>i</code>\uff08\u5982 CSR <code>scause</code> \u4e2d\u6240\u793a\uff09\u5bf9\u5e94\u4e8e <code>sip</code> \u548c <code>sie</code> \u5bc4\u5b58\u5668\u4e2d\u7684\u7b2c <code>i</code> \u4f4d\u3002 \u7b2c 15:0 \u4f4d\u4ec5\u5206\u914d\u7ed9\u6807\u51c6\u4e2d\u65ad\u539f\u56e0\uff0c\u800c\u7b2c 16 \u4f4d\u53ca\u4ee5\u4e0a\u7684\u4f4d\u5219\u4fdd\u7559\u7ed9\u5e73\u53f0\u6216\u81ea\u5b9a\u4e49\u7528\u9014\u3002</p> <p></p> <p></p>"},{"location":"lab/xv6lab-interrupts/#sepc","title":"sepc","text":"<p>\u5f53\u4e00\u4e2a Trap \u88ab\u6355\u83b7\u5e76\u8fdb\u5165 S \u6a21\u5f0f\uff08Supervisor Mode\uff09\u65f6\uff0c <code>sepc</code> \u5bc4\u5b58\u5668\u4f1a\u88ab\u5199\u5165 \u88ab\u4e2d\u65ad\u6216\u9047\u5230\u5f02\u5e38 \u7684\u6307\u4ee4\u7684\u865a\u62df\u5730\u5740\u3002</p>"},{"location":"lab/xv6lab-interrupts/#stval","title":"stval","text":"<p>\u5f53\u4e00\u4e2a Trap \u88ab\u6355\u83b7\u5e76\u8fdb\u5165 S \u6a21\u5f0f\uff08Supervisor Mode\uff09\u65f6\uff0c <code>stval</code> \u5bc4\u5b58\u5668\u4f1a\u88ab\u5199\u5165\u4e0e\u5f02\u5e38\u76f8\u5173\u7684\u7279\u5b9a\u4fe1\u606f\uff0c\u4ee5\u534f\u52a9\u8f6f\u4ef6\u5904\u7406\u8be5\u9677\u9631\u3002</p> <p>\u5728\u53d6\u6307\u3001\u52a0\u8f7d\u6216\u5b58\u50a8\u64cd\u4f5c\u4e2d\u53d1\u751f\u65ad\u70b9\u3001\u5730\u5740\u4e0d\u5bf9\u9f50\u3001\u8bbf\u95ee\u9519\u8bef\u6216\u9875\u9519\u8bef\u5f02\u5e38\u65f6\uff0c <code>stval</code> \u4f1a\u88ab\u5199\u5165\u4e00\u4e2a\u975e\u96f6\u503c\uff0c\u5e76\u4e14 <code>stval</code> \u5c06\u5305\u542b\u5bfc\u81f4\u5f02\u5e38\u7684\u865a\u62df\u5730\u5740\u3002</p>"},{"location":"lab/xv6lab-interrupts/#cpu-trap","title":"CPU \u5982\u4f55\u5904\u7406 Trap","text":"<p>Trap\u5904\u7406\u8fc7\u7a0b\u53ef\u4ee5\u5206\u4e3a\u4e09\u4e2a\u4e3b\u8981\u90e8\u5206\uff1a</p> <ol> <li>\u8fdb\u5165Trap</li> <li>Trap\u5904\u7406\u7a0b\u5e8f</li> <li>Trap\u5904\u7406\u8fd4\u56de </li> </ol>"},{"location":"lab/xv6lab-interrupts/#1-trap","title":"1. \u8fdb\u5165 Trap","text":"<p>\u5f53\u4e00\u4e2a Exception \u53d1\u751f\u65f6\uff0c\u6216\u8005 Hart \u51c6\u5907\u597d\u5904\u7406 Interrupt \u65f6\uff0c Trap \u53d1\u751f\uff0cCPU \u5728\u786c\u4ef6\u7535\u8def\u4e0a\u5b8c\u6210\u4ee5\u4e0b\u51e0\u4ef6\u4e8b\u60c5\uff1a</p> <ol> <li>scause &lt;= {1b'Is_Interrupt, 63b'Cause}</li> <li>stval &lt;= Trap_Value</li> <li>sepc &lt;= pc</li> <li>sstatus.SPP &lt;= Current_Privilege_Level</li> <li>sstatus.SPIE &lt;= sstatus.SIE</li> <li>sstatus.SIE &lt;= 0</li> <li>pc &lt;= stvec</li> </ol> <p>\u5373\u8bbe\u7f6e <code>scause</code> \u4e0e <code>stval</code> =&gt; \u4fdd\u5b58 PC \u5230 <code>spec</code> =&gt; \u4fdd\u5b58\u5f53\u524d\u7279\u6743\u7ea7(U/S)\u5230 <code>sstatus.SPP</code> =&gt; \u4fdd\u5b58\u5f53\u524d\u4e2d\u65ad\u72b6\u6001\u5230 <code>sstatus.SPIE</code> =&gt; \u5c06\u4e2d\u65ad\u5173\u95ed <code>sstatus.SIE = 0</code>\uff0c\u9632\u6b62\u5728 Trap \u5904\u7406\u51fd\u6570\u4e2d\u9047\u5230\u4e2d\u65ad =&gt; \u8df3\u8f6c\u5230 <code>stvec</code></p>"},{"location":"lab/xv6lab-interrupts/#2-trap","title":"2. Trap \u5904\u7406\u7a0b\u5e8f","text":"<p><code>stvec</code> \u4e2d\u5b58\u50a8\u4e86 Trap \u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\uff0c\u5f53CPU\u8bb0\u5f55\u5b8c\u5bfc\u81f4Trap\u7684\u5f02\u5e38\u6216\u4e2d\u65ad\u7684\u76f8\u5173\u4fe1\u606f\u540e\uff0c<code>pc</code> \u4f1a\u6307\u5411 <code>stvec</code> \u4e2d\u5b58\u50a8\u7684\u5730\u5740\uff0c\u4ece\u800c\u6267\u884c\u76f8\u5e94\u7684 <code>Trap</code> \u5904\u7406\u7a0b\u5e8f. <code>Trap</code> \u5904\u7406\u7a0b\u5e8f\u4f1a\u6839\u636e\u5bc4\u5b58\u5668\u4e2d\u5b58\u50a8\u7684\u5f02\u5e38\u6216\u4e2d\u65ad\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u91c7\u7528\u4e0d\u540c\u7684\u8f6f\u4ef6\u884c\u4e3a\u8fdb\u884c\u76f8\u5e94\u7684\u5904\u7406\u3002</p>"},{"location":"lab/xv6lab-interrupts/#3-trap-sret","title":"3. Trap\u5904\u7406\u8fd4\u56de <code>sret</code>","text":"<p>RISC-V \u4f7f\u7528 <code>sret</code> \u6307\u4ee4\u4ece Supervisor \u7684 Trap \u4e2d\u9000\u51fa\uff0c\u8be5\u6307\u4ee4\u4f1a\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ol> <li>sstauts.SIE &lt;= sstatus.SPIE</li> <li>Current_Privilege_Level &lt;= sstauts.SPP</li> <li>pc &lt;= epc</li> </ol> <p>\u5373\u8fd8\u539f <code>sstatus.SIE</code> \u4e3a <code>sstatus.SPIE</code> =&gt; \u5c06\u7279\u6743\u7ea7(U/S)\u8bbe\u7f6e\u4e3a <code>sstauts.SPP</code> =&gt; \u5c06 PC \u8bbe\u7f6e\u4e3a <code>sepc</code></p> <p>\u5b9e\u9645\u4e0a sret \u5c31\u662f Trap \u65f6\u4e09\u6b65\u4fdd\u5b58\u7684\u9006\u6b65\u9aa4\uff1a\u8fd8\u539f <code>SIE</code>\u3001\u7279\u6743\u7ea7\u548c PC \u5bc4\u5b58\u5668\u3002</p>"},{"location":"lab/xv6lab-interrupts/#_2","title":"\u4ee3\u7801\u89e3\u8bfb","text":"<p>\u5728\u64cd\u4f5c\u7cfb\u7edf\u542f\u52a8\u4e4b\u540e\uff0c\u6211\u4eec\u5c06\u5bf9 <code>stvec</code> \u5bc4\u5b58\u5668\u7684\u503c\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u5c06\u5b83\u6307\u5411 <code>kernel_trap_entry</code>\u3002</p> <pre><code>//trap.c\nvoid set_kerneltrap() {\n    assert(IS_ALIGNED((uint64)kernel_trap_entry, 4));\n    w_stvec((uint64)kernel_trap_entry);  // DIRECT\n}\n</code></pre> <p>\u63a5\u7740\uff0c\u5f53 Trap \u53d1\u751f\u540e\uff0cCPU\u5728\u505a\u5b8c\u76f8\u5e94\u4fe1\u606f\u7684\u5b58\u50a8\u540e\uff0c\u8df3\u8f6c\u5230 <code>stvec</code> \u6307\u5411\u7684 <code>kernel_trap_entry</code> \u65b9\u6cd5\u5f00\u59cb\u6267\u884c\uff0c\u5b83\u662f\u9002\u7528\u4e8e S mode \u7684\u4e2d\u65ad\u5411\u91cf\u5165\u53e3\u70b9\u3002</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // we store all registers in the stack\n    add sp, sp, -0x100\n    sd x0, 0x00(sp)\n    sd x1, 0x08(sp)\n    sd x2, 0x10(sp)\n    // ...\n    sd x30, 0xf0(sp)\n    sd x31, 0xf8(sp)\n\n    // ...\n</code></pre> <p>\u5165\u53e3\u70b9\u4f1a\u5728\u6808\u4e0a\u7533\u8bf7 0x100 bytes \u7684\u7a7a\u95f4\uff0c\u5e76\u4fdd\u5b58\u6240\u6709\u901a\u7528\u5bc4\u5b58\u5668\u5230\u6808\u4e0a\u3002 \u6b64\u65f6\uff0c\u6808\u4e0a\u4fdd\u5b58\u4e86 32 \u4e2a\u5bc4\u5b58\u5668\uff0c\u6bcf\u4e2a\u5360\u7528\u7a7a\u95f4 8 bytes\uff0c\u603b\u5171\u5360\u7528 0x100 bytes\uff0c\u4ece\u4f4e\u5730\u5740\u5230\u9ad8\u5730\u5740\u5206\u522b\u662f\u4ece x0 \u5230 x31\u3002 \u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53 <code>struct ktrapframe</code>\uff0c\u5e76\u4f7f\u5b83\u7684\u5185\u5b58\u5e03\u5c40\u548c\u6b64\u65f6\u6808\u4e0a\u7684\u5bc4\u5b58\u5668\u5e03\u5c40\u4e00\u81f4\u3002 \u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5728 C \u8bed\u8a00\u4e2d\u5c31\u53ef\u4ee5\u76f4\u63a5\u5bf9\u4e00\u4e2a <code>struct ktrapframe*</code> \u7684\u6307\u9488\u8fdb\u884c\u89e3\u5f15\u7528\uff0c\u6765\u8bbf\u95ee\u5230\u6b64\u65f6\u5728\u6808\u4e0a\u4fdd\u5b58\u7684\u6240\u6709 GPR\u3002</p> <pre><code>struct ktrapframe {\n    uint64 x0;  // x0\n    uint64 ra;\n    uint64 sp;\n    uint64 gp;\n    uint64 tp;\n    uint64 t0;\n    uint64 t1;\n    uint64 t2;\n    uint64 s0;\n    uint64 s1;\n    uint64 a0;\n    uint64 a1;\n    uint64 a2;\n    uint64 a3;\n    uint64 a4;\n    uint64 a5;\n    uint64 a6;\n    uint64 a7;\n    uint64 s2;\n    uint64 s3;\n    uint64 s4;\n    uint64 s5;\n    uint64 s6;\n    uint64 s7;\n    uint64 s8;\n    uint64 s9;\n    uint64 s10;\n    uint64 s11;\n    uint64 t3;\n    uint64 t4;\n    uint64 t5;\n    uint64 t6;\n\n    // 32 * 8 bytes = 256 (0x100) bytes\n};\n</code></pre> <p>\u6808</p> <p>\u5728\u4e00\u8fdb\u5165 Trap Handler \u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u5b9a\u4e4b\u524d\u7684\u7a0b\u5e8f\u662f\u5728\u6267\u884c C \u4ee3\u7801\uff0c\u4ee5\u53ca\u5b83\u62e5\u6709\u4e00\u4e2a\u5408\u6cd5\u7684\u6808\u3002</p> <p>\u6211\u4eec\u5f53\u7136\u5e0c\u671b Trap \u5904\u7406\u51fd\u6570\u80fd\u662f C \u8bed\u8a00\u5199\u7684\uff0c\u800c\u8fd9\u4e5f\u9700\u8981\u4e00\u4e2a\u5408\u6cd5\u7684\u6808\u7a7a\u95f4\u3002  \u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u501f\u7528\u539f\u6765\u6b63\u5728\u6267\u884c\u7684\u7a0b\u5e8f\u6240\u7528\u7684\u6808\u7a7a\u95f4 \uff0c\u53ea\u8981\u6211\u4eec\u786e\u4fdd sp \u6307\u9488\u80fd\u88ab\u590d\u539f\u5373\u53ef\u3002</p> <p>\u989d\u5916\u7684\uff0cC \u8bed\u8a00\u7f16\u8bd1\u5668\u5728\u4f7f\u7528\u6808\u65f6\uff0c\u501f\u591a\u5c11\u7a7a\u95f4\u5c31\u4f1a\u8fd8\u591a\u5c11\u7a7a\u95f4\u3002 \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u8bc1\u6211\u4eec\u5728\u6c47\u7f16\u5c42\u9762\u5bf9\u6808\u7684\u64cd\u4f5c\u662f\u5e73\u8861\u7684\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u73b0\u6709\u7684\u6808\u8fdb\u884c\u4e0a\u4e0b\u6587\u7684\u4fdd\u5b58\uff0c\u5269\u4e0b\u7684\u5c31\u53ef\u4ee5\u653e\u5fc3\u5730\u4ea4\u7ed9\u7f16\u8bd1\u5668\u4e86\u3002</p> <p>\u4e0a\u4e0b\u6587 (Context)</p> <p>Trap \u7684\u5904\u7406\u9700\u8981\u201c\u653e\u4e0b\u5f53\u524d\u7684\u4e8b\u60c5\u4f46\u4e4b\u540e\u8fd8\u80fd\u56de\u6765\u63a5\u7740\u4e4b\u524d\u5f80\u4e0b\u505a\u201d\uff0c\u5bf9\u4e8eCPU\u6765\u8bf4\uff0c\u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u628a\u539f\u5148\u7684\u5bc4\u5b58\u5668\u4fdd\u5b58\u4e0b\u6765\uff0c\u505a\u5b8c\u5176\u4ed6\u4e8b\u60c5\u628a\u5bc4\u5b58\u5668\u6062\u590d\u56de\u6765\u5c31\u53ef\u4ee5\u4e86\u3002</p> <p>\u5728\u521a\u521a\u8fdb\u5165 Trap \u5904\u7406\u51fd\u6570\u65f6\uff0c31 \u4e2a GPR\uff08General Purpose Register\uff0c\u901a\u7528\u5bc4\u5b58\u5668\uff09 x1-x31 \u5747\u662f\u539f\u6765\u7684\u7a0b\u5e8f\u6b63\u5728\u4f7f\u7528\u4e2d\u7684\u5bc4\u5b58\u5668\u3002Trap Handler \u9700\u8981\u4fdd\u8bc1\u5728\u63a7\u5236\u6d41\u56de\u5230\u539f\u5148\u7684\u7a0b\u5e8f\u540e\uff0c GPR \u5e94\u8be5\u4e0e\u4ea7\u751f Trap \u524d\u4e00\u81f4\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e9b\u5185\u5b58\u7a7a\u95f4\u6765\u4fdd\u5b58\u8fd9\u4e9b\u5bc4\u5b58\u5668\uff0c\u5e76\u5728\u4ece Trap \u4e2d\u8fd4\u56de\u65f6\u6062\u590d\u5b83\u4eec\u539f\u6765\u7684\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e9b\u5bc4\u5b58\u5668\u79f0\u4e3a\u539f\u5148\u7a0b\u5e8f\u7684 Context (\u4e0a\u4e0b\u6587) \u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u4f7f\u7528\u6c47\u7f16\u5b9e\u73b0\u4e0a\u4e0b\u6587\u5207\u6362(context switch)\u673a\u5236\uff0c\u8fd9\u5305\u542b\u4e24\u6b65\uff1a</p> <ul> <li>\u4fdd\u5b58CPU\u7684\u5bc4\u5b58\u5668\uff08\u4e0a\u4e0b\u6587\uff09\u5230\u5185\u5b58\u4e2d\uff08\u6808\u4e0a\uff09</li> <li>\u4ece\u5185\u5b58\u4e2d\uff08\u6808\u4e0a\uff09\u6062\u590dCPU\u7684\u5bc4\u5b58\u5668</li> </ul> <p>\u63a5\u7740\uff0c\u6211\u4eec\u5c06 <code>a0</code> \u8bbe\u7f6e\u4e3a <code>sp</code>\uff0c\u8c03\u7528 <code>kernel_trap</code> \uff0c\u8fdb\u5165 C \u4ee3\u7801\u7ee7\u7eed\u5904\u7406 Trap\u3002</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // ...\n\n    mv a0, sp   // make a0 point to the ktrapframe structure\n    call kernel_trap\n\n    // ...\n</code></pre> <p>\u7531\u4e8e RISC-V \u4f7f\u7528 a0 \u4f5c\u4e3a\u4f20\u9012\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u5bc4\u5b58\u5668\uff0ca0 \u6b64\u65f6\u6307\u5411\u6808\u4e0a\u7684 <code>struct ktrapframe</code> \u7ed3\u6784\u4f53\uff0c\u6240\u4ee5 <code>kernel_trap</code> \u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\u5373\u4e3aa0\u7684\u503c <code>struct ktrapframe* ktf</code>\u3002</p> <pre><code>void kernel_trap(struct ktrapframe *ktf) {\n    assert(!intr_get());\n\n    if ((r_sstatus() &amp; SSTATUS_SPP) == 0)\n        panic(\"kerneltrap: not from supervisor mode\");\n\n    uint64 cause = r_scause();\n    uint64 exception_code = cause &amp; SCAUSE_EXCEPTION_CODE_MASK;\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        // handle interrupt\n        switch (exception_code) {\n            case SupervisorTimer:\n                debugf(\"s-timer interrupt, cycle: %d\", r_time());\n                set_next_timer();\n                break;\n            case SupervisorExternal:\n                debugf(\"s-external interrupt.\");\n                plic_handle();\n                break;\n            default:\n                errorf(\"unhandled interrupt: %d\", cause);\n                goto kernel_panic;\n        }\n    } else {\n        // kernel exception, unexpected.\n        goto kernel_panic;\n    }\n\n    assert(!intr_get());\n    return;\n\nkernel_panic:\n    panicked = 1;\n\n    errorf(\"=========== Kernel Panic ===========\");\n    print_sysregs(true);\n    print_ktrapframe(ktf);\n\n    panic(\"kernel panic\");\n}\n</code></pre> <p>\u5728\u8fdb\u5165 <code>kernel_trap</code> \u65f6\uff0cCPU \u7684\u4e2d\u65ad\u4f4d <code>sstatus.SIE</code> \u5e94\u8be5\u662f\u4fdd\u6301\u5173\u95ed\u7684\uff0c\u5e76\u4e14 Previous Privilege \u5e94\u8be5\u662f Supervisor \u6a21\u5f0f\uff0c\u6211\u4eec\u4f7f\u7528 assert\uff08\u65ad\u8a00\uff09\u6765\u786e\u4fdd\u4ee3\u7801\u662f\u6309\u7167\u9884\u671f\u6267\u884c\u7684\u3002</p> <p>\u4e3a\u4ec0\u4e48\u6211\u4eec\u8981\u5199 assert</p> <p>\u65ad\u8a00\uff08Assertions\uff09\u5728\u64cd\u4f5c\u7cfb\u7edf\u5f00\u53d1\u4e2d\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u8c03\u8bd5\u548c\u9519\u8bef\u68c0\u6d4b\u5de5\u5177\u3002 \u65ad\u8a00\u53ef\u4ee5\u5e2e\u52a9\u5f00\u53d1\u8005\u5728\u7a0b\u5e8f\u6267\u884c\u7684\u65e9\u671f\u9636\u6bb5\u6355\u83b7\u53ef\u80fd\u7684\u903b\u8f91\u9519\u8bef\u3002 \u901a\u8fc7\u5728\u4ee3\u7801\u4e2d\u63d2\u5165\u65ad\u8a00\uff0c\u6211\u4eec\u53ef\u4ee5\u7acb\u5373\u68c0\u6d4b\u5230\u4e0d\u7b26\u5408\u9884\u671f\u7684\u72b6\u6001\u6216\u6761\u4ef6\uff0c\u800c\u4e0d\u662f\u7b49\u5230\u7a0b\u5e8f\u5d29\u6e83\u6216\u4ea7\u751f\u4e0d\u53ef\u9884\u6d4b\u7684\u884c\u4e3a\u540e\uff0c\u518d\u6765\u731c\u6d4b\u95ee\u9898\u53ef\u80fd\u51fa\u5728\u54ea\u91cc\u3002</p> <p>\u6362\u53e5\u8bdd\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u5728\u67d0\u4e2a\u70b9\u4e0a\u80fd\u63a2\u6d4b\u5230\u7a0b\u5e8f\u7684\u8fd0\u884c\u72b6\u6001\u504f\u79bb\u4e86\u6211\u4eec\u7684\u9884\u671f\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u8ba9\u5b83\u5c3d\u91cf\u5d29\u6e83\u5728\u7b2c\u4e00\u73b0\u573a\uff0c\u4ee5\u63d0\u4f9b\u66f4\u52a0\u6709\u6548\u7684\u8c03\u8bd5\u4fe1\u606f\u3002</p> <p>\u7136\u540e\uff0c\u6211\u4eec\u8bfb\u53d6 <code>scause</code> \u5bc4\u5b58\u5668\u5224\u65ad Trap \u662f\u56e0\u4e3a\u4e2d\u65ad\u8fd8\u662f\u5f02\u5e38\u9677\u5165\u7684\uff0c\u5e76\u4e14\u6211\u4eec\u5904\u7406\u65f6\u949f\u4e2d\u65ad\u548c PLIC \u7ba1\u7406\u7684\u5916\u90e8\u4e2d\u65ad\uff0c\u5bf9\u4e8e\u5176\u4ed6\u9884\u671f\u4e4b\u5916\u7684 Trap \u539f\u56e0\uff0c\u6211\u4eec\u53ef\u4ee5\u6253\u5370\u6808\u4e0a\u4fdd\u5b58\u7684 <code>ktramframe</code> \u7ed3\u6784\u4f53\u5e2e\u52a9\u8c03\u8bd5\uff0c\u5e76\u4f7f\u7528 <code>panic</code> \u5b8f\u8868\u793a\u5185\u6838\u9047\u5230\u4e86\u4e0d\u53ef\u6062\u590d\u7684\u9519\u8bef\u5e76\u505c\u673a\u3002</p> <p>\u6700\u540e\uff0c\u6211\u4eec\u4ece <code>kernel_trap</code> \u79bb\u5f00\uff0c\u56de\u5230 <code>kernel_trap_entry</code> \u7ee7\u7eed\u6267\u884c\u3002</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // ...\n    call kernel_trap\n\n    // restore all registers\n    //ld x0, 0x00(sp) // do not write to x0\n    ld x1, 0x08(sp)\n    ld x2, 0x10(sp)\n    // ...\n    ld x30, 0xf0(sp)\n    ld x31, 0xf8(sp)\n\n    // restore stack\n    add sp, sp, 0x100\n\n    // return from trap\n    sret\n</code></pre> <p>\u4ece C \u8bed\u8a00\u73af\u5883\u9000\u51fa\u540e\uff0c\u6211\u4eec\u4ece\u6808\u4e0a\u6062\u590d\u6240\u6709\u901a\u7528\u5bc4\u5b58\u5668\uff0c\u6062\u590d\u6808\u7a7a\u95f4\uff0c\u7136\u540e\u4f7f\u7528 <code>sret</code> \u9000\u51fa Trap\u3002</p> <p>sret \u5c06\u628a <code>sepc</code> \u7684\u503c\u8fd8\u539f\u81f3 PC \u5bc4\u5b58\u5668</p> <p>\u4e0b\u56fe\u5c55\u793a\u4e86 \u8fdb\u5165 Trap\uff0c\u6784\u9020 ktrapframe\uff0c\u7136\u540e\u6062\u590d\u5e76 sret \u8fc7\u7a0b\u7684\u6808\u7ed3\u6784\uff1a</p> <p></p>"},{"location":"lab/xv6lab-interrupts/#lab","title":"Lab \u5b9e\u9a8c\u62a5\u544a","text":"<p>Question 1</p> <p>\u7ed3\u5408\u672c\u5468\u7684\u5b9e\u9a8c\u5185\u5bb9\u3002\u901a\u8fc7 gdb \u8c03\u8bd5\u5668\u6253\u5370\u51fa\u4e0a\u4e00\u5468\u5b9e\u9a8c\u4ee3\u7801\u8fd0\u884c\u5230 main \u51fd\u6570\u65f6 <code>stvec</code> \u7684\u503c\u3002\u5e76\u7ed3\u5408\u8fd9\u4e2a\u503c\u8fdb\u4e00\u6b65\u89e3\u91ca\u4e3a\u4f55\u8bfb\u53d6 CSR mvendorid\u7684\u503c\u5931\u8d25\u540e\u4f1a\u64cd\u4f5c\u7cfb\u7edf\u7684\u8868\u73b0\u662f\u65e0\u9650\u91cd\u542f\u3002</p> <p>\u4f60\u53ef\u80fd\u9700\u8981\u7528\u5230gdb\u6307\u4ee4 <code>b main</code> (\u5728 main \u51fd\u6570\u5165\u53e3\u6253\u65ad\u70b9), <code>c</code> (continue, \u7ee7\u7eed\u6267\u884c) \u548c <code>print $stvec</code> \u3002</p> <p>Question 2</p> <p>\u5728 <code>main.c</code> \u4e2d\uff0c <code>ebreak</code> \u6307\u4ee4\u4f1a\u4e3b\u52a8\u89e6\u53d1\u4e00\u6b21\u5f02\u5e38\u3002\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u5185\u6838\uff0c\u4f60\u5c06\u4f1a\u770b\u5230 <code>Kernel Panic</code>\uff0c\u4ee5\u53ca\u5b83\u6253\u5370\u7684\u4e00\u4e9b CSR.</p> <p>\u5bf9\u7167 RISC-V \u7279\u6743\u7ea7\u624b\u518c Section <code>4.1.1 Supervisor Status Register (sstatus)</code>\uff0c\u67e5\u9605 Kernel Panic \u65e5\u5fd7\u4e2d\u6253\u5370\u7684 CSR\uff0c\u8bf7\u4f60\u4ece sstatus \u7684\u503c\u4e2d\u63d0\u53d6\u7684 SIE, SPIE, SPP \u4e09\u4e2a bit \u7684\u503c\uff0c\u5e76\u89e3\u91ca\u5176\u610f\u601d\u3002</p> <p>\u5bf9\u7167 scause \u4e2d\u5173\u4e8e Interrupt/Exception Code \u7684\u63cf\u8ff0\uff0c \u5199\u4e0b\u5f53\u524d scause \u7684\u610f\u601d \u3002</p> <p>\u63a5\u7740\uff0c\u5728 <code>trap.c</code> \u4e2d\u7684 <code>kernel_trap</code> \u51fd\u6570\u4e2d\uff0c\u4fee\u6539 else \u5206\u652f\uff0c\u4f7f <code>ebreak</code> \u9020\u6210\u7684\u5f02\u5e38\u4e0d\u8981\u8fdb\u5165 <code>kernel_panic</code> \u6807\u7b7e\uff0c\u800c\u662f\u9000\u51fa <code>kernel_trap</code> \u5904\u7406\u51fd\u6570\uff1a</p> <pre><code>if (cause &amp; SCAUSE_INTERRUPT) {\n    // handle interrupt\n    // ...\n} else {\n    if (exception_code == ?) {\n        debugf(\"breakpoint\");\n    } else {\n        // kernel exception, unexpected.\n        goto kernel_panic;\n    }\n}\n</code></pre> <p>\u5199\u4e0b ? \u5904\u5e94\u8be5\u586b\u4ec0\u4e48\u3002\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u5185\u6838\uff0c\u4f60\u89c2\u5bdf\u5230\u4e86\u4ec0\u4e48\uff1f\u5e76\u89e3\u91ca\u8fd0\u884c\u7ed3\u679c\u3002</p> <p>Question 3</p> <p>RISC-V \u7279\u6743\u7ea7\u624b\u518c\uff0cSection <code>3.3.1 Environment Call and Breakpoint</code> \u89e3\u91ca <code>ecall</code> \u548c <code>ebreak</code> \u6307\u4ee4\u5982\u4e0b\uff1a</p> <p>ECALL and EBREAK cause the receiving privilege mode\u2019s epc register to be set to the address of the ECALL or EBREAK instruction itself, not the address of the following instruction. As ECALL and EBREAK cause synchronous exceptions, they are not considered to retire, and should not increment the minstret CSR.</p> <p>\u8bf7\u4f60\u5728 <code>debugf(\"breakpoint\");</code> \u540e\u9762\u52a0\u4e00\u6761\u4ee3\u7801\uff0c\u5b9e\u73b0\u5728\u9000\u51fa Trap \u540e\u80fd\u6267\u884c\u540e\u7eed\u7684\u6307\u4ee4\uff0c\u800c\u4e0d\u662f\u91cd\u590d\u6267\u884c <code>ebreak</code>\u3002</p> <p>Note: \u4f60\u53ef\u4ee5\u5728 <code>build/kernel.asm</code> \u91cc\u9762\u67e5\u9605\u6574\u4e2a\u5185\u6838\u955c\u50cf\u7684\u53cd\u6c47\u7f16\u7ed3\u679c\uff0c\u5373\u6bcf\u4e2a\u5730\u5740\u4e0a\u662f\u4ec0\u4e48\u6307\u4ee4\u3002</p> <p>Note2: \u4f60\u53ef\u4ee5\u4f7f\u7528\u5728 <code>riscv.h</code> \u5934\u6587\u4ef6\u4e2d\u5b9a\u4e49\u7684\u51fd\u6570 <code>w_sepc()</code> \u548c <code>r_sepc()</code> \u8bfb\u5199 <code>sepc</code> \u5bc4\u5b58\u5668\u3002</p>"},{"location":"lab/xv6lab-interrupts/#interrupt","title":"Interrupt","text":"<p>RISC-V \u89c4\u8303\u5b9a\u4e49\u4e86\u6bcf\u4e2a Hart \u7684 M/S mode \u5404\u6709\u4e09\u79cd\u6807\u51c6\u7684\u4e2d\u65ad\uff1a\u65f6\u949f\u4e2d\u65ad (Timer)\u3001\u8f6f\u4ef6\u4e2d\u65ad (Software) \u548c\u5916\u90e8\u4e2d\u65ad (External)\u3002</p>"},{"location":"lab/xv6lab-interrupts/#interrupt_1","title":"\u4ec0\u4e48\u65f6\u5019\u80fd\u5904\u7406 Interrupt","text":"<p>RISC-V \u5b9a\u4e49\u4e86\u4e09\u79cd\u6807\u51c6\u7684\u4e2d\u65ad\uff1aSoftware Interrupt, Timer Interrupt \u548c External Interrupt\uff0c\u5bf9\u5e94 scause \u4e2d\u7684 Exception Code 1, 5, 9\uff0c \u5bf9\u5e94 sip/sie \u4e2d\u7684\u7b2c 1, 5, 9 bit\u3002</p> <p>\u5f53 Interrupt \u5230\u6765\u65f6\uff0cRISC-V \u6838\u5fc3\u4f1a\u68c0\u6d4b\u5f53\u524d\u662f\u5426\u80fd\u591f\u5904\u7406\u4e2d\u65ad\uff0c\u5373\u662f\u5426\u80fd\u8fdb\u5165 Trap\uff1a</p> <ul> <li>(\u5f53\u524d\u8fd0\u884c\u5728 S \u6a21\u5f0f\uff0c\u4e14 <code>sstatus.SIE</code> == 1) \u6216\u8005 \u5f53\u524d\u8fd0\u884c\u5728 U \u6a21\u5f0f\u3002</li> <li>\u4e2d\u65ad\u7c7b\u578b bit i \u5728 <code>sie</code> \u548c <code>sip</code> \u4e2d\u5747\u4e3a 1.</li> </ul> <p>An interrupt i will trap to S-mode if both of the following are true:</p> <p>(a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or the current privilege mode has less privilege than S-mode; and</p> <p>(b) bit i is set in both sip and sie.</p> <p>\u5f53 Software/Timer/External Interrupt \u5230\u8fbe CPU \u65f6\uff0c<code>sip</code> \u4e2d\u5bf9\u5e94\u7684 bit \u4f1a\u88ab\u62c9\u9ad8\uff0c\u7136\u540e CPU \u4f1a\u6309\u7167\u5982\u4e0a\u6761\u4ef6\u8fdb\u884c\u68c0\u67e5\uff0c\u5982\u679c\u7b26\u5408\u6761\u4ef6\uff0c\u5219\u4f1a\u8fdb\u5165 Trap\u3002</p>"},{"location":"lab/xv6lab-interrupts/#_3","title":"\u65f6\u949f\u4e2d\u65ad","text":"<p>\u65f6\u949f\u4e2d\u65ad\u53ef\u4ee5\u7406\u89e3\u4e3a\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\u6267\u884c\u4e00\u6b21\u7684\u7a0b\u5e8f\u3002\u5373\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\uff0c\u4f1a\u56fa\u5b9a\u89e6\u53d1\u4e00\u6b21\u7684\u4e2d\u65ad\u3002\u5728\u65f6\u949f\u4e2d\u65ad\u7684\u5904\u7406\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5b8c\u6210\u8fdb\u7a0b\u8c03\u5ea6\u7b49\u64cd\u4f5c\u3002</p> <p>RISC-V \u5e73\u53f0\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5b9e\u65f6\u7684\u65f6\u95f4\u8ba1\u6570\u5668: <code>time</code> \u5bc4\u5b58\u5668\uff0c\u8be5\u5bc4\u5b58\u5668\u4ee5\u6052\u5b9a\u7684\u9891\u7387\u589e\u957f\uff0c\u5e76\u4e14\u5728\u6240\u6709\u6838\u5fc3\u4e4b\u95f4\u5171\u4eab\u3002\u53e6\u5916\uff0cRISC-V \u5bf9\u6bcf\u4e2a\u6838\u5fc3\u7684\u63d0\u4f9b\u4e86\u4e00\u4e2a <code>timecmp</code> \u5bc4\u5b58\u5668\uff0c\u6bcf\u5f53 <code>time &gt;= timecmp</code> \u65f6\uff0c\u8be5\u6838\u5fc3\u5c31\u4f1a\u62c9\u9ad8\u65f6\u949f\u4e2d\u65ad\u7684 <code>sip.STIP</code> bit\uff0c\u5982\u679c\u6838\u5fc3\u6ee1\u8db3\u8fdb\u5165\u4e2d\u65ad Trap \u7684\u6761\u4ef6\uff0c\u5219\u4f1a\u8fdb\u5165 Trap \u3002</p> <p>SBI \u63d0\u4f9b\u4e86\u4e00\u4e2a SBI call\uff1a<code>SBI_SET_TIMER</code> \u5141\u8bb8 Supervisor \u8f6f\u4ef6\u8bbe\u7f6e <code>timecmp</code> \u5bc4\u5b58\u5668\u3002\u5728\u5df2\u77e5 time \u5bc4\u5b58\u5668\u7684\u589e\u957f\u9891\u7387\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u4e00\u5b9a\u65f6\u95f4 (\u5982 10ms) \u5185 time \u4f1a\u589e\u957f\u591a\u5c11\uff0c\u5e76\u8bbe\u7f6e timecmp \u4e3a\u8be5\u503c\uff0c\u6211\u4eec\u5373\u53ef\u5728 10ms \u540e\u6536\u5230\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u3002\u5728\u6bcf\u6b21\u8fdb\u5165\u65f6\u949f\u4e2d\u65ad\u65f6\uff0c\u6211\u4eec\u518d\u6b21\u8ba1\u7b97\u5e76\u8bbe\u7f6e\u4e0b\u6b21\u7684 timecmp\uff0c\u7531\u6b64\u5b9e\u73b0\u6bcf 10ms \u6536\u5230\u4e00\u6b21\u65f6\u95f4\u4e2d\u65ad\u3002</p> <p>\u65f6\u949f\u90e8\u5206\u7684\u4ee3\u7801\u4f4d\u4e8e <code>timer.c</code>\u3002</p> <p>\u5728\u521d\u59cb\u5316\u65f6\u949f\u4e2d\u65ad\u65f6\uff0c\u6211\u4eec\u901a\u8fc7 SBI call <code>SET_TIMER</code> \u8bbe\u7f6e <code>timecmp</code>\uff0c\u5e76\u5728 <code>sie</code> \u4e2d\u542f\u7528\u65f6\u949f\u4e2d\u65ad <code>SIE_STIE</code>\u3002</p> <p>\u5728 <code>kernel_trap</code> \u4e2d\u5904\u7406\u65f6\u949f\u4e2d\u65ad\u65f6\uff0c\u6211\u4eec\u8ba1\u7b97\u4e0b\u4e00\u6b21\u7684 <code>timecmp</code>\uff0c\u5e76\u518d\u6b21 SBI call <code>SET_TIMER</code>\uff0c\u5faa\u73af\u5f80\u590d\u3002</p> <p>Lab \u5b9e\u9a8c\u62a5\u544a - Question 4</p> <p>\u5c06 <code>main.c</code> \u4e2d\u7684 <code>asm volatile(\"ebreak\" ::: \"s11\");</code> \u4e00\u884c\u4ee3\u7801\u6ce8\u91ca\u6389\uff0c\u5e76\u5c06 <code>intr_on()</code> \u53d6\u6d88\u6ce8\u91ca\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u540e\u89c2\u5bdf\u6bcf\u6b21\u89e6\u53d1\u65f6\u949f\u4e2d\u65ad\u65f6\u7684 cycle \u8bfb\u6570\u3002</p> <p>\u6ce8\u91ca\u6389 <code>trap.c</code> \u4e2d <code>kernel_trap</code> \u8c03\u7528 <code>set_next_timer()</code>\uff0c\u5e76\u518d\u6b21 <code>make run</code> \u89c2\u5bdf\u6bcf\u6b21\u89e6\u53d1\u65f6\u949f\u4e2d\u65ad\u65f6\u7684 cycle \u8bfb\u6570\u3002</p> <p>\u8bf7\u89e3\u91ca\u73b0\u8c61\u548c\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u6837\u3002</p> <p>mtimecmp \u548c stimecmp</p> <p>\u5b9e\u9645\u4e0a\uff0c\u6807\u51c6\u7684 RISC-V \u7279\u6743\u7ea7\u624b\u518c\u53ea\u5b9a\u4e49\u4e86 M-mode \u7684 <code>mtimecmp</code> \u5bc4\u5b58\u5668\u3002S mode \u7684\u8f6f\u4ef6\u9700\u8981\u4f7f\u7528 SBI call \u8bbe\u7f6e\u65f6\u949f\u4e2d\u65ad\uff0c\u8fd9\u5b9e\u9645\u4e0a\u662f\u901a\u8fc7 OpenSBI \u8bbe\u7f6e <code>mtimecmp</code> \uff0c\u5e76\u5728 <code>mtvec</code> \u4e2d\u5c06 <code>STIP</code> \u7f6e 1 \u6765\u5b9e\u73b0\u4e3a S mode \u8bbe\u7f6e\u65f6\u949f\u4e2d\u65ad\u7684\u3002\u8fd9\u4e5f\u4f53\u73b0\u4e86 RISC-V \u786c\u4ef6\u8bbe\u8ba1\u4e0a\u80fd\u4e0d\u7ba1\u5c31\u4e0d\u7ba1\u7684\u539f\u5219\uff0c\u4ee5\u53ca M mode \u901a\u8fc7 emulate \u6765\u4e3a\u4e0a\u5c42\u8f6f\u4ef6\u6a21\u62df\u884c\u4e3a\u3002</p> <p>\u5b9e\u9645\u4e0a\uff0c\u7279\u6743\u7ea7\u5207\u6362\u662f\u4e00\u4e2a\u76f8\u5f53\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u4e3a\u4e86\u6539\u8fdb Supervisor \u65f6\u95f4\u4e2d\u65ad\u7684\u6027\u80fd\uff0cRISC-V \u89c4\u5b9a\u4e86 Sstc \u6269\u5c55\uff0c\u521b\u5efa\u4e86 <code>stimecmp</code> CSR\uff0c\u5141\u8bb8 Supervisor \u76f4\u63a5\u8bbe\u7f6e\u5176\u65f6\u949f\u4e2d\u65ad\u8ba1\u6570\u5668\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u5728 QEMU \u7684 CPU flags \u4e2d\u5c06 Sstc \u6269\u5c55\u7981\u7528\u6389\uff08<code>-cpu rv64,sstc=off</code>\uff09\uff0c\u6765\u89c2\u5bdf OpenSBI \u5728\u6ca1\u6709 Sstc \u65f6\u7684\u884c\u4e3a\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u547d\u4ee4 <code>qemu-system-riscv64 -nographic -machine virt -cpu rv64,svadu=off,sstc=off -m 512 -kernel build/kernel  -S -gdb tcp::3333</code> \u6765\u542f\u52a8\u4e00\u4e2a\u5e26\u8c03\u8bd5\u5668\u7684 qemu\u3002</p> <p>\u6302\u8f7d GDB \u540e\uff0c\u6211\u4eec\u662f\u7528 <code>c</code> (continue) \u547d\u4ee4\u7ee7\u7eed\u6267\u884c\uff0c\u5f53 QEMU \u8f93\u51fa\u51fa\u73b0 <code>kernel_trap: s-timer interrupt</code> \u65f6\uff0c\u5728 GDB \u7ec8\u7aef\u4e2d\u6309 Ctrl-C \u4e2d\u65ad\u6267\u884c\uff0c\u4f7f\u7528<code>print $mtvec</code> \u5f97\u5230 M mode \u7684\u4e2d\u65ad\u5411\u91cf\u5730\u5740\uff0c\u5e76\u4f7f\u7528 <code>b *0x800004f0</code> \u5728\u4e2d\u65ad\u5411\u91cf\u4e0a\u6253\u65ad\u70b9\u3002</p> <p>\u4f7f\u7528 <code>c</code> \u7ee7\u7eed\u6267\u884c\uff0c\u5728\u547d\u4e2d <code>0x800004f0</code> \u7684\u65ad\u70b9\u65f6\uff0c\u6211\u4eec\u4f7f\u7528 <code>print $mcause</code> \u67e5\u8be2 M mode \u7684 Trap \u539f\u56e0\u3002</p> <p>\u6211\u4eec\u5e94\u8be5\u4f1a\u770b\u5230\uff0c\u5728\u6ca1\u6709 <code>Sstc</code> \u65f6\uff0cmcause \u4f1a\u6709\u4e24\u4e2a\u503c <code>0x8000000000000007</code> \u548c <code>0x9</code>\uff0c\u5206\u522b\u5bf9\u5e94\u7740 M-mode Timer Interrupt \u548c\u6765\u81ea S-mode \u7684 <code>ecall</code>\u3002\u5982\u679c\u6709 <code>Sstc</code> \u6269\u5c55\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0 <code>mcause</code> \u53ea\u4f1a\u6709 <code>0x9</code> \u4e00\u79cd\u503c\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528 SBI_SET_TIMER \u65f6\uff0cOpenSBI \u4f1a\u76f4\u63a5\u8bbe\u7f6e <code>stimecmp</code> \u5bc4\u5b58\u5668\uff0c\u907f\u514d\u4e86 S mode \u7684\u65f6\u949f\u4e2d\u65ad\u901a\u8fc7 OpenSBI \u8def\u7531\u3002</p>"},{"location":"lab/xv6lab-interrupts/#_4","title":"\u5916\u90e8\u4e2d\u65ad","text":"<p>\u6211\u4eec\u4e4b\u524d\u63cf\u8ff0\u4e2d\u65ad\u4e0e Trap \u65f6\uff0c\u6211\u4eec\u8bf4\u7684\u662f \"\u5f53 Interrupt \u5230\u6765\u65f6\uff0cRISC-V \u6838\u5fc3...\"\u3002\u6240\u4ee5\uff0c\u5916\u90e8\u4e2d\u65ad\u662f\u5982\u4f55\u6765\u5230\u6bcf\u4e2a\u6838\u5fc3\u7684\uff1f</p> <p>PLIC (Platform-Level Interrupt Controller) \u662f RISC-V \u5e73\u53f0\u4e0a\u7528\u4e8e\u7ba1\u7406\u5916\u90e8\u4e2d\u65ad\u7684 IP \u6838\uff0c\u6bcf\u4e2a RISC-V \u5e73\u53f0\u62e5\u6709\u591a\u4e2a\u6838\u5fc3 (Hart)\uff0c\u800c\u6bcf\u4e2a\u5e73\u53f0\u4e00\u822c\u53ea\u6709\u4e00\u4e2a PLIC\u3002</p> <p>\u7b80\u800c\u8a00\u4e4b\uff0c\u6bcf\u4e2a\u5916\u8bbe\u5747\u4f1a\u5411 PLIC \u901a\u62a5\u81ea\u5df1\u6709\u4e2d\u65ad\u9700\u8981\u5904\u7406\uff0c\u800c\u6bcf\u4e2a\u8bbe\u5907\u7684\u4e2d\u65ad\u5747\u6709\u4e00\u4e2a\u4e2d\u65ad\u53f7\uff0cPLIC \u4f1a\u6839\u636e\u9884\u5148\u914d\u7f6e\u7684\u89c4\u5219\uff0c\u5c06\u8be5\u4e2d\u65ad\u8def\u7531 (Routing) \u7ed9\u67d0(\u4e9b)\u6838\u5fc3\u5904\u7406\uff0c\u5e76\u62c9\u8d77\u8be5\u6838\u5fc3\u7684 mip.MEIP/sip.SEIP \u4ee5\u8bf7\u6c42\u4e2d\u65ad\u6838\u5fc3\u3002</p> <p>\u6838\u5fc3\u9700\u8981\u5411 PLIC \u58f0\u660e (Claim) \u81ea\u5df1\u6765\u8d1f\u8d23\u5904\u7406\u8fd9\u4e2a\u4e2d\u65ad\uff0c\u5e76\u5728\u5904\u7406\u5b8c\u6bd5\u540e\u58f0\u660e\u81ea\u5df1\u5b8c\u6210\u4e86\u8fd9\u4e2a\u4e2d\u65ad\u7684\u5904\u7406 (Complete)\u3002</p> <p>Specification: https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc</p> <p>AMD64 \u548c Aarch64</p> <p>x86 (IA32)\uff0cx86-64 (AMD64) \u548c ARM \u5e73\u53f0\u4e0a\u4e5f\u6709\u7c7b\u4f3c\u7684\u5168\u5c40\u4e2d\u65ad\u5904\u7406\u5668\uff1aPIC, APIC, GIC</p>"},{"location":"lab/xv6lab-interrupts/#plic","title":"PLIC \u7ed3\u6784","text":"<p>PLIC \u53ef\u4ee5\u7ba1\u7406 1~1023 \u4e2a\u4e2d\u65ad\u6e90\uff0c\u6bcf\u4e2a\u4e2d\u65ad\u6e90\u62e5\u6709\u4e00\u4e2a\u4f18\u5148\u7ea7 Priority \u3002PLIC \u5c06\u80fd\u591f\u63a5\u6536\u4e2d\u65ad\u7684\u5bf9\u8c61 (Interrupt Targets) \u79f0\u4e3a Hart Context (where a hart context is a given privilege mode on a given hart)\uff0c\u6bcf\u4e2a Context \u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u4e8c\u5143\u7ec4 (Hart ID, Privilege Level) \u5bf9\u5e94\u7740\u4e00\u4e2a Hart \u548c\u4e00\u4e2a\u7279\u6743\u7ea7\u522b\u3002\u7531\u4e8e\u76ee\u524d RISC-V \u6ca1\u6709\u89c4\u5b9a User-Mode Interrupt\uff0c\uff08RISC-V privilege spec \u53ea\u89c4\u5b9a\u4e86 mie/mip \u548c sie/sip\uff0c\u5bf9\u5e94\u7740 Machine Mode \u548c Supervisor Mode \u7684\u4e2d\u65ad\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6bcf\u4e2a\u6838\u5fc3\u62e5\u6709\u4e24\u4e2a Context\uff0c\u5206\u522b\u5bf9\u5e94\u7740\u8be5 Hart \u7684 M mode \u548c S mode \u7684\u5916\u90e8\u4e2d\u65ad\u3002</p> <p>PLIC \u80fd\u591f\u7ba1\u7406 0~15871 \u4e2a Context\uff0c\u80fd\u8bbe\u7f6e\u6bcf\u4e2a\u4e2d\u65ad\u6e90\u662f\u5426\u5141\u8bb8\u8def\u7531\u81f3\u67d0\u4e2a Context (Enabled Bit)\uff0c\u6bcf\u4e2a Context \u80fd\u63a5\u6536\u7684 Priority Threshold\u3002</p> <p>PLIC \u4f1a\u62c9\u8d77 Hart \u7684 mip.MEIP/sip.SEIP bit\uff0c\u800c\u8be5 hart \u662f\u5426\u8fdb\u5165 Interrupt \u7684 Trap \u7531\u4e0a\u8ff0 <code>\u8fdb\u5165\u4e2d\u65ad\u7684\u6761\u4ef6</code> \u51b3\u5b9a\u3002</p> <p></p>"},{"location":"lab/xv6lab-interrupts/#memory-mapped-register","title":"Memory-Mapped Register","text":"<p>PLIC \u4f7f\u7528 Memory-Mapped Register \u5411\u7cfb\u7edf\u66b4\u9732\u7ba1\u7406\u63a5\u53e3\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u5bc4\u5b58\u5668\uff0c\u6211\u4eec\u4f7f\u7528\u504f\u79fb\u91cf\u6765\u5b9a\u4f4d\u6bcf\u4e2a\u5bc4\u5b58\u5668\u3002\u901a\u5e38\uff0c\u8fd9\u79cd IP \u6838\u6709\u7740\u56fa\u5b9a\u7684\u57fa\u5730\u5740\uff0c\u5728 QEMU \u4e0a\uff0c\u5bf9\u4e8e PLIC \u8fd9\u4e2a\u57fa\u5730\u5740\u662f <code>0x0c00_0000</code>\u3002</p> <p>Memory-Mapped Register, MMIO</p> <p>Memory Mapped Register\uff08\u5185\u5b58\u6620\u5c04\u5bc4\u5b58\u5668\uff09\u662f\u4e00\u79cd\u5728\u8ba1\u7b97\u673a\u4f53\u7cfb\u7ed3\u6784\u4e2d\u7528\u4e8e\u5916\u56f4\u8bbe\u5907\u548c\u786c\u4ef6\u63a7\u5236\u7684\u91cd\u8981\u6280\u672f\u3002</p> <p>Memory-Mapped Register \u662f\u6307\u5c06\u786c\u4ef6\u8bbe\u5907\u7684\u5bc4\u5b58\u5668\u76f4\u63a5\u6620\u5c04\u5230\u5904\u7406\u5668\u7684\u5185\u5b58\u5730\u5740\u7a7a\u95f4\u4e2d\u3002\u8fd9\u610f\u5473\u7740 CPU \u53ef\u4ee5\u50cf\u8bbf\u95ee\u5185\u5b58\u90a3\u6837\u8bbf\u95ee\u67d0\u4e2a\u5730\u5740\uff0c\u800c\u8be5\u5730\u5740\u5b9e\u9645\u4e0a\u5bf9\u5e94\u7740\u67d0\u4e2a\u8bbe\u5907\u5185\u90e8\u7684\u5bc4\u5b58\u5668\u3002</p> <p>\u4f7f\u7528 Memory-Mapped Register \u8fdb\u884c\u7684 IO \u64cd\u4f5c\u5373\u79f0\u4e3a Memory-Mapped I/O (MMIO)</p> <pre><code>gef &gt; monitor info mtree\n    000000000c000000-000000000c5fffff (prio 0, i/o): riscv.sifive.plic\n</code></pre> <p>\u4f8b\u5982\uff0cSpecification \u4e2d\u7684 Memory Map \u89c4\u5b9a\uff0c<code>base + 0x4 * i</code> \u662f\u7b2c i \u4e2a\u4e2d\u65ad\u6e90\u7684</p> <pre><code>base + 0x000000: Reserved (interrupt source 0 does not exist)\nbase + 0x000004: Interrupt source 1 priority\nbase + 0x000008: Interrupt source 2 priority\n...\nbase + 0x000FFC: Interrupt source 1023 priority\n</code></pre> <p>\u5728 <code>plicinit</code> \u4e2d\uff0c\u6211\u4eec\u5411 <code>base + 10*4 = 1</code> \u8bbe\u7f6e UART0 (10\u53f7\u4e2d\u65ad) \u7684 Interrupt Priority \u4e3a 1\u3002\u5728 <code>plicinithart</code> \u4e2d\uff0c\u6211\u4eec\u5c06\u8be5 Hart \u7684 S-mode Context \u5141\u8bb8\u6765\u81ea 10 \u53f7\u4e2d\u65ad\u3001\u5e76\u8bbe\u7f6e Priority Threshold \u4e3a 0\u3002\u6700\u540e\uff0c\u542f\u7528\u8be5\u6838\u5fc3\u7684 <code>sie.SEIE</code> \u4f4d\uff0c\u8868\u793a\u8be5\u6838\u5fc3\u5141\u8bb8 Supervisor-Mode External Interrupt\u3002\u5728 <code>main.c</code> \u7684 <code>while(1)</code> \u5faa\u73af\u524d\uff0c\u6211\u4eec\u4f7f\u7528 <code>intr_on</code> \u6253\u5f00\u6574\u4e2a CPU \u7684 S mode \u4e2d\u65ad\u3002</p>"},{"location":"lab/xv6lab-interrupts/#claim-complete","title":"Claim &amp; Complete","text":"<p>\u5728 Hart \u56e0\u4e3a External Interrupt \u9677\u5165 Trap \u540e\uff0cHart \u9700\u8981\u5411 PLIC \u7533\u8bf7\u5904\u7406\u8be5\u4e2d\u65ad\u3002\u5728\u5904\u7406\u5b8c\u6210\u540e\uff0cHart \u8fd8\u9700\u8981\u5411 PLIC \u7533\u660e\u8be5\u4e2d\u65ad\u5904\u7406\u5b8c\u6bd5\u3002</p> <p></p>"},{"location":"lab/xv6lab-interrupts/#_5","title":"\u4e32\u53e3\u4e2d\u65ad","text":"<p>\u5728 QEMU \u5e73\u53f0\u4e0a\uff0c\u4e32\u53e3\u6240\u4f7f\u7528\u7684\u8bbe\u5907\u6a21\u578b\u662f uart8250\u3002\u5b83\u7684 MMIO \u63a5\u53e3\u66b4\u9732\u4e86 8 \u4e2a\u5bc4\u5b58\u5668\u3002\u5177\u4f53\u7684\u7ec6\u8282\u53ef\u89c1\uff1ahttps://www.lammertbies.nl/comm/info/serial-uart</p> <p>uart8250 \u5177\u6709\u4e00\u4e2a\u8bfb\u53e3\u548c\u4e00\u4e2a\u5199\u53e3\uff0c\u5206\u522b\u662f <code>RHR</code> \u548c <code>THR</code>\uff0c\u5b83\u4eec\u5728\u5bc4\u5b58\u5668 <code>LSR</code> \u4e2d\u5404\u6709\u4e00\u4e2a bit \u8868\u793a\u8bfb\u53e3\u6709\u6570\u636e\u548c\u5199\u53e3\u7a7a\u95f2\u3002\u8bfb\u53d6\u548c\u5199\u5165\u7684\u51fd\u6570\u4f4d\u4e8e <code>uartgetc</code> \u548c <code>uart_putchar</code>\u3002</p> <p>\u5728\u4e32\u53e3\u521d\u59cb\u5316\u51fd\u6570 <code>console_init</code> \u4e2d\uff0c\u6211\u4eec\u5411 uart8250 \u7684 MMIO \u5730\u5740\u4e2d\u7684 <code>IER</code> \u5bc4\u5b58\u5668\u5199\u5165\u7279\u6b8a\u7684\u6807\u5fd7\u4f4d\uff0c\u8868\u793a\u6211\u4eec\u5141\u8bb8 uart8250 \u8bbe\u5907\u5728\u6709\u8f93\u5165\u7684\u65f6\u5019\u4ea7\u751f\u4e2d\u65ad\u3002\u968f\u540e\uff0c\u6211\u4eec\u5411 PLIC \u6ce8\u518c\u8be5\u8bbe\u5907\u7684\u4e2d\u65ad\u53f7 10\uff0c\u5c06\u5176\u8def\u7531\u5230\u5f53\u524d\u6838\u5fc3\u7684 S mode \u4e0b\uff0c\u5e76\u5728 <code>kernel_trap</code> \u4e2d\u5bf9\u5176\u5904\u7406\u3002</p> <pre><code>if (cause &amp; SCAUSE_INTERRUPT) {\n    // handle interrupt\n    switch (exception_code) {\n        case SupervisorExternal:\n            debugf(\"s-external interrupt.\");\n            plic_handle();\n            break;\n    }\n}\n</code></pre> <p><code>plic_handle</code> \u51fd\u6570\u4f1a\u4ece PLIC Claim \u5f97\u5230\u5f53\u524d\u5916\u90e8\u4e2d\u65ad\u6765\u6e90\u7684\u4e2d\u65ad\u53f7\uff0c\u5982\u679c\u5b83\u662f UART0 \u7684\u4e2d\u65ad\u53f7 10\uff0c\u90a3\u4e48\u5c31\u4ea4\u7ed9 <code>uart_intr()</code> \u51fd\u6570\u5904\u7406\u3002</p>"},{"location":"lab/xv6lab-pagefault/","title":"Page Fault","text":""},{"location":"lab/xv6lab-pagefault/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u638c\u63e1\u4ec0\u4e48\u662f\u7f3a\u9875\u4e2d\u65ad</li> <li>\u638c\u63e1\u4e09\u79cd\u7f3a\u9875\u4e2d\u65ad\u7684\u5904\u7406\u65b9\u5f0f</li> <li>\u638c\u63e1\u9875\u9762\u7f6e\u6362\u7684\u51e0\u79cd\u57fa\u7840\u7b97\u6cd5</li> </ol> <p>xv6-lab7 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTechOS/tree/pgfault</p> <p>\u6ce8\u610f\uff1a\u4ed3\u5e93\u5e76\u4e0d\u662f\u4ee5\u524d\u7684 SUSTech-OS-2025\u3002 </p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTechOS -b pgfault xv6lab7</code> \u4e0b\u8f7d xv6lab7 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u8fd0\u884c <code>pgfault</code> \u7a0b\u5e8f\uff0c\u5bf9\u7167 <code>user/src/pgfault.c</code>\uff0c\u89c2\u5bdf\u5185\u6838\u7684\u884c\u4e3a\u3002</p>"},{"location":"lab/xv6lab-pagefault/#page-fault_1","title":"Page Fault","text":"<p>Page Fault \u662f\u4e00\u79cd\u5f02\u5e38\u3002\u82e5\u7ed9\u5b9a\u7684\u865a\u62df\u5730\u5740\u8bf7\u6c42\uff08\u53d6\u6307\u3001\u8bfb\u53d6\u3001\u5199\u5165\uff09\u4e0e\u9875\u8868\u4e2d\u63cf\u8ff0\u7684\u4e0d\u4e00\u81f4\uff0cMMU \u5c31\u4f1a\u53d1\u8d77 Page Fault \u5f02\u5e38\u3002scause \u4e2d\u7684 <code>Exception Code</code> \u89c4\u5b9a\u4e86\u4e09\u79cd Page Fault\uff1a<code>Instruction page fault</code>, <code>Load page fault</code>, <code>Store/AMO page fault</code>\u3002</p> <p>\u5728\u7279\u6743\u7ea7\u624b\u518c\u4e2d\uff0c\u7ae0\u8282 <code>4.3.2 Virtual Address Translation Process</code> \u89c4\u5b9a\u4e86\u5728\u5730\u5740\u7ffb\u8bd1\u8fc7\u7a0b\u4e2d\uff0c\u6240\u6709\u53ef\u80fd\u9020\u6210 page fault \u7684\u60c5\u51b5\u3002</p> <p>\u5728\u53d1\u751f\u5f02\u5e38\u65f6\uff0c<code>stval</code> \u4f1a\u88ab\u5199\u5165\u9020\u6210 Page Fault \u7684\u865a\u62df\u5730\u5740\uff1a</p> <p>If stval is written with a nonzero value when a breakpoint, address-misaligned, access-fault, or page-fault exception occurs on an instruction fetch, load, or store, then stval will contain the faulting virtual address.</p>"},{"location":"lab/xv6lab-pagefault/#demand-paging","title":"Demand Paging","text":"<p>\u5728\u73b0\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c \u9700\u6c42\u5206\u9875\uff08Demand Paging\uff09 \u662f\u4e00\u79cd\u5185\u5b58\u7ba1\u7406\u7b56\u7565\uff0c\u5b83\u53ea\u6709\u5728\u7a0b\u5e8f\u8bbf\u95ee\u67d0\u4e00\u5185\u5b58\u9875\u65f6\u624d\u5c06\u8be5\u9875\u52a0\u8f7d\u5230\u5185\u5b58\u3002\u4e0e\u4f20\u7edf\u7684\u5c06\u6574\u4e2a\u7a0b\u5e8f\u7684\u6240\u6709\u9875\u4e00\u6b21\u6027\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u7b56\u7565\u4e0d\u540c\uff0c\u9700\u6c42\u5206\u9875\u53ef\u4ee5\u66f4\u6709\u6548\u5730\u5229\u7528\u5185\u5b58\u8d44\u6e90\uff0c\u907f\u514d\u6d6a\u8d39\u3002</p> <p>\u5728\u5f53\u524d\u7684 xv6 \u4e2d\uff0c\u6bcf\u4e2a\u7528\u6237\u8fdb\u7a0b\u7684\u6808\u5206\u914d\u4e86 8 \u4e2a\u7269\u7406\u9875\u9762\u3002\u6211\u4eec\u8981\u601d\u8003\u4e00\u4e2a\u95ee\u9898\uff1a\u7528\u6237\u8fdb\u7a0b\u771f\u7684\u4f1a\u4f7f\u7528\u5230\u6240\u6709 8 \u4e2a\u9875\u9762\u5417\uff1f \u6808\u662f\u4ece\u9ad8\u5730\u5740\u5411\u4f4e\u5730\u5740\u751f\u957f\u7684\uff0c\u56e0\u6b64\u7a0b\u5e8f\u5728\u8fd0\u884c\u65f6\u6808\u4f1a\u9010\u6e10\u6269\u5c55\u3002\u8fd9\u79cd\u52a8\u6001\u6269\u5c55\u610f\u5473\u7740\u5728\u8fdb\u7a0b\u7684\u521d\u671f\uff0c\u5b83\u53ef\u80fd\u5e76\u4e0d\u4f1a\u4f7f\u7528\u5230\u6240\u6709\u5206\u914d\u7684\u6808\u7a7a\u95f4\u3002\u8fd9\u6837\uff0c\u4e00\u5f00\u59cb\u5c31\u4e3a\u6808\u5206\u914d\u5927\u91cf\u5185\u5b58\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u8d44\u6e90\u6d6a\u8d39\u3002</p> <p>\u6240\u4ee5\uff0c\u5728\u5206\u914d\u6808\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u53ea\u5206\u914d 2 \u4e2a\u7269\u7406\u9875\u9762\uff0c\u7b49 \u7528\u6237\u8fdb\u7a0b\u9700\u8981\u5269\u4e0b\u7684\u9875\u9762\u65f6\uff0c\u6211\u4eec\u518d\u8fdb\u884c\u5206\u914d\u7269\u7406\u9875\u9762 \u3002 \u5f53\u7528\u6237\u8fdb\u7a0b\u8bbf\u95ee\u67d0\u4e2a\u865a\u62df\u5730\u5740\u65f6\uff0cCPU \u4f1a\u53d1\u73b0\u8be5\u5730\u5740\u5728\u9875\u8868\u4e2d\u6ca1\u6709\u6620\u5c04\uff0c\u4e8e\u662f\u4f1a\u89e6\u53d1\u4e00\u4e2a Page Fault \u5f02\u5e38\u3002</p> <p>\u5c3d\u7ba1\u8fd9\u4e2a\u865a\u62df\u5730\u5740\u5bf9 CPU \u6765\u8bf4\u662f\u975e\u6cd5\u7684\uff0c\u4f46\u5b9e\u9645\u4e0a\uff0c\u5185\u6838\u5df2\u7ecf\u4e3a\u8be5\u865a\u62df\u5730\u5740\u9884\u7559\u4e86\u7a7a\u95f4\u3002\u6536\u5230 Page Fault \u5f02\u5e38\u540e\uff0c\u5185\u6838\u77e5\u9053\u7528\u6237\u8fdb\u7a0b\u786e\u5b9e\u9700\u8981\u4f7f\u7528\u8fd9\u4e2a\u9875\u9762\uff0c\u56e0\u6b64\u4f1a\u5728\u5f02\u5e38\u5904\u7406\u8fc7\u7a0b\u4e2d\u5206\u914d\u76f8\u5e94\u7684\u7269\u7406\u9875\u9762\uff0c\u5e76\u66f4\u65b0\u9875\u8868\u3002\u968f\u540e\uff0c\u5185\u6838\u4f1a\u8ba9\u7a0b\u5e8f\u4ece\u53d1\u751f Page Fault \u7684\u4f4d\u7f6e\u7ee7\u7eed\u6267\u884c\uff0cCPU \u8fd9\u65f6\u4f1a\u53d1\u73b0\u8be5\u865a\u62df\u5730\u5740\u5df2\u7ecf\u5408\u6cd5\u3002\u5bf9\u7528\u6237\u8fdb\u7a0b\u800c\u8a00\uff0c\u7a0b\u5e8f\u6267\u884c\u88ab\u77ed\u6682\u6682\u505c\u4e86\u4e00\u4e0b\uff0c\u6574\u4e2a\u8fc7\u7a0b\u662f\u65e0\u611f\u77e5\u7684\u3002</p>"},{"location":"lab/xv6lab-pagefault/#page-fault_2","title":"Page Fault","text":"<p>\u524d\u9762\u6211\u4eec\u63d0\u5230\u5f53\u8fdb\u7a0b\u7533\u8bf7\u5185\u5b58\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u8fdb\u7a0b\u63d0\u4f9b\u4e00\u6bb5\u865a\u62df\u5730\u5740\u7684\u4f7f\u7528\u6743\uff0c\u4f46\u5e76\u6ca1\u6709\u5b9e\u9645\u5206\u914d\u865a\u62df\u5730\u5740\u5bf9\u5e94\u7684\u7269\u7406\u5185\u5b58\u3002\u800c\u5f53\u8fdb\u7a0b\u8bbf\u95ee\u8be5\u5730\u5740\u65f6\uff0c\u4f1a\u53d1\u73b0\u865a\u62df\u5730\u5740\u5e76\u6ca1\u6709\u5bf9\u5e94\u7684\u7269\u7406\u5730\u5740\uff0c\u4ece\u800c\u89e6\u53d1\u7f3a\u9875\u4e2d\u65ad\uff08page fault\uff09\uff0c\u800c\u540e\u64cd\u4f5c\u7cfb\u7edf\u901a\u8fc7\u54cd\u5e94\u8be5\u4e2d\u65ad\u5b9e\u73b0\u7269\u7406\u5185\u5b58\u7684\u5206\u914d\uff0c\u5e76\u5728\u9875\u8868\u4e2d\u5efa\u7acb\u76f8\u5e94\u7684\u5730\u5740\u6620\u5c04\u3002</p> <p>\u5f53cpu\u8bbf\u95ee\u865a\u62df\u5730\u5740\uff0c\u800c\u8be5\u865a\u62df\u5730\u5740\u627e\u4e0d\u5230\u5bf9\u5e94\u7684\u7269\u7406\u5185\u5b58\u65f6\u89e6\u53d1\u8be5\u5f02\u5e38\u3002\u4ee5\u4e0b\u60c5\u51b5\u53ef\u80fd\u5bfc\u81f4page fault\u88ab\u89e6\u53d1\uff1a</p> <ol> <li>\u9875\u8868\u4e2d\u6ca1\u6709\u865a\u62df\u5730\u5740\u5bf9\u5e94\u7684PTE\uff08\u865a\u62df\u5730\u5740\u65e0\u6548\u6216\u865a\u62df\u5730\u5740\u6709\u6548\u4f46\u6ca1\u6709\u5206\u914d\u7269\u7406\u5185\u5b58\u9875\uff09</li> <li>\u73b0\u6709\u6743\u9650\u65e0\u6cd5\u64cd\u4f5c\u5bf9\u5e94\u7684PTE</li> </ol> <p>linux\u4e2d\u7f3a\u9875\u4e2d\u65ad\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff1a</p> <ol> <li>major page fault (hard page fault)</li> </ol> <p>\u8bbf\u95ee\u7684\u865a\u62df\u5730\u5740\u5185\u5bb9\u4e0d\u5728\u5185\u5b58\u4e2d\uff0c\u9700\u8981\u4ece\u5916\u8bbe\u8f7d\u5165\u3002\u5e38\u89c1\u4e8e\u5185\u5bb9\u9875\u88ab\u7f6e\u6362\u5230\u5916\u8bbe\u4ea4\u6362\u533a\u4e2d\uff0c\u9700\u8981\u5c06\u4ea4\u6362\u533a\u4e2d\u7684\u9875\u9762\u91cd\u65b0\u8f7d\u5165\u5185\u5b58\u3002</p> <ol> <li>minor page fault (soft page fault)</li> </ol> <p>\u865a\u62df\u5730\u5740\u5728\u9875\u8868\u4e2d\u6ca1\u6709\u5efa\u7acb\u6620\u5c04\uff0c\u5e38\u89c1\u4e8e\u8fdb\u7a0b\u7533\u8bf7\u865a\u62df\u5185\u5b58\u540e\u521d\u6b21\u64cd\u4f5c\u5185\u5b58\uff0c\u53ca\u591a\u4e2a\u8fdb\u7a0b\u8bbf\u95ee\u5171\u4eab\u5185\u5b58\u5c1a\u672a\u5efa\u7acb\u865a\u62df\u5730\u5740\u6620\u5c04\u7684\u60c5\u51b5\u3002</p> <ol> <li>invalid fault</li> </ol> <p>\u8bbf\u95ee\u7684\u865a\u62df\u5730\u5740\u4e0d\u5408\u6cd5\u3002</p> <p>\u5728XV6\u4e2d\uff0c\u7f3a\u9875\u4e2d\u65ad\u7684\u5904\u7406\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <p></p>"},{"location":"lab/xv6lab-pagefault/#_2","title":"\u5b9e\u73b0","text":"<p>\u5728 xv6 \u4e2d\uff0c\u6211\u4eec\u5bf9 \u7528\u6237\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4 \u6709\u4e24\u79cd\u8868\u793a\u65b9\u5f0f\uff1aVMA \u7ed3\u6784\u4f53\u548c\u9875\u8868\u3002\u540e\u8005\u662f CPU \u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\u6240\u9700\u7684\uff0c\u800c\u524d\u8005\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u4ee3\u7801\u8f83\u4e3a\u53cb\u597d\u3002</p> <p>\u5728\u7ed9\u7528\u6237\u5206\u914d\u865a\u62df\u5730\u5740\u7a7a\u95f4\u65f6\uff0c\u6211\u4eec\u5c06\u5176\u4fdd\u5b58\u5230 VMA \u7ed3\u6784\u4f53\u4e2d\uff0c\u4f46\u662f\u5148\u4e0d\u7ed9\u5b83\u6620\u5c04\u7269\u7406\u9875\u9762\uff1b\u5e76\u7b49\u5f85\u7528\u6237\u771f\u6b63\u7528\u5230\u8fd9\u4e2a\u5730\u5740\u65f6\uff08\u5373\u53d1\u751f Page Fault\u65f6\uff09\u518d\u6620\u5c04\u7269\u7406\u9875\u9762\u3002</p> <p>\u5f53 Page Fault \u53d1\u751f\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u68c0\u67e5 <code>stval</code> \u4e2d\u7684\u865a\u62df\u5730\u5740\u662f\u5426\u5728 VMA \u7ed3\u6784\u4f53\u4e2d\u3002\u5982\u679c\u4e0d\u5728\uff0c\u5219\u8bf4\u660e\u8be5\u5f02\u5e38\u771f\u7684\u662f\u7528\u6237\u7a0b\u5e8f\u8fdb\u884c\u4e86\u975e\u6cd5\u5185\u5b58\u8bbf\u95ee\uff1b\u5426\u5219\uff0c\u5219\u8bf4\u660e\u8be5\u5730\u5740\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u7528\u6237\u865a\u62df\u5730\u5740\uff0c\u6211\u4eec\u5728\u8fd9\u65f6\u518d\u7ed9\u5b83\u5206\u914d\u7269\u7406\u9875\u9762\u5e76\u5728\u9875\u8868\u4e2d\u6620\u5c04\u3002</p> <p>\u53e6\u4e00\u79cd\u65b9\u5f0f</p> <p>\u6b64\u5916\uff0c\u6211\u4eec\u9700\u8981\u4e86\u89e3\u8fd8\u6709\u4e00\u79cd\u65b9\u6cd5\u6765\u8868\u793a\u201c\u8be5\u865a\u62df\u5730\u5740\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u3001\u4f46\u662f\u672a\u5206\u914d\u7684\u865a\u62df\u5730\u5740\u201d\uff1a\u56de\u987e PTE \u7684\u7ed3\u6784\uff0c\u5728\u7b2c0\u4f4d\u4e0a\u6709\u4e00\u4e2a <code>V</code> \u6807\u5fd7\u4f4d\uff0cMMU \u5728\u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\u65f6\u4f1a\u68c0\u67e5\u8fd9\u4e2abit\uff0c\u5982\u679c\u662f0\uff0c\u5219\u4f1a\u8ba4\u4e3a\u8be5 PTE \u4e0d\u53ef\u7528\uff0c\u5373\u4f1a\u5ffd\u7565\u6240\u6709\u9ad863\u4f4d\u3002</p> <p>\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u6709\u4ec0\u4e48\u4e1c\u897f\u6700\u4f4e\u4f4d\u4e00\u5b9a\u662f0\u5462\uff1a\u4e00\u4e2a\u5185\u5b58\u5bf9\u9f50\u7684\u6307\u9488\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u9875\u8868\u4e0a\u7684 PTE \u4e2d\u653e\u7f6e\u4e00\u4e2a\u6307\u9488\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684 PTE\u3002\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6b64\u7279\u70b9\u5c06\u4e00\u4e2a\u201c\u5408\u6cd5\u4f46\u662f\u672a\u5206\u914d\u201d\u7684\u865a\u62df\u5730\u5740\u6307\u5411\u4e00\u4e2a\u5185\u6838\u7684\u5bf9\u8c61\uff0c\u5728 Page Fault \u65f6\u6211\u4eec\u5c31\u53ef\u4ee5\u4ece\u8be5\u5bf9\u8c61\u4e2d\u62bd\u53d6\u76f8\u5173\u4fe1\u606f\u3002</p> <p>\u76f8\u5173\u5b9e\u73b0</p> <p>\u5982\u679c\u4f60\u6709\u5174\u8da3\uff0c\u53ef\u4ee5\u53c2\u8003 MIT 6.828 \u539f\u7248\u7684 mmap \u4f5c\u4e1a\uff0c\u5728\u6211\u4eec\u7684 xv6 \uff08\u8f83\u539f\u7248xv6\u6709\u6240\u6539\u52a8\uff09\u4e0a\u5b9e\u73b0 mmap\u3002</p> <p>https://pdos.csail.mit.edu/6.828/2024/labs/mmap.html</p>"},{"location":"lab/xv6lab-pagefault/#swap","title":"\u9875\u9762\u7f6e\u6362 Swap","text":"<p>\u5f53\u9700\u8981\u5206\u914d\u7269\u7406\u9875\u9762\u65f6\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528 <code>kallocpage</code> \u7684\u65b9\u6cd5\u3002\u4f46\u662f\uff0c\u5f53\u7cfb\u7edf\u4e2d\u6ca1\u6709\u7a7a\u95f2\u7269\u7406\u9875\u9762\u65f6\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</p> <p>\u5bf9\u4e8e\u8fd9\u79cd\u8d44\u6e90\u5206\u914d\u5931\u8d25\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u5730\u56de\u5230\u6700\u5f00\u59cb\u7684\u60c5\u51b5\uff0c\u5e76\u5bf9\u8c03\u7528\u8005\u8fd4\u56de\u4e00\u4e2a\u9519\u8bef\u3002\u5982 <code>fork</code> \u548c <code>exec</code> \u5728\u5185\u5b58\u5206\u914d\u5931\u8d25\u65f6\u4f1a\u8fd4\u56de\u4e00\u4e2a\u8d1f\u6570\u8868\u793a\u9519\u8bef\u3002</p> <p>\u6709\u65f6\u5019\uff0c\u6211\u4eec\u5e0c\u671b\u5185\u6838\u4e2d\u5c3d\u91cf\u6709\u8db3\u591f\u7684\u7269\u7406\u9875\u9762\u3002\u6240\u4ee5\uff0c\u5f53\u5185\u6838\u4e2d\u53ef\u7528\u7269\u7406\u9875\u9762\u8fc7\u4f4e\u65f6\uff08\u7406\u8bba\u8bfe\u4e0a\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u4f4e\u6c34\u4f4d/\u9ad8\u6c34\u4f4d, low/high watermark\uff09\uff0c\u5185\u6838\u53ef\u4ee5\u5c06\u4e00\u4e9b\u9875\u9762\u4e22\u51fa\u5185\u5b58 (swap out) \uff0c\u5b58\u50a8\u5230\u6b21\u7ea7\u7684\u5b58\u50a8\u7a7a\u95f4\uff08\u5982\u786c\u76d8\uff0c\u56de\u987e CSAPP: Memory Hierarchy\uff09\uff0c\u4ee5\u6b64\u817e\u51fa\u7a7a\u95f4\u3002</p> <p>CSAPP: Memory Hierarchy</p> <p></p> <p>\u90a3\u4e48\uff0c\u4e22\u51fa\u53bb\u7684\u9875\u9762\u5982\u679c\u4e4b\u540e\u8fd8\u9700\u8981\u4f7f\u7528\u600e\u4e48\u529e\uff1f\u56de\u987e\u4e4b\u524d\u7684 Demand Paging \u601d\u60f3\uff1a\u53ea\u6709\u5728 Page Fault \u65f6\uff0c\u7528\u6237\u8fdb\u7a0b\u5728\u771f\u6b63\u5f15\u7528\u4e86\u67d0\u865a\u62df\u5730\u5740\u3002\u5bf9\u4e8e\u90a3\u4e9b\u88ab\u4e22\u51fa\u53bb\u7684\u7269\u7406\u9875\u9762\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u8fd9\u6837\u505a\u3002\u5728\u518d\u6b21\u8bbf\u95ee\u4e4b\u524d\u4e22\u51fa\u7684\u9875\u9762\uff0c\u6b64\u65f6\u56e0\u4e3a\u9875\u9762\u5df2\u7ecf\u4e22\u51fa\uff0c\u8be5\u9875\u5bf9\u5e94\u7684\u9875\u8868\u4e2d\u7684PTE\u5c06\u662f\u4e00\u4e2a\u65e0\u6548PTE\uff0c\u4ece\u800c\u5bfc\u81f4 Page Fault \uff0c\u9047\u5230 Page Fault \u65f6\u624d\u4ece\u6b21\u7ea7\u5b58\u50a8\u7a7a\u95f4\u8bfb\u53d6\u5230\u5185\u5b58 (swap in)\uff0c\u5e76\u91cd\u65b0\u5efa\u7acb\u9875\u8868\u6620\u5c04\u3002</p> <p>\u9009\u62e9\u54ea\u4e2a\u7a7a\u95f2\u9875\u9762\u8fdb\u884c swap out \u7684\u7b56\u7565\u6211\u4eec\u79f0\u4e3a\u9875\u9762\u7f6e\u6362\u7b97\u6cd5\u3002</p> <p>\u4ee5\u4e0b\u6d41\u7a0b\u56fe\u8bf4\u660e\u4e86\u4f55\u65f6\u9700\u8981\u9875\u9762\u7f6e\u6362\uff1a </p> <p>\u8fd8\u662f\u56de\u987e Memory Hierarchy\uff0c\u5bf9\u4e8e\u6b21\u7ea7\u5b58\u50a8\u7a7a\u95f4\uff08\u786c\u76d8\uff09\uff0c\u5b83\u7684\u8bbf\u95ee\u901f\u5ea6\u548c\u8bbf\u95ee\u5ef6\u8fdf\u80af\u5b9a\u662f\u4e0d\u5982\u5185\u5b58\u7684\u3002\u6240\u4ee5\u6211\u4eec\u8981\u5c3d\u91cf\u51cf\u5c11 swap \u7684\u6b21\u6570\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u8be5\u5982\u4f55\u9009\u62e9 \u88ab\u4e22\u51fa\u53bb\u7684\u9875\u9762 \uff1f</p>"},{"location":"lab/xv6lab-pagefault/#_3","title":"\u9875\u9762\u7f6e\u6362\u7b97\u6cd5","text":"<p>\u5728\u5bf9\u4e8e\u4e00\u4e2a\u603b\u6570\u6709\u9650\u3001\u9700\u8981\u62bd\u9009\u4e00\u4e9b\u9879\u76ee\u8e22\u51fa\u53bb\u7684\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u901a\u5e38\u6709\u4e24\u79cd\u5b9e\u73b0\u4e0a\u6bd4\u8f83\u53cb\u597d\u7684\u7b97\u6cd5\uff1aFIFO \u548c LRU\u3002\uff08\u4f8b\u5982 CPU \u4e2d\u7684 L1/L2/L3 Cache, TLB\uff09</p> <ul> <li> <p>\u5148\u8fdb\u5148\u51fa(First In First Out, FIFO)\u9875\u66ff\u6362\u7b97\u6cd5\uff1a\u8be5\u7b97\u6cd5\u603b\u662f\u6dd8\u6c70\u6700\u5148\u8fdb\u5165\u5185\u5b58\u7684\u9875\uff0c\u5373\u9009\u62e9\u5728\u5185\u5b58\u4e2d\u9a7b\u7559\u65f6\u95f4\u6700\u4e45\u7684\u9875\u4e88\u4ee5\u6dd8\u6c70\u3002\u53ea\u9700\u628a\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u5df2\u8c03\u5165\u5185\u5b58\u7684\u9875\u6309\u5148\u540e\u6b21\u5e8f\u94fe\u63a5\u6210\u4e00\u4e2a\u961f\u5217\uff0c\u961f\u5217\u5934\u6307\u5411\u5185\u5b58\u4e2d\u9a7b\u7559\u65f6\u95f4\u6700\u4e45\u7684\u9875\uff0c\u961f\u5217\u5c3e\u6307\u5411\u6700\u8fd1\u88ab\u8c03\u5165\u5185\u5b58\u7684\u9875\u3002\u8fd9\u6837\u9700\u8981\u6dd8\u6c70\u9875\u65f6\uff0c\u4ece\u961f\u5217\u5934\u5f88\u5bb9\u6613\u67e5\u627e\u5230\u9700\u8981\u6dd8\u6c70\u7684\u9875\u3002FIFO \u7b97\u6cd5\u53ea\u662f\u5728\u5e94\u7528\u7a0b\u5e8f\u6309\u7ebf\u6027\u987a\u5e8f\u8bbf\u95ee\u5730\u5740\u7a7a\u95f4\u65f6\u6548\u679c\u624d\u597d\uff0c\u5426\u5219\u6548\u7387\u4e0d\u9ad8\u3002\u56e0\u4e3a\u90a3\u4e9b\u5e38\u88ab\u8bbf\u95ee\u7684\u9875\uff0c\u5f80\u5f80\u5728\u5185\u5b58\u4e2d\u4e5f\u505c\u7559\u5f97\u6700\u4e45\uff0c\u7ed3\u679c\u5b83\u4eec\u56e0\u53d8\u201c\u8001\u201d\u800c\u4e0d\u5f97\u4e0d\u88ab\u7f6e\u6362\u51fa\u53bb\u3002FIFO \u7b97\u6cd5\u7684\u53e6\u4e00\u4e2a\u7f3a\u70b9\u662f\uff0c\u5b83\u6709\u4e00\u79cd\u5f02\u5e38\u73b0\u8c61\uff08Belady \u73b0\u8c61\uff09\uff0c\u5373\u5728\u589e\u52a0\u653e\u7f6e\u9875\u7684\u7269\u7406\u9875\u5e27\u7684\u60c5\u51b5\u4e0b\uff0c\u53cd\u800c\u4f7f\u9875\u8bbf\u95ee\u5f02\u5e38\u6b21\u6570\u589e\u591a\u3002</p> </li> <li> <p>\u6700\u4e45\u672a\u4f7f\u7528(least recently used, LRU)\u7b97\u6cd5\uff1a\u5229\u7528\u5c40\u90e8\u6027 (Locality)\uff0c\u901a\u8fc7\u8fc7\u53bb\u7684\u8bbf\u95ee\u60c5\u51b5\u9884\u6d4b\u672a\u6765\u7684\u8bbf\u95ee\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6700\u8fd1\u8fd8\u88ab\u8bbf\u95ee\u8fc7\u7684\u9875\u9762\u5c06\u6765\u88ab\u8bbf\u95ee\u7684\u53ef\u80fd\u6027\u5927\uff0c\u800c\u5f88\u4e45\u6ca1\u8bbf\u95ee\u8fc7\u7684\u9875\u9762\u5c06\u6765\u4e0d\u592a\u53ef\u80fd\u88ab\u8bbf\u95ee\u3002\u4e8e\u662f\u6211\u4eec\u6bd4\u8f83\u5f53\u524d\u5185\u5b58\u91cc\u7684\u9875\u9762\u6700\u8fd1\u4e00\u6b21\u88ab\u8bbf\u95ee\u7684\u65f6\u95f4\uff0c\u628a\u4e0a\u4e00\u6b21\u8bbf\u95ee\u65f6\u95f4\u79bb\u73b0\u5728\u6700\u4e45\u7684\u9875\u9762\u7f6e\u6362\u51fa\u53bb\u3002</p> </li> <li> <p>\u65f6\u949f\uff08Clock\uff09\u9875\u66ff\u6362\u7b97\u6cd5\uff1a\u662f LRU \u7b97\u6cd5\u7684\u4e00\u79cd\u8fd1\u4f3c\u5b9e\u73b0\u3002\u65f6\u949f\u9875\u66ff\u6362\u7b97\u6cd5\u628a\u5404\u4e2a\u9875\u9762\u7ec4\u7ec7\u6210\u73af\u5f62\u94fe\u8868\u7684\u5f62\u5f0f\uff0c\u7c7b\u4f3c\u4e8e\u4e00\u4e2a\u949f\u7684\u8868\u9762\u3002\u7136\u540e\u628a\u4e00\u4e2a\u6307\u9488\uff08\u7b80\u79f0\u5f53\u524d\u6307\u9488\uff09\u6307\u5411\u6700\u8001\u7684\u90a3\u4e2a\u9875\u9762\uff0c\u5373\u6700\u5148\u8fdb\u6765\u7684\u90a3\u4e2a\u9875\u9762\u3002\u53e6\u5916\uff0c\u65f6\u949f\u7b97\u6cd5\u9700\u8981\u5728\u9875\u8868\u9879\uff08PTE\uff09\u4e2d\u8bbe\u7f6e\u4e86\u4e00\u4f4d\u8bbf\u95ee\u4f4d\u6765\u8868\u793a\u6b64\u9875\u8868\u9879\u5bf9\u5e94\u7684\u9875\u5f53\u524d\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7\u3002\u5f53\u8be5\u9875\u88ab\u8bbf\u95ee\u65f6\uff0cCPU \u4e2d\u7684 MMU \u786c\u4ef6\u5c06\u628a\u8bbf\u95ee\u4f4d\u7f6e\u201c1\u201d\u3002\u5f53\u64cd\u4f5c\u7cfb\u7edf\u9700\u8981\u6dd8\u6c70\u9875\u65f6\uff0c\u5bf9\u5f53\u524d\u6307\u9488\u6307\u5411\u7684\u9875\u6240\u5bf9\u5e94\u7684\u9875\u8868\u9879\u8fdb\u884c\u67e5\u8be2\uff0c\u5982\u679c\u8bbf\u95ee\u4f4d\u4e3a\u201c0\u201d\uff0c\u5219\u6dd8\u6c70\u8be5\u9875\uff0c\u5982\u679c\u8be5\u9875\u88ab\u5199\u8fc7\uff0c\u5219\u8fd8\u8981\u628a\u5b83\u6362\u51fa\u5230\u786c\u76d8\u4e0a\uff1b\u5982\u679c\u8bbf\u95ee\u4f4d\u4e3a\u201c1\u201d\uff0c\u5219\u5c06\u8be5\u9875\u8868\u9879\u7684\u6b64\u4f4d\u7f6e\u201c0\u201d\uff0c\u7ee7\u7eed\u8bbf\u95ee\u4e0b\u4e00\u4e2a\u9875\u3002\u8be5\u7b97\u6cd5\u8fd1\u4f3c\u5730\u4f53\u73b0\u4e86 LRU \u7684\u601d\u60f3\uff0c\u4e14\u6613\u4e8e\u5b9e\u73b0\uff0c\u5f00\u9500\u5c11\uff0c\u9700\u8981\u786c\u4ef6\u652f\u6301\u6765\u8bbe\u7f6e\u8bbf\u95ee\u4f4d\u3002\u65f6\u949f\u9875\u66ff\u6362\u7b97\u6cd5\u5728\u672c\u8d28\u4e0a\u4e0e FIFO \u7b97\u6cd5\u662f\u7c7b\u4f3c\u7684\uff0c\u4e0d\u540c\u4e4b\u5904\u662f\u5728\u65f6\u949f\u9875\u66ff\u6362\u7b97\u6cd5\u4e2d\u8df3\u8fc7\u4e86\u8bbf\u95ee\u4f4d\u4e3a 1 \u7684\u9875\u3002</p> </li> <li> <p>\u6539\u8fdb\u7684\u65f6\u949f\uff08Enhanced Clock\uff09\u9875\u66ff\u6362\u7b97\u6cd5\uff1a\u5728\u65f6\u949f\u7f6e\u6362\u7b97\u6cd5\u4e2d\uff0c\u6dd8\u6c70\u4e00\u4e2a\u9875\u9762\u65f6\u53ea\u8003\u8651\u4e86\u9875\u9762\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7\uff0c\u4f46\u5728\u5b9e\u9645\u60c5\u51b5\u4e2d\uff0c\u8fd8\u5e94\u8003\u8651\u88ab\u6dd8\u6c70\u7684\u9875\u9762\u662f\u5426\u88ab\u4fee\u6539\u8fc7\u3002\u56e0\u4e3a\u6dd8\u6c70\u4fee\u6539\u8fc7\u7684\u9875\u9762\u8fd8\u9700\u8981\u5199\u56de\u786c\u76d8\uff0c\u4f7f\u5f97\u5176\u7f6e\u6362\u4ee3\u4ef7\u5927\u4e8e\u672a\u4fee\u6539\u8fc7\u7684\u9875\u9762\uff0c\u6240\u4ee5\u4f18\u5148\u6dd8\u6c70\u6ca1\u6709\u4fee\u6539\u7684\u9875\uff0c\u51cf\u5c11\u78c1\u76d8\u64cd\u4f5c\u6b21\u6570\u3002\u6539\u8fdb\u7684\u65f6\u949f\u7f6e\u6362\u7b97\u6cd5\u9664\u4e86\u8003\u8651\u9875\u9762\u7684\u8bbf\u95ee\u60c5\u51b5\uff0c\u8fd8\u9700\u8003\u8651\u9875\u9762\u7684\u4fee\u6539\u60c5\u51b5\u3002\u5373\u8be5\u7b97\u6cd5\u4e0d\u4f46\u5e0c\u671b\u6dd8\u6c70\u7684\u9875\u9762\u662f\u6700\u8fd1\u672a\u4f7f\u7528\u7684\u9875\uff0c\u800c\u4e14\u8fd8\u5e0c\u671b\u88ab\u6dd8\u6c70\u7684\u9875\u662f\u5728\u4e3b\u5b58\u9a7b\u7559\u671f\u95f4\u5176\u9875\u9762\u5185\u5bb9\u672a\u88ab\u4fee\u6539\u8fc7\u7684\u3002\u8fd9\u9700\u8981\u4e3a\u6bcf\u4e00\u9875\u7684\u5bf9\u5e94\u9875\u8868\u9879\u5185\u5bb9\u4e2d\u589e\u52a0\u4e00\u4f4d\u5f15\u7528\u4f4d\u548c\u4e00\u4f4d\u4fee\u6539\u4f4d\u3002\u5f53\u8be5\u9875\u88ab\u8bbf\u95ee\u65f6\uff0cCPU \u4e2d\u7684 MMU \u786c\u4ef6\u5c06\u628a\u8bbf\u95ee\u4f4d\u7f6e\u201c1\u201d\u3002\u5f53\u8be5\u9875\u88ab\u201c\u5199\u201d\u65f6\uff0cCPU \u4e2d\u7684 MMU \u786c\u4ef6\u5c06\u628a\u4fee\u6539\u4f4d\u7f6e\u201c1\u201d\u3002\u8fd9\u6837\u8fd9\u4e24\u4f4d\u5c31\u5b58\u5728\u56db\u79cd\u53ef\u80fd\u7684\u7ec4\u5408\u60c5\u51b5\uff1a\uff080\uff0c0\uff09\u8868\u793a\u6700\u8fd1\u672a\u88ab\u5f15\u7528\u4e5f\u672a\u88ab\u4fee\u6539\uff0c\u9996\u5148\u9009\u62e9\u6b64\u9875\u6dd8\u6c70\uff1b\uff080\uff0c1\uff09\u6700\u8fd1\u672a\u88ab\u4f7f\u7528\uff0c\u4f46\u88ab\u4fee\u6539\uff0c\u5176\u6b21\u9009\u62e9\uff1b\uff081\uff0c0\uff09\u6700\u8fd1\u4f7f\u7528\u800c\u672a\u4fee\u6539\uff0c\u518d\u6b21\u9009\u62e9\uff1b\uff081\uff0c1\uff09\u6700\u8fd1\u4f7f\u7528\u4e14\u4fee\u6539\uff0c\u6700\u540e\u9009\u62e9\u3002\u8be5\u7b97\u6cd5\u4e0e\u65f6\u949f\u7b97\u6cd5\u76f8\u6bd4\uff0c\u53ef\u8fdb\u4e00\u6b65\u51cf\u5c11\u78c1\u76d8\u7684 I/O \u64cd\u4f5c\u6b21\u6570\uff0c\u4f46\u4e3a\u4e86\u67e5\u627e\u5230\u4e00\u4e2a\u5c3d\u53ef\u80fd\u9002\u5408\u6dd8\u6c70\u7684\u9875\u9762\uff0c\u53ef\u80fd\u9700\u8981\u7ecf\u8fc7\u591a\u6b21\u626b\u63cf\uff0c\u589e\u52a0\u4e86\u7b97\u6cd5\u672c\u8eab\u7684\u6267\u884c\u5f00\u9500\u3002</p> </li> </ul>"},{"location":"lab/xv6lab-pagefault/#pte-ad","title":"PTE A/D","text":"<p>\u64cd\u4f5c\u7cfb\u7edf\u662f\u600e\u4e48\u77e5\u9053\u201c\u4e00\u4e2a\u9875\u9762\u6700\u8fd1\u88ab\u8bbf\u95ee\u8fc7\u201d\u7684\uff1f</p> <p>PTE \u4e2d\u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d A (Access), D (Dirty)\uff0c\u5206\u522b\u8868\u793a\u8be5\u865a\u62df\u5730\u5740\u6620\u5c04\u662f\u5426\u88ab\u8bfb\u53d6\u8fc7\u3001\u88ab\u5199\u5165\u8fc7\uff0cMMU \u4f1a\u5728\u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\u65f6\u8bbe\u7f6e\u8fd9\u4e24\u4e2a bit\uff0c\u8fd9\u6837\u64cd\u4f5c\u7cfb\u7edf\u5c31\u80fd\u77e5\u9053\u201c\u4e00\u4e2a\u9875\u9762\u88ab\u8bbf\u95ee\u8fc7\u201d\u3002</p> <p>\u5bf9\u4e8e \u201c\u6700\u8fd1\u201d\uff0c\u64cd\u4f5c\u7cfb\u7edf\u53ef\u4ee5\u91c7\u7528\u4e00\u79cd\u8fd1\u4f3c\u7684\u65b9\u5f0f\u3002\u4f8b\u5982\u6bcf 10ms \u6e05\u9664\u6240\u6709\u9875\u8868\u4e2d\u7684 A/D bits\uff0c\u5982\u679c\u5728\u4e0b\u6b21\u68c0\u67e5\u5b83\u4eec\u7684\u65f6\u5019\u4e0d\u4e3a0\uff0c\u5219\u8868\u793a\u5728\u8fd9 10ms \u5185\u6709\u8bbf\u95ee\u8fc7\u3002</p>"},{"location":"lab/xv6lab-paging/","title":"RISC-V \u9875\u8868\u6a21\u578b &amp; xv6 \u5185\u6838\u9875\u8868","text":""},{"location":"lab/xv6lab-paging/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u4e86\u89e3RISC-V\u9875\u8868\u6a21\u578bSV39</li> <li>\u638c\u63e1\u865a\u62df\u5730\u5740\u5230\u7269\u7406\u5730\u5740\u7684\u8f6c\u6362\u673a\u5236</li> <li>\u638c\u63e1XV6\u5982\u4f55\u7ba1\u7406\u5185\u5b58\u5e76\u521b\u5efa\u9875\u8868</li> </ol>"},{"location":"lab/xv6lab-paging/#_2","title":"\u6982\u89c8","text":"<p>\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u9875\u8868\uff1f\u5728\u7406\u89e3\u9875\u8868\u524d\uff0c\u6211\u4eec\u9700\u8981\u4e86\u89e3\u6211\u4eec\u4e3a\u4ec0\u4e48\u9700\u8981\u5730\u5740\u7ffb\u8bd1\uff0c\u5730\u5740\u7ffb\u8bd1\u5e0c\u671b\u80fd\u505a\u5230\u4e24\u4ef6\u4e8b\u60c5\uff1a\u9694\u79bb (Isolation) \u548c\u4fdd\u62a4 (Protection)\u3002</p> <p>\u6211\u4eec\u5728\u7406\u8bba\u8bfe\u8bb2 Process \u65f6\u63d0\u5230\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\u3002\u5982\u679c\u6709\u4e24\u4e2a\u8fdb\u7a0b P1 \u548c P2 \u90fd\u80fd\u8bbf\u95ee\u5730\u5740 <code>0x8000</code>\uff0c\u90a3\u4e48\u5b83\u4eec\u4fe9\u6240\u80fd\u770b\u5230\u7684 <code>0x8000</code>\uff0c\u80cc\u540e\u5e94\u8be5\u662f\u4e24\u4e2a\u4e0d\u540c\u5185\u5b58\u533a\u57df\u3002</p> <p>\u6211\u4eec\u5c06\u8fdb\u7a0b\u6240\u80fd\u770b\u5230\u7684\u5730\u5740\u79f0\u4e3a\u865a\u62df\u5730\u5740 (Virtual Address)\uff0c\u5728\u5bf9 DRAM \u8bbf\u95ee\u65f6\u6240\u7528\u7684\u5730\u5740\u79f0\u4e3a\u7269\u7406\u5730\u5740 (Physical Address)\u3002</p> <p>\u7406\u8bba\u4e0a\u6765\u8bf4\uff0c\u6211\u4eec\u80fd\u591f\u5efa\u7acb\u4e00\u4e2a \u5730\u5740\u6620\u5c04\u5173\u7cfb f\uff0c\u5c06\u6bcf\u4e2a\u5408\u6cd5\u7684 VA \u90fd\u6620\u5c04\u5230\u4e00\u4e2a PA\uff0c\u5373 f(VA) = PA\u3002\u5e76\u4e14\uff0c\u5bf9\u4e8e\u4e0d\u540c\u7684\u8fdb\u7a0b P1 \u548c P2\uff0c\u6211\u4eec\u4ee4\u5b83\u4eec\u62e5\u6709\u4e0d\u540c\u7684\u6620\u5c04\u5173\u7cfb f<sub>1</sub> \u548c f<sub>2</sub>\uff0c\u8fd9\u6837\u5373\u53ef\u505a\u5230\u8ba9 P1 \u548c P2 \u770b\u5230\u7684 VA <code>0x8000</code> \u4e0d\u662f\u540c\u4e00\u4e2a PA\u3002</p> <p>\u7406\u8bba\u5f88\u7f8e\u597d\uff0c\u4f46\u662f\u5728\u771f\u5b9e CPU \u7535\u8def\u4e0a\u5b9e\u73b0\u8fd9\u6837\u7684\u5730\u5740\u6620\u5c04\u5173\u7cfb\uff0c\u6211\u4eec\u5c31\u5f97\u8003\u8651\u7535\u8def\u4e0a\u7684\u590d\u6742\u5ea6\u3001\u5b9e\u73b0\u6210\u672c\u548c\u6027\u80fd\u7b49\u56e0\u7d20\u3002</p> <p>Segmentation \u6211\u4eec\u53ef\u4ee5\u5bf9\u7406\u8bba\u8fdb\u884c\u7b80\u5316\u3002\u6ce8\u610f\u5230\u7a0b\u5e8f\u6240\u9700\u8981\u7684\u5185\u5b58\u7a7a\u95f4\u4e00\u822c\u90fd\u662f\u51e0\u4e2a\u8fde\u7eed\u7684\u5927\u5757\uff0c\u4f8b\u5982\u7f16\u8bd1\u4ea7\u751f\u7684 <code>.text</code> \u6bb5\u3001<code>.data</code> \u6bb5\u7b49\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u5c06\u8fde\u7eed\u7684\u7269\u7406\u5730\u5740\u7a7a\u95f4\u5206\u4e3a\u51e0\u4e2a\u6bb5 (Segment)\uff0c\u5e76\u5206\u914d\u7ed9\u4e0d\u540c\u7684\u8fdb\u7a0b\u3002\u5bf9\u4e8e CPU \u800c\u8a00\uff0c\u5b83\u9700\u8981\u770b\u5230\u4e00\u5f20\u63cf\u8ff0\u4e86\u591a\u4e2a Segment \u7684\u5927\u8868 (GDT/LDT)\uff0c\u5176\u4e2d\u6bcf\u4e2a Segment \u63cf\u8ff0\u4e86\u6bb5\u7684\u57fa\u5730\u5740 (Base)\u3001\u957f\u5ea6 (Limit)\u3001\u548c\u6743\u9650 (Flags)\u3002</p> <p>\u6bcf\u4e2a\u8fdb\u7a0b\u5728\u8bbf\u95ee\u5185\u5b58\u65f6\u9700\u8981\u5e26\u4e0a\u6bb5\u9009\u62e9\u5668 (Segment Selector)\uff0c\u8868\u793a\u81ea\u5df1\u8bbf\u95ee\u7684\u5730\u5740\u5c5e\u4e8e\u8fd9\u5f20\u5927\u8868\u7684\u7b2c\u51e0\u4e2a Segment\uff0c\u4ee5\u53ca\u5728\u8be5\u6bb5\u4e2d\u7684\u504f\u79fb\u91cf (Offset)\u3002CPU \u4f1a\u5bf9\u5185\u5b58\u8bbf\u95ee\u91cd\u65b0\u8ba1\u7b97\u5b83\u5b9e\u9645\u5f15\u7528\u7684\u7269\u7406\u5730\u5740\u3002</p> <p></p> <p>\u4f46\u662f\uff0cSegmentation \u5728\u7269\u7406\u5185\u5b58\u7ba1\u7406\u4e0a\u6709\u7740\u4e0d\u591f\u7075\u6d3b\u7684\u7f3a\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u9875\u9762\u673a\u5236\u3002</p> <p>Page \u9875\u9762\u673a\u5236\u5c06\u865a\u62df\u5730\u5740\u7a7a\u95f4\u548c\u7269\u7406\u5730\u5740\u7a7a\u95f4\u5207\u5206\u4e3a \u7b49\u5927\u3001\u5bf9\u9f50 \u7684\u5757\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a \u9875\u9762\uff0c\u5927\u5c0f\u901a\u5e38\u4e3a 4KiB (4096 bytes)\u3002\u8fd9\u6837\u4e00\u6765\uff0c\u5730\u5740\u6620\u5c04\u5173\u7cfb\u5c31\u53d8\u6210\u4e86 \u9875\u9762\u6620\u5c04\u5173\u7cfb\u3002</p> <p>\u6211\u4eec\u5c06\u5730\u5740\u6309\u7167 12 bits (2^^12=4096) \u4e3a\u8fb9\u754c\u5207\u5206\uff0c\u540e 12 bits \u8868\u793a\u8be5\u5730\u5740\u5728\u67d0\u4e2a\u9875\u9762\u4e2d\u7684\u504f\u79fb\u91cf(offset)\uff0c\u800c\u5269\u4f59\u7684\u5730\u5740\u5219\u8868\u793a\u54ea\u4e2a\u9875\u9762\u3002\uff08\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u4e0d\u8bba\u5728\u4ec0\u4e48\u5e73\u53f0\u4e0a\uff0c\u9875\u9762\u5927\u5c0f\u90fd\u662f 2 \u7684\u6574\u6570\u6b21\u65b9\uff0c\u5982 512\u30014096\u300116384\uff0c\u5bf9 CPU \u800c\u8a00\uff0c\u4f4d\u8fd0\u7b97\u6c38\u8fdc\u662f\u6700\u5feb\u6700\u7b80\u6d01\u7684\uff09</p> <p>\u6211\u4eec\u4ee4 <code>VA = {x'VPN, 12'offset}</code>, <code>PA = {x'PPN, 12'offset}</code>\u3002\u8fd9\u6837\uff0c\u6211\u4eec\u4e4b\u524d\u5b9a\u4e49\u7684 <code>f(VA) = PA</code> \u5c31\u53ea\u9700\u8981\u5b9e\u73b0 <code>f(VPN) = PPN</code> \u5373\u53ef\uff0c\u5269\u4e0b\u7684 offset \u53ef\u4ee5\u7167\u642c\u8fc7\u6765\u3002</p> <p>\u9875\u9762\u673a\u5236\u89e3\u51b3\u4e86\u5185\u5b58\u5206\u914d\u5bfc\u81f4\u7684\u788e\u7247\u5316\u95ee\u9898\u3002\u5f53\u7528\u6237\u7a0b\u5e8f\u8981\u6c42\u4e00\u5757\u8fde\u7eed\u7684\u5185\u5b58\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e0d\u518d\u9700\u8981\u5206\u914d \u8fde\u7eed\u7684\u7269\u7406\u5730\u5740 \u7a7a\u95f4\uff0c\u800c\u662f\u53ef\u4ee5\u5728 \u9875\u9762\u6620\u5c04\u5173\u7cfb \u4e2d\u4ee4\u865a\u62df\u5730\u5740\u7a7a\u95f4\u8fde\u7eed\uff0c\u800c\u5176\u5bf9\u5e94\u7684\u7269\u7406\u9875\u9762\u5219\u53ef\u4ee5\u4e0d\u8fde\u7eed\u3002</p> <p>\u90a3\u4e48\uff0c\u6211\u4eec\u8be5\u5982\u4f55\u5b9e\u73b0\u4e00\u4e2a\u5bf9 CPU \u786c\u4ef6\u7535\u8def\u53cb\u597d\u7684\u9875\u9762\u6620\u5c04\u5173\u7cfb\u5462\uff1f</p> <p>Page Table \u5bf9 CPU \u800c\u8a00\uff0c\u57fa\u5730\u5740+\u504f\u79fb\u91cf\u7684\u5730\u5740\u8ba1\u7b97\u6a21\u5f0f\u662f\u975e\u5e38\u7b80\u5355\u7684\u3002\u5c31\u50cf\u6211\u4eec\u5728 C \u8bed\u8a00\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u6570\u7ec4 <code>int a[10]</code>\uff0c\u7f16\u8bd1\u5668\u4f1a\u4e3a\u6211\u4eec\u5206\u914d <code>sizeof(int) * 10 = 40 bytes</code> \u7684\u7a7a\u95f4\uff0c\u7136\u540e\u901a\u8fc7 <code>a</code> \u7684\u57fa\u5730\u5740\u52a0\u4e0a\u5143\u7d20\u7d22\u5f15\u8ba1\u7b97\u76ee\u6807\u5143\u7d20\u7684\u5730\u5740\u3002\u4f8b\u5982\uff0c\u5f53\u6211\u4eec\u8bbf\u95ee <code>a[6]</code> \u65f6\uff0c\u7f16\u8bd1\u5668\u4f1a\u8ba1\u7b97 <code>a[6]</code> \u7684\u5185\u5b58\u5730\u5740\uff1a<code>&amp;a + 6 * sizeof(int)</code>\uff0c\u7136\u540e\u5bf9\u8be5\u5185\u5b58\u5730\u5740\u53d1\u8d77\u8bbf\u5b58\u3002</p> <p>\u9875\u9762\u6620\u5c04\u5173\u7cfb\u4e5f\u662f\u7c7b\u4f3c\u3002\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u8d85\u7ea7\u5927\u7684\u6570\u7ec4\uff0c\u5b83\u7684\u7d22\u5f15\u8868\u793a VPN\uff0c\u5b83\u7684\u6bcf\u4e2a\u5143\u7d20(PTE)\u8868\u793a PPN\u3002\u5bf9\u4e8e CPU \u800c\u8a00\uff0cz\u5728\u6c47\u7f16\u6307\u4ee4\u53d1\u8d77\u8bbf\u5b58\u8bf7\u6c42\uff08\u865a\u62df\u5730\u5740\uff09\u65f6\uff0c\u5b83\u5148\u6309\u7167\u4e0a\u8ff0\u683c\u5f0f\u5c06 <code>VA</code> \u89e3\u7801\u4e3a <code>VPN | offset</code> \uff0c\u7136\u540e\u6309\u7167 <code>base + VPN * sizeof(PTE)</code> \u683c\u5f0f\u8ba1\u7b97\u51fa\u8fd9\u6761 PTE \u7684\u5730\u5740\uff0c\u5e76\u53d1\u8d77\u5bf9\u4e00\u6b21\u5185\u5b58\u8bfb\u53d6\uff0c\u5373\u53ef\u5f97\u5230 PPN \u7684\u503c\uff0c\u6700\u540e\u62fc\u63a5 offset \u540e\uff0cCPU \u5c31\u5f97\u5230\u4e86\u6700\u7ec8\u7684\u7269\u7406\u5730\u5740\uff01\u6700\u540e\u624d\u5bf9\u8fd9\u4e2a\u7269\u7406\u5730\u5740\u8fdb\u884c\u8bbf\u5b58\u3002</p> <p>\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u6837\u7684\u5730\u5740\u8ba1\u7b97\u65b9\u5f0f\u7b80\u76f4\u548c\u8bbf\u95ee\u6570\u7ec4\u4e00\u6a21\u4e00\u6837\uff01\u6211\u4eec\u5c06\u8fd9\u4e2a\u8d85\u5927\u7684\u6570\u7ec4\u79f0\u4e3a \u9875\u8868 (Page Table)\uff0c\u8fd9\u4e2a\u6570\u7ec4\u7684\u57fa\u5730\u5740\u5219\u79f0\u4e3a\u9875\u8868\u57fa\u5730\u5740\u3002</p> <p>\u90a3\u4e48\uff0c\u53e4\u5c14\u4e39\uff0c\u4ee3\u4ef7\u662f\u4ec0\u4e48\u5462\uff1f\u9875\u8868\u7684\u7d22\u5f15\u9700\u8981\u548c <code>VPN</code> \u4e00\u6837\u5927\uff01\u5047\u8bbe\u865a\u62df\u5730\u5740\u548c\u7269\u7406\u5730\u5740\u7684\u957f\u5ea6\u5747\u4e3a 32 bits\uff0c\u5219 VPN \u548c PPN \u7684\u957f\u5ea6\u90fd\u662f 20 bits\uff0c\u90a3\u4e48\u9875\u8868\uff08\u6570\u7ec4\uff09\u5c31\u9700\u8981\u6709 <code>2^20^ = 1Mi</code> \u4e2a\u5143\u7d20\u3002\u7531\u4e8e\u6570\u7ec4\u5143\u7d20\u8981\u5bf9\u9f50\u52302\u7684\u6574\u6570\u6b21\u5e42\u5927\u5c0f\uff0c\u90a3\u4e48\u6bcf\u4e2a PTE \u5c31\u662f 4 bytes\u3002\u6211\u4eec\u60ca\u5947\u7684\u53d1\u73b0\uff0c\u6bcf\u4e2a\u9875\u8868\u5c45\u7136\u8981 4MiB \u7684\u7a7a\u95f4\uff0c\u8fd9\u5728\u4ee5\u524d\u5185\u5b58\u4ef7\u683c\u548c\u5bb9\u91cf\u8fd8\u6ca1\u964d\u4e0b\u6765\u7684\u65f6\u4ee3\u662f\u96be\u4ee5\u60f3\u8c61\u7684\u3002</p> <p>Multi-level Page Table</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u5c31\u4e0d\u518d\u7528\u4e00\u4e2a\u7b80\u5355\u7684\u4e00\u7ef4\u6570\u7ec4\u8868\u793a\u9875\u8868\uff0c\u800c\u662f\u91c7\u7528\u591a\u7ea7\u7684\u3001\u6811\u72b6\u7684\u6570\u7ec4\u3002</p> <p>\u6211\u4eec\u4ee4\u9875\u8868\u7684\u5927\u5c0f\u4e25\u683c\u7b49\u4e8e\u9875\u9762\u5927\u5c0f\u3002\u5047\u8bbe\u865a\u62df\u5730\u5740\u548c\u7269\u7406\u5730\u5740\u7684\u957f\u5ea6\u5747\u5927\u4e8e 32 bits\uff0cPTE \u5927\u5c0f\u4e3a 8 bytes\uff0c\u90a3\u4e48\u6bcf\u4e2a\u9875\u8868\u4e2d\u5c31\u80fd\u88c5\u4e0b <code>4096 / 8 = 512 = 2^9^</code> \u4e2a PTE\u3002\u4e00\u5f20\u9875\u8868\u5373\u80fd\u8868\u793a <code>512 * 4KiB = 2MiB</code> \u7684\u5185\u5b58\u533a\u57df\u3002</p> <p>\u7136\u540e\uff0c\u6211\u4eec\u4ee4 PTE \u53ef\u4ee5\u6307\u5411\u9875\u8868\u7684\u57fa\u5730\u5740\uff0c\u800c\u4e0d\u4e00\u5b9a\u662f\u6700\u7ec8PA\u7684 PPN\uff01\u9875\u8868\u5c31\u6b64\u5206\u4e86\u7b49\u7ea7\uff0c\u9ad8\u4e00\u7ea7\u7684\u9875\u8868\u4e2d\u5305\u542b\u6307\u5411\u4e0b\u4e00\u7ea7\u9875\u8868\u7684\u6307\u9488\u3002\u6211\u4eec\u89c4\u5b9a\u6700\u540e\u4e00\u7ea7\u7684\u9875\u8868\u662f\u9875\u8868\u7684\u7ec8\u70b9\uff0c\u5373\u5b83\u53ea\u80fd\u5305\u542b\u6700\u7ec8\u7684\u7269\u7406\u5730\u5740\u3002</p> <p>\u90a3\u4e48\uff0c\u5012\u6570\u7b2c\u4e8c\u7ea7\u9875\u8868\u4e2d\u53ef\u4ee5\u5305\u542b 512 \u4e2a\u5012\u6570\u7b2c\u4e00\u7ea7\u9875\u8868\u7684\u6307\u9488\uff0c\u90a3\u4e48\u5b83\u5c31\u80fd\u7ba1\u7406 <code>512 * 2MiB = 1 GiB</code> \u7684\u7a7a\u95f4\u4e86\u3002\u90a3\u4e48\uff0c\u600e\u4e48\u5728\u8fd9\u4e24\u7ea7\u9875\u8868\uff08\u6570\u7ec4\uff09\u4e2d\u8fdb\u884c\u7d22\u5f15\u5462\uff1f</p> <p>\u6211\u4eec\u4e5f\u5c06 VPN \u62c6\u6210\u591a\u7ea7\u7684\u3002\u5047\u8bbe\u6211\u4eec\u4f7f\u7528\u4e09\u7ea7\u9875\u8868\u3002\u4e0e\u4e4b\u524d\u7c7b\u4f3c\uff0cVPN \u5c06\u4f5c\u4e3a\u9875\u8868\u6570\u7ec4\u7684\u7d22\u5f15\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u8fd9\u6b21\u6709\u4e09\u4e2a\u9875\u8868\uff0c\u90a3\u4e48 VPN \u5e94\u8be5\u4e5f\u88ab\u62c6\u6210\u4e09\u5757\uff1a<code>VPN = {VPN2, VPN1, VPN0}</code>\uff0c\u6bcf\u4e00\u4e2a VPNx \u90fd\u5728\u6bcf\u4e00\u7ea7\u9875\u8868\u4e2d\u505a\u7d22\u5f15\uff01</p> <p>\u989d\u5916\u7684\uff0c\u6211\u4eec\u5f3a\u5236\u89c4\u5b9a\u9875\u8868\u5927\u5c0f\u4e3a\u9875\u9762\u5927\u5c0f\uff0c\u6240\u4ee5\u6bcf\u4e00\u4e2a VPNx \u5e94\u8be5\u4e3a 9 bits\u3002\u56e0\u6b64 VA \u7684\u957f\u5ea6\u5e94\u8be5\u662f <code>9+9+9+12 = 39</code>\u3002\u606d\u559c\u4f60\uff0c\u4f60\u91cd\u65b0\u53d1\u660e\u4e86 RISC-V \u4e2d\u7684 Sv39\uff01\u5047\u5982\u6211\u4eec\u9700\u8981\u56db\u7ea7\u9875\u8868\uff0c\u90a3\u4e48 VA \u7684\u957f\u5ea6\u5219\u662f 48 bits\uff0c\u8fd9\u5c31\u662f Sv48 \u6a21\u5f0f\uff01</p> <p>TLB </p> <p>\u90a3\u4e48\uff0c\u6211\u4eec\u8fd8\u6709\u4ec0\u4e48\u4ee3\u4ef7\u5462\uff1f</p> <p>--- \u4ee5\u4e0b\u4e3a\u6b63\u6587</p>"},{"location":"lab/xv6lab-paging/#segmentation","title":"Segmentation","text":"<p>\u4ece\u5bf9\u5185\u5b58\u8bbf\u95ee\u4fdd\u62a4\u800c\u8a00\uff0c\u6211\u4eec\u5e0c\u671b\u5bf9\u5185\u5b58\u7684\u8bbf\u95ee\u662f\u5e26\u6709\u6743\u9650\u4fdd\u62a4\u7684\u3002\u8fd9\u5305\u62ec\u4e24\u4e2a\u5c42\u9762\uff1a</p> <ol> <li>\u8be5\u5185\u5b58\u5730\u5740\u662f\u5426\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u53ef\u6267\u884c\u3002</li> <li>\u8be5\u5185\u5b58\u5730\u5740\u662f\u5426\u5141\u8bb8\u4f4e\u7279\u6743\u7ea7\u8bbf\u95ee\u3002</li> </ol> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5185\u5b58\u5730\u5740\uff0c\u6211\u4eec\u90fd\u5e0c\u671b\u80fd\u68c0\u67e5\u5b83\u7684\u64cd\u4f5c\u6743\u9650\u662f\u5426\u7b26\u5408\u539f\u5148\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u3002</p> <p>\u5728 CPU \u5b9e\u73b0\u4e0a\uff0c\u5185\u5b58\u662f\u4ee5\u5b57\u8282\u4e3a\u5355\u4f4d\u6765\u5bfb\u5740\u7684\u3002\u5982\u679c\u8981\u5b9e\u73b0\u5bf9\u6bcf\u4e2a\u5b57\u8282\u7684\u8bbf\u95ee\u6743\u9650\u90fd\u80fd\u8fdb\u884c\u7ba1\u7406\uff0c\u8fd9\u6837\u7684\u4ee3\u4ef7\u662f\u96be\u4ee5\u73b0\u8c61\u7684\u3002 \u4f46\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba9\u76f8\u540c\u6743\u9650\u7684\u4ee3\u7801\u3001\u6570\u636e\u6392\u5e03\u5728\u4e00\u8d77\uff0c\u8fd9\u6837\u5373\u53ef\u5c06\u6574\u4e2a\u7a0b\u5e8f\u7684\u5185\u5b58\u7a7a\u95f4\u5206\u4e3a\u51e0\u4e2a\u5927\u5757\uff0c\u6bcf\u4e2a\u5757\u5747\u6709\u81ea\u5df1\u7684\u8d77\u59cb\u5730\u5740(Base)\u548c\u5927\u5c0f\u9650\u5236(Limit)\uff0c\u4ee5\u53ca\u6743\u9650\u8bbe\u7f6e\uff0c\u8fd9\u5c31\u662f\u4f7f\u7528 Segmentation \u8fdb\u884c\u5185\u5b58\u4fdd\u62a4\u7684\u65b9\u5f0f\u3002 </p> <p></p> <p>Segmentation \u5728\u5185\u5b58\u7a7a\u95f4\u7684\u7ba1\u7406\u4e0a\u6709\u7740\u8bf8\u591a\u52a3\u52bf\uff0c\u4f8b\u5982\u8981\u6c42\u7269\u7406\u5185\u5b58\u8fde\u7eed\u3001\u96be\u4ee5\u52a8\u6001\u8c03\u8282\u5927\u5c0f\u3001\u5b58\u5728\u788e\u7247\u5316\u7684\u95ee\u9898\u3002\u6240\u4ee5\uff0c\u73b0\u4ee3 CPU \u548c\u64cd\u4f5c\u7cfb\u7edf\u5747\u4f7f\u7528\u9875\u8868\uff08Paging\uff09\u673a\u5236\u6765\u5b9e\u73b0\u5185\u5b58\u7ba1\u7406\u3002</p>"},{"location":"lab/xv6lab-paging/#paging","title":"Paging","text":"<p>\u5206\u9875\u673a\u5236\uff0c\u662f\u5c06\u7a0b\u5e8f\u7a7a\u95f4\uff08\u865a\u62df\u5730\u5740\uff09\u5207\u5272\u6210\u76f8\u540c\u5927\u5c0f\u7684\u82e5\u5e72\u4e2a\u9875\u9762\uff0c\u540c\u65f6\u5c06\u7269\u7406\u5185\u5b58\u4e5f\u5207\u5272\u6210\u540c\u6837\u5927\u5c0f\u7684\u591a\u4e2a\u9875\u9762\uff0c\u4ece\u800c\u53ef\u4ee5\u5728\u7269\u7406\u5730\u5740\u4e0d\u8fde\u7eed\u7684\u60c5\u51b5\u4e0b\uff0c\u7ed9\u8fdb\u7a0b\u5206\u914d\u8db3\u591f\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5e76\u4e14\u4ece\u865a\u62df\u5730\u5740\u7684\u89d2\u5ea6\u770b\u8fd9\u4e2a\u7a7a\u95f4\u662f\u8fde\u7eed\u7684\u3002</p> <p>\u4e3a\u4ec0\u4e48\u9700\u8981\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff1f</p> <p>\u5982\u679c\u6211\u4eec\u53ea\u6709\u7269\u7406\u5185\u5b58\u7a7a\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u4e5f\u53ef\u4ee5\u5199\u7a0b\u5e8f\uff0c\u4f46\u662f\u6240\u6709\u7684\u7a0b\u5e8f\uff0c\u5305\u62ec\u5185\u6838\uff0c\u5305\u62ec\u7528\u6237\u7a0b\u5e8f\uff0c\u90fd\u5728\u540c\u4e00\u4e2a\u5730\u5740\u7a7a\u95f4\u91cc\uff0c\u7528\u6237\u7a0b\u5e8f\u8bbf\u95ee\u7684 <code>0x80200000</code> \u548c\u5185\u6838\u8bbf\u95ee\u7684 <code>0x80200000</code> \u662f\u540c\u4e00\u4e2a\u5730\u5740\u3002\u8fd9\u6837\u597d\u4e0d\u597d\uff1f\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u7a0b\u5e8f\u5728\u8fd0\u884c\uff0c\u90a3\u4e5f\u65e0\u6240\u8c13\u3002\u4f46\u5f88\u591a\u7a0b\u5e8f\u4f7f\u7528\u540c\u4e00\u4e2a\u5185\u5b58\u7a7a\u95f4\uff0c\u5c31\u4f1a\u6709\u95ee\u9898\uff1a\u600e\u6837\u9632\u6b62\u7a0b\u5e8f\u4e4b\u95f4\u4e92\u76f8\u5e72\u6270\uff0c\u751a\u81f3\u4e92\u76f8\u641e\u7834\u574f\uff1f</p> <p>\u6bd4\u8f83\u7c97\u66b4\u7684\u65b9\u5f0f\u5c31\u662f\uff0c\u6211\u8ba9\u7528\u6237\u7a0b\u5e8f\u8bbf\u95ee\u7684<code>0x80200000</code>\u548c\u5185\u6838\u8bbf\u95ee\u7684<code>0x80200000</code>\u4e0d\u662f\u4e00\u4e2a\u5730\u5740\u3002\u4f46\u662f\u6211\u4eec\u53ea\u6709\u4e00\u5757\u5185\u5b58\uff0c\u4e3a\u4e86\u521b\u9020\u4e24\u4e2a\u4e0d\u540c\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u5f15\u5165\u4e00\u4e2a\u201d\u7ffb\u8bd1\u201c\u673a\u5236\uff1a\u7a0b\u5e8f\u4f7f\u7528\u7684\u5730\u5740\uff08\u865a\u62df\u5730\u5740\uff09\u9700\u8981\u7ecf\u8fc7\u4e00\u6b65\u201d\u7ffb\u8bd1\u201c\u624d\u80fd\u53d8\u6210\u771f\u6b63\u7684\u5185\u5b58\u7684\u7269\u7406\u5730\u5740\u3002\u8fd9\u4e2a\u201d\u7ffb\u8bd1\u201c\u8fc7\u7a0b\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u201d\u8bcd\u5178\u201c\uff08\u9875\u8868\uff09\u5b9e\u73b0---\u7ed9\u51fa\u7ffb\u8bd1\u4e4b\u524d\u7684\u5730\u5740\uff0c\u53ef\u4ee5\u5728\u8bcd\u5178\u91cc\u67e5\u627e\u7ffb\u8bd1\u540e\u7684\u5730\u5740\u3002</p> <p>\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u6709\u552f\u4e00\u7684\u4e00\u672c\u201d\u8bcd\u5178\u201c\uff0c\u800c\u5b83\u80fd\u4f7f\u7528\u7684\u5185\u5b58\u4e5f\u5c31\u53ea\u6709\u4ed6\u7684\u201d\u8bcd\u5178\u201c\u6240\u5305\u542b\u7684\u3002</p> <p>\"\u8bcd\u5178\"\u662f\u5426\u5bf9\u80fd\u4f7f\u7528\u7684\u6bcf\u4e2a\u5b57\u8282\u90fd\u8fdb\u884c\u7ffb\u8bd1\uff1f\u6211\u4eec\u53ef\u4ee5\u60f3\u8c61\uff0c\u5b58\u50a8\u6bcf\u4e2a\u5b57\u8282\u7ffb\u8bd1\u7684\u7ed3\u679c\u81f3\u5c11\u9700\u8981\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u4f7f\u75281MB\u7684\u5185\u5b58\u5c06\u81f3\u5c11\u9700\u8981\u6784\u90201MB\u7684\u201d\u8bcd\u5178\u201c\uff0c\u8fd9\u6548\u7387\u592a\u4f4e\u4e86\u3002\u89c2\u5bdf\u5230\uff0c\u4e00\u4e2a\u7a0b\u5e8f\u4f7f\u7528\u5185\u5b58\u7684\u6570\u91cf\u7ea7\u901a\u5e38\u8fdc\u5927\u4e8e\u5b57\u8282\uff0c\u81f3\u5c11\u4ee5KB\u4e3a\u5355\u4f4d\uff08\u6240\u4ee5\u4e0a\u53e4\u65f6\u4ee3\u7684\u4eba\u8bf4\u7684\u662f\"640K\u5bf9\u6bcf\u4e2a\u4eba\u90fd\u591f\u4e86\"\u800c\u4e0d\u662f\"640B\u5bf9\u6bcf\u4e2a\u4eba\u90fd\u591f\u4e86\"\uff09\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8003\u8651\uff0c\u628a\u8fde\u7eed\u7684\u5f88\u591a\u5b57\u8282\u5408\u5728\u4e00\u8d77\u7ffb\u8bd1\uff0c\u8ba9\u4ed6\u4eec\u7ffb\u8bd1\u524d\u540e\u7684\u6570\u503c\u4e4b\u5dee\u76f8\u540c\uff0c\u8fd9\u5c31\u662f\"\u9875\"\u3002</p>"},{"location":"lab/xv6lab-paging/#_3","title":"\u865a\u62df\u5730\u5740 =&gt; \u7269\u7406\u5730\u5740","text":"<p>\u5206\u9875\u673a\u5236\u5f88\u91cd\u8981\u7684\u4e00\u70b9\u662f\u5982\u4f55\u5efa\u7acb\u548c\u89e3\u6790\u865a\u62df\u5730\u5740\u5230\u7269\u7406\u5730\u5740\u7684\u6620\u5c04\uff0c\u4e0b\u9762\u6211\u4eec\u4ece\u201c\u5982\u4f55\u4ece\u865a\u62df\u5730\u5740\u83b7\u5f97\u76f8\u5e94\u7684\u7269\u7406\u5730\u5740\u201d\u7684\u89d2\u5ea6\u8fdb\u884c\u4ecb\u7ecd\uff1a</p>"},{"location":"lab/xv6lab-paging/#_4","title":"\u4e00\u7ea7\u9875\u8868","text":"<p>\u5982\u56fe\u6240\u793a\u662f\u4e00\u4e2a\u4e00\u7ea7\u9875\u8868\u5206\u9875\u673a\u5236\uff08\u4e00\u7ea7\u5bf9\u5e94\u4e8e\u540e\u9762\u7684\u591a\u7ea7\uff0c\u4e00\u7ea7\u9875\u8868\u53ea\u9700\u8981\u67e5\u8be2\u4e00\u5c42\u9875\u8868\u5373\u53ef\u5f97\u5230\u7269\u7406\u5730\u5740\uff0c\u4e0b\u79f0\"\u5355\u7ea7\u9875\u8868\"\uff09\uff1a</p> <p></p> <p>\u4ee5\u4e0a\u56fe\u4e3a\u4f8b\uff0c\u6211\u4eec\u9996\u5148\u5f97\u5230\u4e00\u4e2a \u865a\u62df\u5730\u5740\uff08 Virtual Address\uff09\uff0c\u8fd9\u4e2a\u5730\u5740\u957f\u5ea6\u4e3a6\u4f4d\uff0c\u5176\u4e2d 5 ~ 4 \u4f4d\uff08\u9ad82\u4f4d\uff09\u4e3a \u9875\u53f7\uff08VPN\uff0cVirtual Page Number\uff09 \uff0c 3 ~ 0 \u4f4d\uff08\u4f4e4\u4f4d\uff09\u4e3a \u504f\u79fb\u91cf\uff08Offset\uff09 \u3002</p> <p>\u901a\u8fc7\u865a\u62df\u5730\u5740\uff0c\u6211\u4eec\u53ef\u4ee5\u67e5\u8be2 \u9875\u8868 \uff08 Page Table \uff09\uff0c\u9875\u8868\u5b58\u5728\u4e8e \u9875\u8868\u57fa\u5730\u5740\uff08 PageTablePtr,Page Table Pointer \uff0c\u662f\u4e2a\u7269\u7406\u5730\u5740\uff09\u6240\u6307\u5411\u7684\u5185\u5b58\u7a7a\u95f4\u4e2d\uff0c\u7531\u8fde\u7eed\u5b58\u50a8\u7684\u82e5\u5e72\u4e2a \u9875\u8868\u9879\uff08PTE\uff0cPage Table Entry\uff09 \u6784\u6210\u3002\u5728\u4e00\u7ea7\u9875\u8868\u4e2d\uff0c\u6bcf\u4e2a\u9875\u8868\u9879\u5185\u5bb9\u5373\u4e3a \u7269\u7406\u9875\u53f7\uff08Page Frame #\uff09+\u90e8\u5206\u6807\u5fd7\u4f4d \u3002\u5c3d\u7ba1\u56fe\u4e2d\u6bcf\u4e2a\u9875\u8868\u9879\u770b\u4f3c\u5305\u542b \u9875\u53f7\uff08Page #\uff09 \u4f46\u662f\u5728\u5b9e\u9645\u7684\u8bbe\u8ba1\u4e2d\uff0c \u9875\u53f7(VPN)\u5e76\u4e0d\u5199\u5728\u9875\u8868\u9879(PTE)\u4e2d \uff0c\u7531\u4e8e\u9875\u8868\u9879\u662f\u8fde\u7eed\u5206\u5e03\u7684\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u9875\u8868\u9879\u7684\u5927\u5c0f\uff08\u6709\u591a\u5c11\u4f4d\uff09\u4ee5\u53ca\u865a\u62df\u5730\u5740\u9875\u53f7\uff08VPN\uff0c\u4ee3\u8868\u8981\u67e5\u8be2\u7b2c\u51e0\u4e2a\u9875\u8868\u9879\uff09\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7 <code>\u9875\u8868\u9996\u5730\u5740+\u9875\u53f7\u00d7\u9875\u8868\u9879\u5927\u5c0f</code> \u5f97\u5230\u5bf9\u5e94\u7684\u9875\u8868\u9879\u5730\u5740\uff0c\u67e5\u8be2\u8be5\u5730\u5740\u5bf9\u5e94\u5185\u5bb9\u5373\u53ef\u5f97\u5230\u7269\u7406\u9875\u53f7\u3002\u9875\u8868\u9996\u5730\u5740\u662f\u5b58\u50a8\u5728\u67b6\u6784\u6307\u5b9a\u7684\u5bc4\u5b58\u5668\u4e2d\u7684\u3002</p> <p>\u5f97\u5230\u7269\u7406\u9875\u53f7\u540e\uff0c\u901a\u8fc7 <code>\u7269\u7406\u9875\u53f7\u00d7\u9875\u9762\u5927\u5c0f</code> \u5373\u53ef\u5f97\u5230\u6240\u5728\u9875\u7684\u7269\u7406\u5730\u5740\uff08\u7269\u7406\u7a7a\u95f4\u9996\u5730\u5740\u4e3a0x0\uff09\u3002\u4e00\u9875\u53ef\u80fd\u5f88\u5927\uff0c\u5982\u4f55\u5f97\u5230\u4e00\u9875\u4e2d\u5177\u4f53\u67d0\u4e2a\u5b57\u8282\u7684\u5730\u5740\u5462\uff1f\u901a\u8fc7\u504f\u79fb\u91cf\uff0c <code>\u9875\u7269\u7406\u5730\u5740+\u504f\u79fb\u91cf</code> \u5373\u53ef\u5f97\u5230\u5177\u4f53\u865a\u62df\u5730\u5740\u5bf9\u5e94\u7684\u5177\u4f53\u7269\u7406\u5730\u5740\u3002</p> <p>\u4e00\u4e2a\u4f8b\u5b50</p> <p>\u5047\u8bbe\u9875\u9762\u5927\u5c0f\u4e3a 4KiB \uff0c\u5982\u679c\u60f3\u8981\u5b9a\u4f4d\u5230\u9875\u9762\u7684\u6bcf\u4e00\u4e2a Byte \uff0c\u6211\u4eec\u7684\u504f\u79fb\u91cf\u5219\u9700\u80fd\u8868\u793a 4096 \u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\uff0c\u56e0\u6b64\u5bf9\u4e8e 4KiB \u5927\u5c0f\u7684\u9875\u9762\u6765\u8bf4\uff0c\u504f\u79fb\u91cf\u7684\u4f4d\u6570\u4e3a12\u4f4d\uff082<sup>12</sup>=4096\uff09\u3002\u6216\u8005\u8bf4\uff0c\u504f\u79fb\u91cf\u7684\u4f4d\u6570\u4e3a12\u4f4d\u53ef\u4ee5\u63a8\u51fa\u9875\u9762\u5927\u5c0f\u4e3a 2<sup>12</sup> \u4e2a Byte \u3002</p> <p>\u5728\u56fe\u7247\u7684\u4e00\u7ea7\u9875\u8868\u4e2d\uff0c Offset \u4e3a4\u4f4d\uff0c\u53ef\u4ee5\u5f97\u77e5\u9875\u9762\u5927\u5c0f\u4e3a2<sup>4</sup>=16B\u3002\u5982\u679c\u7ed9\u5b9a\u865a\u62df\u5730\u5740100100<sub>2</sub>\uff0c\u53ef\u4ee5\u5f97\u51fa\u5176\u9875\u53f7\u4e3a10<sub>2</sub>\uff0c\u53732<sub>10</sub>\uff0c\u901a\u8fc7\u9875\u53f72<sub>10</sub>\u53ef\u4ee5\u67e5\u5230\u5bf9\u5e94\u7684\u9875\u8868\u9879\u5185\u5bb9\u4e3a5<sub>10</sub>\u30025\u662f\u7269\u7406\u9875\u53f7\uff0c\u53ef\u4ee5\u6c42\u5f97\u7269\u7406\u9875\u9762\u5730\u5740\uff1a \u7269\u7406\u9996\u5730\u5740+\u7269\u7406\u9875\u53f7\u00d7\u9875\u9762\u5927\u5c0f=0+5\u00d716=80<sub>10</sub>\u3002100100\u4e2d\u4f4e\u56db\u4f4d\u504f\u79fb\u91cf\u4e3a0100\uff0c\u56e0\u6b64\u67e5\u8be2\u7684\u662f\u8be5\u9875\u9762\u7684\u7b2c5\u4e2a\u5b57\u8282\u5bf9\u5e94\u7684\u5730\u5740\uff08\u5730\u57400\u4e5f\u662f\u4e00\u4e2a\u5b57\u8282\uff09\uff0c\u5219\u8be5\u7269\u7406\u5730\u5740\u4e3a80+4=84<sub>10</sub>\uff085*16+4=0101\u5de6\u79fb\u56db\u4f4d+0100=0101 0100<sub>2</sub>\uff09\u3002\u9700\u8981\u6ce8\u610f\u8fd0\u7b97\u8fc7\u7a0b\u4e2d\u662f2\u8fdb\u5236\u8fd8\u662f10\u8fdb\u5236\u8fd8\u662f16\u8fdb\u5236\u6570\uff08\u5b58\u50a8\u80af\u5b9a\u662f2\u8fdb\u5236\uff09\u3002</p>"},{"location":"lab/xv6lab-paging/#_5","title":"\u591a\u7ea7\u9875\u8868","text":"<p>\u7cfb\u7edf\u4e2d\uff0c\u901a\u5e38\u9875\u9762\u5927\u5c0f\u662f 4KiB\u3002\u5047\u8bbe 32 \u4f4d\u7cfb\u7edf\u4e2d\uff0c\u865a\u62df\u5730\u5740\u7a7a\u95f4\u957f\u5ea6\u4e3a 32bits\uff0c\u5373 <code>2^32 = 4GiB</code>\uff0c\u90a3\u4e48\u5728\u5355\u7ea7\u9875\u8868\u6a21\u5f0f\u4e0b\uff0c\u5c31\u9700\u89811M\u4e2a\u9875\u8868\u9879\u6765\u5bf9\u5e94\u4e0d\u540c\u7684\u7269\u7406\u9875\u3002\u5047\u8bbe\u4e00\u4e2a\u9875\u8868\u9879\u4e3a4B\uff0c\u5219\u4e00\u4e2a\u9875\u8868\u5c31\u6709 4MiB \u3002\u7531\u4e8e\u865a\u62df\u5730\u5740\u662f\u8fde\u7eed\u7684\uff08\u76f8\u5f53\u4e8e\u9ad8\u4f4d VPN \u662f\u8fde\u7eed\u7684\uff09\uff0c\u800cPTE\u7684\u5b58\u50a8\u65b9\u5f0f\u4e5f\u662f\u76f8\u5f53\u4e8e\u6570\u7ec4\u7684\u8fde\u7eed\u5b58\u50a8\u65b9\u5f0f\uff0c\u56e0\u6b64\u5373\u4f7f\u8fdb\u7a0b\u5b9e\u9645\u4f7f\u7528\u7684\u7a7a\u95f4\u975e\u5e38\u5c0f\uff0c\u5b83\u4e5f\u9700\u8981\u8fde\u7eed\u5b8c\u6574\u7684\u9875\u8868\u6765\u8fdb\u884c\u5730\u5740\u8f6c\u6362\uff08\u4e0d\u80fd\u79fb\u9664\u4e2d\u95f4\u4e0d\u4f7f\u7528\u7684 PTE \uff09\u3002\u800c\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u9664\u4e86\u5185\u6838\u9875\u8868\uff0c\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u8fd8\u4f1a\u5206\u914d\u81ea\u5df1\u7684\u9875\u8868\uff0c\u8fdb\u7a0b\u591a\u7684\u60c5\u51b5\u4e0b\uff0c\u5b58\u50a8\u6240\u6709\u9875\u8868\u7684\u5f00\u9500\u5c31\u53d8\u5f97\u5f88\u5927\u3002</p> <p>\u56e0\u6b64\u9700\u8981\u7528\u5230\u591a\u7ea7\u9875\u8868\uff0c\u5982\u56fe\u6240\u793a\uff0c\u662f\u4e00\u4e2a\u4e8c\u7ea7\u9875\u8868\u5206\u9875\u673a\u5236\uff08Sv32\uff09\uff1a</p> <p></p> <p>\u4e0e\u5355\u7ea7\u9875\u8868\u4e0d\u540c\u7684\u662f\uff0cSv32 \u5c06\u865a\u62df\u5730\u5740\u5206\u5272\u6210\u4e86\u4e09\u4e2a\u90e8\u5206\uff1a<code>VPN[1], VPN[0], offset</code>\u3002Sv32 \u4e2d\uff0c\u6bcf\u4e2a\u9875\u9762\u5927\u5c0f 4KiB\uff0c\u6bcf\u4e2a PTE 4 Bytes\uff0c\u6bcf\u4e2a\u9875\u8868\u4e2d\u6709 <code>2^10 = 1024</code> \u4e2a PTE\u3002</p> <p>\u56fe\u4e2d\uff0c32\u4f4d\u865a\u62df\u5730\u5740\u7684\u7ffb\u8bd1\u8fc7\u7a0b\u53d8\u6210\u4e86\u5982\u4e0b\u6d41\u7a0b\uff1a</p> <pre><code>    1. \u901a\u8fc7 `PageTablePtr + VPN1 * 4` \u5f97\u5230\u7b2c\u4e00\u7ea7PTE\u5730\u5740\uff08`PageTablePtr`\u5b58\u50a8\u4e8e\u6307\u5b9a\u5bc4\u5b58\u5668\u4e2d\uff09\u3002\n    2. \u53d6\u5f97\u7b2c\u4e00\u7ea7 PTE \u4e2d\u7684PFN\uff0c\u5b83\u4ee3\u8868\u7740\u7b2c\u4e8c\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740\uff0c\u901a\u8fc7 `PFN * 4Ki` \u5f97\u5230\u7b2c\u4e8c\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740\u3002\n    3. \u901a\u8fc7 `\u7b2c\u4e8c\u7ea7\u9875\u8868\u57fa\u5730\u5740+ VPN0 * 4` \u53ef\u4ee5\u5f97\u5230\u7b2c\u4e8c\u7ea7PTE\u7684\u5730\u5740\n    4. \u53d6\u5f97\u7b2c\u4e8c\u7ea7 PTE \u4e2d\u7684PFN\uff0c\u5b83\u4ee3\u8868\u7740\u6700\u7ec8\u7684\u7269\u7406\u9875\u9762\u3002\u901a\u8fc7 `PFN * 4Ki + offset` \u53ef\u4ee5\u5f97\u5230\u6700\u7ec8\u7684\u7269\u7406\u5730\u5740\u3002\n</code></pre> <p>\u601d\u8003</p> <p>\u4e3a\u4ec0\u4e48\u591a\u7ea7\u9875\u8868\u76f8\u6bd4\u5355\u7ea7\u9875\u8868\u53ef\u4ee5\u8282\u7701\u9875\u9762\u5f00\u9500\u5462\uff1f</p> <p>\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a 4GiB \u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u9875\u9762\u5927\u5c0f\u4e3a 4KiB\uff0c\u4e14\u6bcf\u4e2a\u9875\u8868\u9879\uff08PTE\uff09\u7684\u5927\u5c0f\u4e3a 4Byte\u3002\u5982\u679c\u4e00\u4e2a\u8fdb\u7a0b\u53ea\u9700\u8981\u4f7f\u7528\u9ad8\u865a\u62df\u5730\u5740\u7a7a\u95f4 (0xffff_f000) \u7684 1 \u9875 4KiB \u7a7a\u95f4\u548c\u4f4e\u865a\u62df\u5730\u5740\u7a7a\u95f4 (0x0000_0000) \u7684 1 \u9875 4KiB \u7a7a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u8ba1\u7b97\uff0c\u6bd4\u8f83\u5355\u7ea7\u9875\u8868\u548c\u4e8c\u7ea7\u9875\u8868\u673a\u5236\u4e0b\uff0c\u8fdb\u7a0b\u6240\u9700\u7684\u9875\u8868\u7a7a\u95f4\u3002</p> <p>\u5355\u7ea7\u9875\u8868\uff1a \u5728\u5355\u7ea7\u9875\u8868\u7684\u60c5\u51b5\u4e0b\uff0c\u5c3d\u7ba1\u6211\u4eec\u53ea\u9700\u8981\u7b2c0\u4e2a\u548c\u6700\u540e\u4e00\u4e2aPTE\uff0c\u4f46\u662f\u8fd8\u662f\u9700\u8981 4GiB / 4KiB = 1M \u4e2a \u8fde\u7eed\u7684 \u9875\u8868\u9879\u6765\u6620\u5c04\u6574\u4e2a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002\u56e0\u6b64\uff0c\u5355\u7ea7\u9875\u8868\u673a\u5236\u6240\u9700\u8981\u7684\u9875\u8868\u5927\u5c0f\u662f 1M * 4Byte = 4MiB\u3002</p> <p>\u591a\u7ea7\u9875\u8868\uff1a \u5728\u591a\u7ea7\u9875\u8868\u673a\u5236\u4e2d\uff0c\u6bcf\u5c0f\u4e00\u7ea7\u9875\u8868\u6240\u80fd\u8868\u793a\u7684\u5730\u5740\u7a7a\u95f4\u5927\u5c0f\u662f\u9010\u7ea7\u589e\u52a0\u7684\u3002 \u4ee5 Sv32 \u4e3a\u4f8b\uff0c\u7b2c\u4e8c\u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2a PTE \u7ba1\u7406\u7740 <code>4KiB</code> \u7684\u7a7a\u95f4\uff0c\u90a3\u4e48\u6574\u4e2a\u7b2c\u4e8c\u7ea7\u9875\u8868\u80fd\u7ba1\u7406 <code>1024 * 4KiB = 4 MiB</code> \u7684\u7a7a\u95f4\uff1b\u7b2c\u4e00\u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2a PTE \u7ba1\u7406\u7740\u4e00\u5f20\u7b2c\u4e8c\u7ea7\u9875\u8868\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u7b2c\u4e00\u7ea7\u4e2d\u7684\u6bcf\u4e2a PTE \u5b9e\u9645\u4e0a\u80fd\u7ba1\u7406 <code>4 MiB</code> \u7684\u7a7a\u95f4\u3002</p> <p>\u5bf9\u4e8e\u5730\u5740\u7a7a\u95f4\u4e2d\u5927\u7247\u7684\u3001\u8fde\u7eed\u7684\u7a7a\u6d1e\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4e0d\u4e3a\u4ed6\u5206\u914d\u4e8c\u7ea7\u9875\u8868\uff0c\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u591a\u7ea7\u9875\u8868\u53ef\u4ee5\u8282\u7ea6\u7a7a\u95f4\u3002</p> <p>\u5bf9\u4e8e\u4e0a\u8ff0\u60c5\u51b5\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5728\u4e00\u7ea7\u9875\u8868\u4e2d\u5206\u914d\u4e24\u4e2a PTE\uff0c\u5206\u522b\u7ba1\u7406\u4e24\u4e2a\u7b2c\u4e8c\u7ea7\u9875\u8868\uff1b\u5728\u7b2c\u4e00\u4e2a\u7b2c\u4e8c\u7ea7\u9875\u8868\u4e2d\uff0c\u6211\u4eec\u7528\u7b2c0\u4e2a PTE \u6620\u5c04\u865a\u62df\u5730\u5740 <code>0x0000_0000</code>\uff1b\u5728\u7b2c\u4e8c\u4e2a\u7b2c\u4e8c\u7ea7\u9875\u8868\u4e2d\uff0c\u6211\u4eec\u7528\u7b2c 1023 \u4e2a PTE \u6620\u5c04\u865a\u62df\u5730\u5740 <code>0xffff_f000</code>\u3002</p> <p>\u603b\u7ed3\uff1a \u4e3a\u4e86\u7ba1\u7406\u8fd9\u4e24\u4e2a\u865a\u62df\u9875\u9762\uff0c\u4e8c\u7ea7\u9875\u8868\u9700\u8981 2 \u4e2a\u4e8c\u7ea7\u9875\u8868\u548c 1 \u4e2a\u7b2c\u4e00\u7ea7\u9875\u8868\uff08\u5176\u4f59\u672a\u7528\u5230\u7684\u4e8c\u7ea7\u9875\u8868\u7684 PTE \u53ef\u4ee5\u6807\u8bb0\u4e3a\u4e0d\u53ef\u7528\uff0c\u65e0\u9700\u5206\u914d\u7a7a\u95f4\uff09\u3002\u7531\u4e8e\u7b2c\u4e00\u7ea7\u548c\u7b2c\u4e8c\u7ea7\u9875\u8868\u7684\u5927\u5c0f\u5747\u4e3a 4KB\uff0c\u56e0\u6b64\u603b\u5171\u9700\u8981 2 * 4KB + 4KB = 12KB \u7684\u9875\u8868\u7a7a\u95f4\u3002</p> <p>\u901a\u8fc7\u8fd9\u4e2a\u4f8b\u5b50\u53ef\u4ee5\u770b\u51fa\uff0c\u4e8c\u7ea7\u9875\u8868\u673a\u5236\u901a\u8fc7\u5c42\u7ea7\u5316\u7684\u7ba1\u7406\uff0c\u663e\u8457\u51cf\u5c11\u4e86\u9875\u8868\u7684\u7a7a\u95f4\u5f00\u9500\uff0c\u5c24\u5176\u662f\u5728\u53ea\u9700\u8981\u6620\u5c04\u5c11\u91cf\u5185\u5b58\u65f6\u3002</p> <p>\u6ce8\u610f</p> <p>\u5c06\u865a\u62df\u5730\u5740\u7ffb\u8bd1\u6210\u7269\u7406\u5730\u5740\u7684\u5de5\u4f5c\u662f\u7531 CPU \u7684\u5185\u5b58\u7ba1\u7406\u5355\u5143\uff08MMU\uff0cMemory Management Unit\uff09\u5b8c\u6210\u7684\uff0c\u5e76\u4e0d\u9700\u8981\u6211\u4eec\u7f16\u5199\u4ee3\u7801\u8fdb\u884c\u64cd\u4f5c\u3002</p> <p>\u6211\u4eec\u9700\u8981\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5b8c\u6210\u7684\u662f\"\u8bcd\u5178\"\u4e5f\u5c31\u662f\u9875\u8868\u7684\u7f16\u5199\u5de5\u4f5c\uff0c\u4e3a\u8bcd\u6761\u5206\u914d\u9875\u8868\u7a7a\u95f4\u5e76\u586b\u5199\u9875\u8868\u9879\u624d\u662f\u6211\u4eec\u7684\u5de5\u4f5c\u3002</p>"},{"location":"lab/xv6lab-paging/#tlb","title":"\u5feb\u8868 TLB","text":"<p>\u7269\u7406\u5185\u5b58\u7684\u8bbf\u95ee\u901f\u5ea6\u8981\u6bd4 CPU \u7684\u8fd0\u884c\u901f\u5ea6\u6162\u5f88\u591a, \u53bb\u8bbf\u95ee\u4e00\u6b21\u7269\u7406\u5185\u5b58\u53ef\u80fd\u9700\u8981\u51e0\u767e\u4e2a\u65f6\u949f\u5468\u671f\uff08\u5e26\u6765\u6240\u8c13\u7684\u201c\u51af\u8bfa\u4f9d\u66fc\u74f6\u9888\u201d\uff09\u3002</p> <p>\u800c\u6211\u4eec\u7684\u9875\u8868\u90fd\u662f\u5b58\u653e\u5728\u7269\u7406\u5185\u5b58\u4e2d\u3002\u5982\u679c\u6211\u4eec\u6309\u7167\u9875\u8868\u673a\u5236\u4e00\u6b65\u6b65\u8d70\uff0c\u5c06\u4e00\u4e2a\u865a\u62df\u5730\u5740\u8f6c\u5316\u4e3a\u7269\u7406\u5730\u5740\u9700\u8981\u8bbf\u95ee 3 \u6b21\u7269\u7406\u5185\u5b58\uff0c\u5f97\u5230\u7269\u7406\u5730\u5740\u4e4b\u540e\u8fd8\u8981\u518d\u8bbf\u95ee\u4e00\u6b21\u7269\u7406\u5185\u5b58\uff0c\u624d\u80fd\u8bfb\u5230\u6211\u4eec\u60f3\u8981\u7684\u6570\u636e\u3002\u8fd9\u5f88\u5927\u7a0b\u5ea6\u4e0a\u964d\u4f4e\u4e86\u6548\u7387\u3002</p> <p>\u597d\u5728\uff0c\u5b9e\u8df5\u8868\u660e\u865a\u62df\u5730\u5740\u7684\u8bbf\u95ee\u5177\u6709\u65f6\u95f4\u5c40\u90e8\u6027\u548c\u7a7a\u95f4\u5c40\u90e8\u6027\u3002</p> <ul> <li>\u65f6\u95f4\u5c40\u90e8\u6027\u662f\u6307\uff0c\u88ab\u8bbf\u95ee\u8fc7\u4e00\u6b21\u7684\u5730\u5740\u5f88\u6709\u53ef\u80fd\u4e0d\u8fdc\u7684\u5c06\u6765\u518d\u6b21\u88ab\u8bbf\u95ee\uff1b</li> <li>\u7a7a\u95f4\u5c40\u90e8\u6027\u662f\u6307\uff0c\u5982\u679c\u4e00\u4e2a\u5730\u5740\u88ab\u8bbf\u95ee\uff0c\u5219\u8fd9\u4e2a\u5730\u5740\u9644\u8fd1\u7684\u5730\u5740\u5f88\u6709\u53ef\u80fd\u5728\u4e0d\u8fdc\u7684\u5c06\u6765\u88ab\u8bbf\u95ee\u3002</li> </ul> <p>\u200b\u56e0\u6b64\uff0c\u5728 CPU \u5185\u90e8\uff0c\u6211\u4eec\u4f7f\u7528 \u5feb\u8868 (TLB, Translation Lookaside Buffer) \u6765\u8bb0\u5f55\u8fd1\u671f\u5df2\u5b8c\u6210\u7684\u865a\u62df\u9875\u53f7\u5230\u7269\u7406\u9875\u53f7\u7684\u6620\u5c04\u3002\u7531\u4e8e\u5c40\u90e8\u6027\uff0c\u5f53\u6211\u4eec\u8981\u505a\u4e00\u4e2a\u6620\u5c04\u65f6\uff0c\u4f1a\u6709\u5f88\u5927\u53ef\u80fd\u8fd9\u4e2a\u6620\u5c04\u5728\u8fd1\u671f\u88ab\u5b8c\u6210\u8fc7\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u5230 TLB \u91cc\u9762\u53bb\u67e5\u4e00\u4e0b\uff0c\u5982\u679c\u6709\u7684\u8bdd\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u5b8c\u6210\u6620\u5c04\uff0c\u800c\u4e0d\u7528\u8bbf\u95ee\u90a3\u4e48\u591a\u6b21\u5185\u5b58\u4e86\u3002</p> <p>\u4f46\u662f\uff0c\u6211\u4eec\u5982\u679c\u4fee\u6539\u4e86\u6839\u9875\u8868\u5bc4\u5b58\u5668\u7684\u503c\uff0c\u6bd4\u5982\u5c06\u4e0a\u9762\u7684 PPN \u5b57\u6bb5\u8fdb\u884c\u4e86\u4fee\u6539\uff0c\u8bf4\u660e\u6211\u4eec\u5207\u6362\u5230\u4e86\u4e00\u4e2a\u4e0e\u5148\u524d\u6620\u5c04\u65b9\u5f0f\u5b8c\u5168\u4e0d\u540c\u7684\u9875\u8868\u3002\u6b64\u65f6\u5feb\u8868\u91cc\u9762\u5b58\u50a8\u7684\u6620\u5c04\u7ed3\u679c\u5c31\u8ddf\u4e0d\u4e0a\u65f6\u4ee3\u4e86\uff0c\u5f88\u53ef\u80fd\u662f\u9519\u8bef\u7684\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6211\u4eec\u8981\u4f7f\u7528\u7279\u5b9a\u7684\u6307\u4ee4\u5237\u65b0\u6574\u4e2a TLB \u3002\u5728 RISC-V \u4e2d\u8fd9\u4e2a\u6307\u4ee4\u662f <code>sfence.vma</code> \u3002</p> <p>\u540c\u6837\u7684\uff0c\u5982\u679c\u6211\u4eec\u624b\u52a8\u4fee\u6539\u4e00\u4e2a\u9875\u8868\u9879\uff0c\u4e5f\u7b49\u4e8e\u4fee\u6539\u4e86\u6620\u5c04\uff0c\u4f46 TLB \u5e76\u4e0d\u4f1a\u81ea\u52a8\u5237\u65b0\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u4f7f\u7528\u7279\u5b9a\u7684\u6307\u4ee4\u5237\u65b0 TLB \u3002</p> <p>\u5728 RISC-V \u4e2d\uff0c\u5982\u679c\u4e0d\u52a0\u53c2\u6570\uff0c <code>sfence.vma</code> \u4f1a\u5237\u65b0\u6574\u4e2a TLB \u3002\u5982\u679c\u52a0\u4e0a\u4e00\u4e2a\u865a\u62df\u5730\u5740\uff0c\u5219 <code>sfence.vma</code> \u53ea\u4f1a\u5237\u65b0\u8fd9\u4e2a\u865a\u62df\u5730\u5740\u7684\u6620\u5c04\u3002</p>"},{"location":"lab/xv6lab-paging/#risc-v-sv39","title":"RISC-V \u7684 Sv39 \u5206\u9875\u673a\u5236","text":""},{"location":"lab/xv6lab-paging/#satp","title":"satp","text":"<p>satp (Supervisor Address Translation and Protection) \u5bc4\u5b58\u5668\u662f\u63a7\u5236 S mode \u548c U mode \u4e0b\u5730\u5740\u7ffb\u8bd1\u7684\u5bc4\u5b58\u5668\uff0c\u5176\u4e2d\u5305\u542b\u4e09\u4e2a\u5c5e\u6027\uff1a<code>MODE</code>, <code>ASID</code> \u548c <code>PPN</code>\u3002</p> <p></p> <p>Mode \u8868\u793a\u4f7f\u7528\u7684\u5730\u5740\u7ffb\u8bd1\u6a21\u5f0f\uff0c0 \u5219\u8868\u793a\u7981\u7528\u5730\u5740\u7ffb\u8bd1\uff0c\u6240\u6709\u8bf7\u6c42\u7684\u5730\u5740\u5747\u4f5c\u4e3a\u7269\u7406\u5730\u5740\u770b\u5f85\uff0c<code>PPN</code> \u8868\u793a \u6839\u9875\u8868\u7684\u57fa\u5730\u5740 \u3002\u5728\u6211\u4eec\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u5c06\u4f7f\u7528 Sv39 \u4f5c\u4e3a\u9875\u8868\u6a21\u5f0f\u3002</p> <p>\u6211\u4eec\u6682\u4e14\u4e0d\u9700\u8981\u7406\u89e3 ASID \u7684\u4f5c\u7528\u3002</p> <p></p>"},{"location":"lab/xv6lab-paging/#sv39","title":"Sv39","text":"<p>RISC-V \u7684 Sv39 \u6a21\u5f0f\u652f\u6301\u4e86 39-bit \u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u6bcf\u4e2a\u9875\u9762\u5927\u5c0f 4KiB\uff0c\u6bcf\u4e2a PTE 8 bytes\uff0c\u5373\u6bcf\u4e2a\u9875\u9762\u4e2d\u6709 <code>2^9=512</code> \u4e2a PTE\u3002Sv39 \u8981\u6c42\u6bcf\u4e2a\u9875\u8868\u662f\u4e00\u4e2a\u5bf9\u9f50\u7684\u9875\u9762\uff0c\u5373\u5176\u57fa\u5730\u5740\u5bf9\u9f50\u5230 4KiB\u3002</p> <p>RISC-V CPU \u7684\u865a\u62df\u5730\u5740\u4e3a64\u4f4d\u3002Sv39\u6a21\u5f0f\u4e0b\uff0c\u6709\u6548\u7684\u865a\u62df\u5730\u5740\u4e3a 39 \u4f4d\uff0c\u5e76\u89c4\u5b9a\u865a\u62df\u5730\u5740\u7684 63-39 \u4f4d\u5fc5\u987b\u4e0e\u7b2c 38 \u4f4d\u76f8\u540c\uff0c\u5373\u7b26\u53f7\u6269\u5c55(Signed-Extension)\uff0c\u5426\u5219\u662f\u4e00\u4e2a\u975e\u6cd5\u7684\u865a\u62df\u5730\u5740\u3002\u6240\u4ee5\uff0cSv39 \u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e00\u5171\u4e3a <code>(1 &lt;&lt; 39) = 512 GiB</code> \u7684\u7a7a\u95f4\uff0c\u5176\u4e2d\u5206\u4e3a\u9ad8\u5730\u5740\u548c\u4f4e\u5730\u5740\u5404 <code>256 GiB</code> \u7684\u7a7a\u95f4\uff0c\u4f4e\u5730\u5740\u7a7a\u95f4\u4e3a <code>0x0000_0000_0000_0000</code> - <code>0x0000_003f_xxxx_xxxx</code> \uff0c\u800c\u9ad8\u5730\u5740\u7a7a\u95f4\u4e3a <code>0xffff_ffc0_0000_0000</code> - <code>0xffff_ffff_xxxx_xxxx</code>\u3002</p> <p></p> <p>\u865a\u62df\u5730\u5740\u5206\u4e3a\u56db\u90e8\u5206\uff1aVPN[2-0] (Virtual Page Number) \u548c page offset\u3002\u4e09\u7ea7 VPN \u8868\u793a\u5728\u4e09\u7ea7\u9875\u8868\u4e2d\u7684 index, \u800c page offset \u8868\u793a\u5f53\u524d\u5730\u5740\u5728\u88ab\u7ffb\u8bd1\u7684\u9875\u9762\u4e2d\u7684\u504f\u79fb\u91cf\u3002</p> <p>Sv39 \u4e2d\u7684 PTE \u957f\u5ea6\u4e3a 8-byte\uff0c\u5206\u4e3a\u4e24\u90e8\u5206\uff1aPPN \u548c Flags\u3002PPN (Physical Page Number) \u548c\u865a\u62df\u5730\u5740\u4e2d\u7684 page offset \u7ec4\u6210\u6700\u7ec8\u7684\u7269\u7406\u5730\u5740\uff0cFlags \u5219\u8868\u793a\u8be5\u865a\u62df\u5730\u5740\u9875\u9762\u7684\u8bbf\u95ee\u6743\u9650\u7b49\u4fe1\u606f\u3002</p>"},{"location":"lab/xv6lab-paging/#flags","title":"Flags","text":"<p>Flags \u5b9a\u4e49\u5982\u4e0b\uff1a</p> <ul> <li>D, A: Dirty, Accessed\u3002\u8868\u793a\u8be5\u9875\u9762\u6700\u8fd1\u88ab\u8bbf\u95ee / \u5199\u5165\u8fc7\u3002</li> <li>G: Global\u3002\u8868\u793a\u8be5\u6620\u5c04\u5173\u7cfb\u5728\u6240\u6709\u9875\u8868\u4e2d\u5747\u5b58\u5728\u3002</li> <li>U: User\u3002\u8868\u793a\u8be5\u6620\u5c04\u5173\u7cfb\u5141\u8bb8\u5728\u7528\u6237\u6743\u9650\u4e0b\u8bbf\u95ee\u3002</li> <li>V: Valid\u3002\u8be5 bit \u8868\u793a\u6b64 PTE \u4e3a\u6709\u6548 PTE\uff0c\u5426\u5219\u6574\u4e2a PTE \u89c6\u4e3a\u65e0\u6548\u3002</li> <li>R, W, X: Read, Write, Executable \u6743\u9650</li> </ul> <p>RWX \u5b9a\u4e49\u5982\u4e0b\u56fe\u6240\u793a\uff1a \u6ce8\u610f <code>XWR == 3'b000</code> \u7684\u60c5\u51b5\u8868\u793a\u7269\u7406\u5730\u5740 [PPN: 12b0] \u4e3a\u4e0b\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740\uff0c\u5426\u5219\uff0c\u8be5PTE\u4e3a Leaf PTE.</p> <p></p>"},{"location":"lab/xv6lab-paging/#a-d","title":"A &amp; D","text":"<p>\u6bcf\u4e2a\u9875 PTE \u5305\u542b Accessed \u548c Dirty \u4e24\u4e2a bits\uff1a</p> <ul> <li>A \u8868\u793a\uff1a\u81ea\u4ece\u4e0a\u6b21 A bit \u88ab\u6e05\u96f6\uff0c\u8be5\u865a\u62df\u9875\u9762\u66fe\u7ecf\u88ab\u8bfb\u53d6\u3001\u5199\u5165\u3001\u53d6\u6307 \uff08Instruction Fetch\uff09\u3002</li> <li>D \u8868\u793a\uff1a\u81ea\u4ece\u4e0a\u6b21 D bit \u88ab\u6e05\u96f6\uff0c\u8be5\u865a\u62df\u9875\u9762\u66fe\u7ecf\u88ab\u5199\u5165\u3002</li> </ul> <p>\u5f53\u8bbf\u95ee\u7684\u865a\u62df\u9875\u9762\u88ab\u8bbf\u95ee\u65f6\uff0cA bit \u662f 0\u3001\u6216\u88ab\u5199\u5165\u65f6\uff0cD bit \u662f 0 \u662f\uff0cRISC-V \u89c4\u8303\u5b9e\u73b0\u5141\u8bb8\u4e24\u79cd\u65b9\u5f0f\u6765\u66f4\u65b0 A &amp; D bits\uff1a</p> <ol> <li>\u53d1\u51fa PageFault\uff0cSupervisor \u7684\u5f02\u5e38\u5904\u7406\u51fd\u6570\u9700\u8981\u624b\u52a8\u8bbe\u7f6e A / D bits.</li> <li>\u7531\u786c\u4ef6\u8bbe\u7f6e A / D bits.</li> </ol> <p>Supervisor \u8f6f\u4ef6\u5e94\u5f53\u6b63\u786e\u5904\u7406\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\u3002</p>"},{"location":"lab/xv6lab-paging/#_6","title":"\u6743\u9650\u68c0\u67e5","text":"<p>\u51ed\u76f4\u89c9\u7684\uff0c\u8bfb\u53d6\u7684\u9875\u9762\u8981\u5e26\u6709 R bit\uff0c\u5199\u5165\u7684\u9875\u9762\u8981\u5e26\u6709 W bit\uff0c\u6267\u884c\u7684\u9875\u9762\u8981\u5e26\u6709 X bit\u3002</p> <p>\u4f46\u662f\uff0c\u5982\u679c\u4e00\u4e2a\u9875\u9762\u7684\u6743\u9650\u5e26\u6709 U bit\uff0c\u5e76\u4e14\u73b0\u5728 CPU \u6838\u5fc3\u8fd0\u884c\u5728 S mode \u4e0b\uff0c\u6211\u4eec\u9700\u8981\u5bf9 SUM (permit Supervisor User Memory access) bit \u8fdb\u884c\u989d\u5916\u68c0\u67e5\uff1a\u5982\u679c <code>sstatus.SUM == 1</code> \u5219\u8bbf\u95ee\u88ab\u5141\u8bb8\uff0c\u5426\u5219\u5bfc\u81f4 Page Fault.</p> <p>\u901a\u5e38\u6765\u8bf4\uff0cS mode \u4e00\u822c\u8fd0\u884c\u5728 <code>sstatus.SUM == 0</code> \u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u901a\u8fc7\u9875\u8868\u53bb\u8bbf\u95ee\u7528\u6237\u6570\u636e\u65f6\uff0c\u6211\u4eec\u4f1a\u5c06\u8be5 flag \u7f6e 1\uff0c\u5e76\u5728\u8bbf\u95ee\u7ed3\u675f\u540e\u6e05\u96f6\u3002\u8be5\u8fc7\u7a0b\u4e00\u822c\u88ab\u79f0\u4e3a uaccess \u539f\u8bed (primitive).</p> <p>See also: https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/uaccess.h</p> <p>Sv39 \u5730\u5740\u7ffb\u8bd1\u7684\u8fc7\u7a0b\u5982\u4e0b\u56fe\u6240\u793a\uff1a\uff08L2, L1, L0 \u5206\u522b\u4ee3\u8868 VPN2, VPN1, VPN0\uff0c\u56fe\u4e2d\u7684 Page Directory \u4e2d\uff0c\u4e0b\u65b9\u4e3a\u4f4e\u5730\u5740\uff0c\u4e0a\u65b9\u4e3a\u9ad8\u5730\u5740\uff09</p> <p></p> <p>See also: riscv-privilege.pdf, 4.3.2 Virtual Address Translation Process</p> <p>\u6587\u5b57\u63cf\u8ff0\uff0c\u4ee5\u4e0b <code>{xx | yy}</code> \u8868\u793a\u5728 <code>xx</code> bit \u53f3\u8fb9\u5e76\u4e0a <code>yy</code> bit\uff0c\u7c7b\u4f3c\u4e8e Verilog \u7684\u5199\u6cd5\u3002</p> <ol> <li>\u5206\u89e3 Virtual Address: <code>{ 25'signed_ext, 9'VPN2, 9'VPN1, 9'VPN0, 12'pgoff} = 64'VirtualAddress</code></li> <li>\u5c06 satp \u5bc4\u5b58\u5668\u4e2d\u7684 PPN \u4f5c\u4e3a\u7b2c\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740</li> <li>\u4f7f\u7528 VPN2 \u4f5c\u4e3a index \u5728\u7b2c\u4e00\u7ea7\u9875\u8868\u4e2d\u627e\u5230 pte2\u3002</li> </ol> <p>\u8fd9\u4e00\u6b65\u7b49\u6548\u4e8e C \u4ee3\u7801\uff1a<code>uint64 pte2 = *(uint64*)(satp.base + VPN2 * 8);</code></p> <ol> <li>\u5982\u679c <code>pte2.WXR != 3'b000</code>\uff0c\u5219\u8868\u793a\u8be5 PTE \u4e3a 1GiB \u5927\u9875\u6620\u5c04\u3002</li> </ol> <p>\u68c0\u67e5 PPN \u662f\u5426\u5bf9\u9f50\u5230 1GiB\uff0caka\uff1a<code>pte2.PPN1 == 9'b0 &amp;&amp; pte2.PPN0 == 9'b0</code>\u3002\u5982\u679c\u6ee1\u8db3\uff0c\u5219\u8df3\u8f6c\u81f3 10\uff0c\u5426\u5219 Page Fault\u3002</p> <ol> <li><code>{pte2.PPN, 12'b0}</code> \u4e3a\u7b2c\u4e8c\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740</li> <li>\u4f7f\u7528 VPN1 \u4f5c\u4e3a index \u5728\u7b2c\u4e8c\u7ea7\u9875\u8868\u4e2d\u627e\u5230 pte1\u3002</li> </ol> <p>\u8fd9\u4e00\u6b65\u7b49\u6548\u4e8e C \u4ee3\u7801\uff1a<code>uint64 pte1 = *(uint64*)((pte2.ppn &lt;&lt; 12) + VPN1 * 8);</code></p> <ol> <li>\u5982\u679c <code>pte1.WXR != 3'b000</code>\uff0c\u5219\u8868\u793a\u8be5 PTE \u4e3a 2MiB \u5927\u9875\u6620\u5c04\u3002</li> </ol> <p>\u68c0\u67e5 PPN \u662f\u5426\u5bf9\u9f50\u5230 2MiB\uff0caka\uff1a<code>pte2.PPN0 == 9'b0</code>\u3002\u5982\u679c\u6ee1\u8db3\uff0c\u5219\u8df3\u8f6c\u81f3 10\uff0c\u5426\u5219 Page Fault\u3002</p> <ol> <li>\u5426\u5219\uff0c<code>{pte1.PPN | 12'b0}</code> \u4e3a\u7b2c\u4e09\u7ea7\u9875\u8868\u7684\u57fa\u5730\u5740</li> <li>\u4f7f\u7528 VPN0 \u4f5c\u4e3a index \u5728\u7b2c\u4e09\u7ea7\u9875\u8868\u4e2d\u627e\u5230 PTE\u3002</li> </ol> <p>\u8fd9\u4e00\u6b65\u7b49\u6548\u4e8e C \u4ee3\u7801\uff1a<code>uint64 pte0 = *(uint64*)((pte1.ppn &lt;&lt; 12) + VPN0 * 8);</code></p> <ol> <li> <p>\u5f97\u5230\u6700\u7ec8\u7684\u7269\u7406\u5730\u5740\uff1a<code>PA = (leaf_pte.ppn &lt;&lt; 12) | final_page_offset</code>\uff0c</p> <p>\u5982\u679c\u4e3a 2MiB \u5927\u9875\u6620\u5c04\uff0c<code>final_page_offset = {9'VPN0, 12'pgoff}</code>\u3002</p> <p>\u5982\u679c\u4e3a 1GiB \u5927\u9875\u6620\u5c04\uff0c<code>final_page_offset = {9'VPN1, 9'VPN0, 12'pgoff}</code></p> <p>\u5426\u5219\uff0c<code>final_page_offset = 12'pgoff</code></p> </li> <li> <p>\u6743\u9650\u68c0\u67e5\uff1a\u68c0\u67e5 <code>leaf_pte.rwx</code> \u662f\u5426\u4e0e\u8bbf\u5b58\u8bf7\u6c42\u76f8\u540c\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-paging/#_7","title":"\u5927\u9875\u6620\u5c04","text":"<p>\u53ef\u4ee5\u6ce8\u610f\u5230\u5f53 Flags \u4e2d\u7684 XWR \u53d6\u503c\u5747\u4e3a0\u65f6\uff0c\u8be5 PTE \u662f\u6307\u5411\u4e0b\u4e00\u7ea7\u9875\u8868\u7684\u6307\u9488\uff0c\u800c\u5f53\u8fd9 XWR \u4e2d\u5b58\u5728\u975e0\u4f4d\u65f6\uff0c\u5219\u8be5PTE\u662f\u9875\u8868\u6811\u7684\u4e00\u4e2a\u53f6\u8282\u70b9\uff0c\u4e5f\u5c31\u662f\u6b64\u65f6\u8be5PTE\u7684PPN\u503c\u4ee3\u8868\u4e86 \u7269\u7406\u9875 \u7684\u57fa\u5730\u5740\u800c\u975e \u9875\u8868 \u7684\u7269\u7406\u57fa\u5740\u3002</p> <p>\u6bd4\u5982\uff0cSv39\u4e2d\u7ed9\u5b9a\u4e00\u4e2a\u865a\u62df\u5730\u5740VA[38:0]\uff0c\u7136\u540e\u6211\u4eec\u6839\u636e <code>satp.PPN\u00d74096+VPN2</code> \u6c42\u5f97\u4e00\u7ea7\u9875\u8868\u4e2d\u7684PTE\u7684\u5730\u5740\uff0c\u5047\u8bbe\u8be5PTE\u7684XWR\u4e3a001\uff0c\u5219\u8be5PTE\u4e3a\u53f6\u8282\u70b9\u9875\u8868\u9879\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a\u5927\u9875\u6620\u5c04\u3002\u6b64\u65f6\uff0c\u7531\u4e8e\u4e00\u7ea7\u9875\u8868\u4e2d\u7684\u9875\u8868\u9879\u5c31\u662f\u53f6\u8282\u70b9\u9875\u8868\u9879\uff0c\u865a\u62df\u5730\u5740\u7684\u542b\u4e49\u5c31\u4ece\u539f\u672c\u7684</p> <p></p> <p>\u53d8\u6210\u4e86</p> <p></p> <p>\u800c\u7269\u7406\u5730\u5740\u7684\u8ba1\u7b97\u5219\u53d8\u6210\u4e86 <code>PTE.PPN\u00d74096+VA[29:0]</code>\u3002\u6b64\u65f6\u53ef\u4ee5\u53d1\u73b030\u4f4d\u504f\u79fb\u91cf\u53ef\u4ee5\u8868\u793a\u4ecePTE.PPN\u00d74096\u5f00\u59cb\u7684\u4e00\u4e2a\u5f88\u5927\u7684\u7a7a\u95f4\uff08\u7a7a\u95f4\u5927\u5c0f\u4e3a2<sup>30</sup>Byte\u53731GiB\uff09\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a \u5409\u9875\u3002\uff08\u6ce8\u610f\u5e38\u89c1\u652f\u6301\u5927\u9875\u673a\u5236\u7684\u67b6\u6784\u4e2d\uff0c\u5927\u9875\u57fa\u5730\u5740\u5fc5\u987b\u5bf9\u9f50\u81ea\u5df1\u7684\u5927\u9875\u7a7a\u95f4\uff0c\u5373\u5409\u9875\u57fa\u5730\u5740\u5fc5\u987b\u5bf9\u9f501GB\uff0cPTE.PPN*4096\u7684\u4f4e30\u4f4d\u9700\u8981\u4e3a0\u3002\uff09</p> <p>\u76f8\u5e94\u7684\uff0c\u5982\u679c\u7b2c\u4e8c\u7ea7\u9875\u8868\u7684\u9875\u8868\u9879\u4e3a\u53f6\u8282\u70b9\u9875\u8868\u9879\uff0c\u5219\u8be5\u9875\u8868\u9879\u7684 <code>[20:0]</code> \u4f4d\u5c06\u8868\u793a\u4e00\u4e2a\u6574\u4f53\u7684\u504f\u79fb\u91cf\uff0c\u4ee3\u8868\u4e00\u4e2a\u5c0f\u4e8e\u5409\u9875\u7684\u9875\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a \u5de8\u9875 \u3002\u4e00\u822c\u60c5\u51b5\u4e0b\u4e09\u7ea7\u9875\u8868\u9879\u662f\u53f6\u8282\u70b9\u9875\u8868\u9879\uff0c\u6307\u5411\u4e00\u4e2a \u57fa\u9875 \uff084KB\uff09\u3002</p>"},{"location":"lab/xv6lab-paging/#lab","title":"Lab \u8bfe\u5802\u62a5\u544a","text":"<ol> <li>\u8bf7\u53c2\u7167 Sv39 \u5730\u5740\u7ffb\u8bd1\u6a21\u5f0f\uff0c\u89e3\u7801\u4ee5\u4e0b\u865a\u62df\u5730\u5740\uff0c\u5199\u51fa\u5176 VPN[2-0] \u548c offset \u7684\u4e8c\u8fdb\u5236\u503c\u3002\u6ce8\u610f\uff1a\u8bf7\u7528\u4e8c\u8fdb\u5236\u8868\u793a\uff01</li> </ol> vaddr VPN2 VPN1 VPN0 offset <code>0x0000_0000_8020_1234</code> <code>0x0000_003f_ffff_f000</code> <code>0xffff_ffd1_dead_beef</code> <p>Hint: \u4f60\u53ef\u4ee5\u4f7f\u7528 Windows \u4e2d\u81ea\u5e26\u7684\u8ba1\u7b97\u5668\uff0c\u5207\u6362\u5230 Programmer \u6a21\u5f0f\uff0c\u5373\u53ef\u5feb\u901f\u572816\u300110\u30012\u8fdb\u5236\u95f4\u8f6c\u6362\u3002\u6216\u8005\u53ef\u4ee5\u4f7f\u7528 python3 \u81ea\u5e26\u7684  <code>bin(0x1122_3344)</code> \u51fd\u6570\u8f6c\u6362\u6570\u5b57\u5230\u4e8c\u8fdb\u5236\u3002</p> <ol> <li>\u8bf7\u4f60\u53c2\u7167 Sv39 \u6a21\u5f0f\u624b\u52a8\u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\uff0c\u8bf7\u4f60\u5199\u51fa\u8be5\u9875\u8868\u4e2d\u6240\u6709\u6709\u6548\u7684\u6620\u5c04\u3002</li> </ol> <p><code>satp: 0x8000000000080400</code></p> <p>\u90e8\u5206\u5185\u5b58\u7684 hexdump \u5982\u4e0b\uff0c\u5192\u53f7\u5de6\u4fa7\u4ee3\u8868\u5185\u5b58\u5730\u5740\uff0c\u53f3\u4fa7\u4ee3\u8868\u8be5\u5730\u5740\u5904\u7684\u503c\u768416\u8fdb\u5236\u8868\u793a\u3002\u672a\u6307\u5b9a\u7684\u5185\u5b58\u5747\u4e3a0\u3002hexdump\u5df2\u7ecf\u8f6c\u6362\u4e3a\u5c0f\u7aef\u5e8f\uff0c\u4f60\u4e0d\u9700\u8981\u8003\u8651\u7aef\u5e8f\u95ee\u9898\u3002</p> <pre><code>0x8040_0000:\n0x0000000080400000:     0x0000000020100401\n0x00000000804004a8:     0x0000000020101401\n0x00000000804007f8:     0x0000000020100c01\n\n0x8040_1000:\n0x0000000080401000:     0x0000000020100801\n\n0x8040_2000:\n0x0000000080402008:     0x000000002000001f\n0x0000000080402010:     0x000000002000041f\n\n0x8040_3000:\n0x0000000080403ff8:     0x0000000020101001\n\n0x8040_4000:\n0x0000000080404ff8:     0x000000003777400b\n\n0x8040_5000:\n0x00000000804056f0:     0x00000037ab400043\n</code></pre> <p>\u6ce8\uff1a\u7b54\u9898\u7eb8\u4e0a\u7b2c\u4e09\u5217 PPN \u662f\u5199\u9519\u4e86\uff0c\u8bf7\u6309\u7167 Physical Address \u586b\u5199\u3002\u6240\u6709\u6570\u5b57\u5747\u4ee516\u8fdb\u5236\u8868\u793a\uff0c\u8bf7\u53c2\u7167\u8868\u683c\u4e2d\u7b2c\u4e00\u6761\u7684\u683c\u5f0f\u3002</p> Virtual Address Size Physical Address Flags(DAGUXWRV) <code>0xdead_beef_aabb_ccdd</code> <code>0x00aa_eeff</code> <code>0x8899_0000</code> <code>DA-UWXRV</code> <ol> <li>\u5728 RISC-V \u5e73\u53f0\u4e0a\uff0c\u9875\u9762\u5927\u5c0f\u4e3a <code>4KiB</code>\u3002\u5728 32 \u4f4d\u4e0b\u6211\u4eec\u53ef\u7528 Sv32\uff0c\u5728 64 \u4f4d\u4e0b\u6211\u4eec\u53ef\u7528 Sv39\u3002\u5df2\u77e5 Sv32 \u4e2d PTE \u7684\u5927\u5c0f\u4e3a 4 Bytes\uff0cSv39 \u4e2d PTE \u7684\u5927\u5c0f\u4e3a 8 Bytes\u3002</li> </ol> <p>Sv32 page tables consist of 2^10 page-table entries (PTEs), each of four bytes. A page table is exactly the size of a page and must always be aligned to a page boundary. The physical page number of the root page table is stored in the satp register.</p> <p>Sv39 page tables contain 2^9 page table entries (PTEs), eight bytes each. A page table is exactly the size of a page and must always be aligned to a page boundary. The physical page number of the root page table is stored in the satp register\u2019s PPN field.</p> <p>\u8bf7\u4f60\u7b80\u8981\u89e3\u91ca\u4e3a\u4ec0\u4e48 Sv32 \u4e2d\u6bcf\u4e2a VPN \u7684\u957f\u5ea6\u662f 10 bits\uff0c\u800c Sv39 \u4e2d\u6bcf\u4e2a VPN \u7684\u957f\u5ea6\u662f 9 bits\u3002</p>"},{"location":"lab/xv6lab-paging/#_8","title":"\u5b9e\u9a8c\u573a\u666f","text":"<p>xv6-lab4 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab4</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab4 xv6lab4</code> \u4e0b\u8f7d xv6-lab4 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u5185\u6838\u4f1a\u8fdb\u884c\u91cd\u5b9a\u4f4d\u542f\u52a8\uff0c\u6700\u7ec8\uff0c\u5b83\u4f1a\u8fd0\u884c\u5728\u9ad8\u5730\u5740\u7684 pc \u548c sp \u4e0a\u3002</p> <pre><code>Kernel Starts Relocating...\nKernel size: 0x000000000002e000, Rounded to 2MiB: 0x0000000000200000\n[INFO  0,-1] bootcpu_start_relocation: Kernel phy_base: 0x0000000080200000, phy_end_4k:0x000000008022e000, phy_end_2M 0x0000000080400000\nMapping Identity: 0x0000000080200000 to 0x0000000080200000\nMapping kernel image: 0xffffffff80200000 to 0x0000000080200000\nMapping Direct Mapping: 0xffffffc080400000 to 0x0000000080400000\nEnable SATP on temporary pagetable.\nBoot HART Relocated. We are at high address now! PC: 0xffffffff80203d68\n[INFO  0,-1] kvm_init: boot-stage page allocator: base 0xffffffc080400000, end 0xffffffc080600000\n[INFO  0,-1] kvmmake: Memory after kernel image (phys) size = 0x0000000007c00000\n[INFO  0,-1] kvm_init: enable pageing at 0x8000000000080400\n[INFO  0,-1] kvm_init: boot-stage page allocator ends up: base 0xffffffc080400000, used: 0xffffffc080411000\nRelocated. Boot halt sp at 0xffffffffff001fb0\n</code></pre> <p>\u5728\u672c\u6b21\u7684\u5b9e\u9a8c\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u4f1a\u4e3a\u5185\u6838\u6784\u5efa\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u5e76\u5c06\u64cd\u4f5c\u7cfb\u7edf\u4ece\u8fd0\u884c\u5728\u7269\u7406\u5730\u5740\u7a7a\u95f4\u8df3\u8f6c\u5230\u8fd0\u884c\u5728\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002</p> <p>\u4ee3\u7801\u7684\u5177\u4f53\u6267\u884c\u6d41\u7a0b\u5982\u4e0b\uff1a</p> <ol> <li> <p>entry.S \u7684 <code>_entry</code> \uff1a\u64cd\u4f5c\u7cfb\u7edf\u5165\u53e3</p> </li> <li> <p>main.c \u7684 <code>bootcpu_entry</code> \uff1aC\u8bed\u8a00\u5165\u53e3</p> </li> <li> <p>main.c \u7684 <code>bootcpu_start_relocation</code> \uff1a\u5c06 PC \u548c satp \u8fdb\u884c\u91cd\u5b9a\u4f4d\uff0c\u8bbe\u7f6e\u4e34\u65f6\u9875\u8868</p> </li> <li> <p>main.c \u7684 <code>bootcpu_relocating</code> \uff1a\u8c03\u7528 <code>kvm_init</code> \u5b8c\u6210\u5bf9\u5185\u6838\u9875\u8868\u7684\u8bbe\u7f6e\u4e0e\u5207\u6362</p> </li> <li> <p>main.c \u7684 <code>bootcpu_init</code> \uff1a\u5185\u6838\u521d\u59cb\u5316\uff0c\u8df3\u8f6c <code>scheduler</code></p> </li> </ol> <p>\u8981\u5c06\u8fd0\u884c\u5728\u7269\u7406\u5730\u5740\u7a7a\u95f4\u6539\u4e3a\u8fd0\u884c\u5728\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u4e86\u89e3\u5185\u6838\u653e\u7f6e\u5728\u7269\u7406\u7a7a\u95f4\u7684\u4ec0\u4e48\u533a\u57df\uff1a</p>"},{"location":"lab/xv6lab-paging/#risc-v","title":"RISC-V \u7269\u7406\u5730\u5740\u5e03\u5c40","text":"<p>\u9996\u5148\uff0cRISC-V \u5c06\u7269\u7406\u5185\u5b58 (DDR / DRAM) \u7684\u8d77\u59cb\u5730\u5740\u6620\u5c04\u5728\u7269\u7406\u5730\u5740 <code>0x8000_0000</code> \u4e0a\uff0c\u800c\u4e0d\u662f\u7269\u7406\u5730\u5740 <code>0x0000_0000</code> \u5904\u3002</p> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u6709 128 MiB (0x0800_0000) \u7684 DRAM \u5927\u5c0f\uff0cRISC-V \u6838\u5fc3\u4f1a\u5c06 DRAM \u7a7a\u95f4\u6620\u5c04\u5230 <code>[0x8000_0000, 0x8800_0000)</code> \u4e0a\u9762\u3002</p> <p>\u5bf9\u4e8e QEMU \u7684 virt \u673a\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u7ffb\u9605 qemu \u7684\u6e90\u4ee3\u7801\u627e\u5230\u5176\u7269\u7406\u5730\u5740\u7684\u6620\u5c04\uff1a</p> <pre><code>static const MemMapEntry virt_memmap[] = {\n    [VIRT_DEBUG] =        {        0x0,         0x100 },\n    [VIRT_MROM] =         {     0x1000,        0xf000 },\n    [VIRT_TEST] =         {   0x100000,        0x1000 },\n    [VIRT_RTC] =          {   0x101000,        0x1000 },\n    [VIRT_CLINT] =        {  0x2000000,       0x10000 },\n    [VIRT_ACLINT_SSWI] =  {  0x2F00000,        0x4000 },\n    [VIRT_PCIE_PIO] =     {  0x3000000,       0x10000 },\n    [VIRT_PLATFORM_BUS] = {  0x4000000,     0x2000000 },\n    [VIRT_PLIC] =         {  0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) },\n    [VIRT_APLIC_M] =      {  0xc000000, APLIC_SIZE(VIRT_CPUS_MAX) },\n    [VIRT_APLIC_S] =      {  0xd000000, APLIC_SIZE(VIRT_CPUS_MAX) },\n    [VIRT_UART0] =        { 0x10000000,         0x100 },\n    [VIRT_VIRTIO] =       { 0x10001000,        0x1000 },\n    [VIRT_FW_CFG] =       { 0x10100000,          0x18 },\n    [VIRT_FLASH] =        { 0x20000000,     0x4000000 },\n    [VIRT_IMSIC_M] =      { 0x24000000, VIRT_IMSIC_MAX_SIZE },\n    [VIRT_IMSIC_S] =      { 0x28000000, VIRT_IMSIC_MAX_SIZE },\n    [VIRT_PCIE_ECAM] =    { 0x30000000,    0x10000000 },\n    [VIRT_PCIE_MMIO] =    { 0x40000000,    0x40000000 },\n    [VIRT_DRAM] =         { 0x80000000,           0x0 },\n};\n</code></pre> <p>\u4e0d\u8fc7\uff0c\u5728\u6211\u4eec\u7684\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8 DRAM \u7a7a\u95f4\u548c\u4e00\u4e9b\u5916\u8bbe(PLIC, UART)\u5373\u53ef</p> <code>Base</code> Size Description <code>0x0000_1000</code> <code>0x0000_f000</code> BootROM <code>0x0c00_0000</code> <code>0x0060_0000</code> PLIC <code>0x1000_0000</code> <code>0x0000_0100</code> Serial UART <code>0x8000_0000</code> DRAM Size DRAM <p></p> <p>\u63a5\u7740\uff0c\u6211\u4eec\u9700\u8981\u8bbe\u8ba1\u4e00\u4e2a\u5185\u5b58\u5e03\u5c40\uff0c\u5b83\u5c06\u51b3\u5b9a\u5bf9\u4e8e\u5185\u6838\uff0c\u6211\u4eec\u5c06\u5efa\u7acb\u600e\u4e48\u6837\u7684\u5730\u5740\u6620\u5c04\u3002</p>"},{"location":"lab/xv6lab-paging/#xv6","title":"xv6 \u5185\u6838\u5185\u5b58\u5e03\u5c40","text":"<p>Sv39 \u865a\u62df\u5730\u5740\u7684\u9ad8\u4f4d\u662f Sign-Extension \u7684\uff0c\u5728 <code>&lt; 256 GiB</code> \u548c <code>256 GiB ~ 512 GiB</code> \u4e4b\u95f4\u6709\u7740\u5de8\u5927\u7684 gap\uff0c\u6211\u4eec\u5229\u7528\u6b64\u7279\u6027\u5728\u5730\u5740\u4e0a\u533a\u5206\u7528\u6237\u5730\u5740\uff08\u4f4e\uff0c\u4ee5 <code>0x0000</code> \u5f00\u5934\uff09\u548c\u5185\u6838\u5730\u5740\uff08\u9ad8\uff0c\u4ee5 <code>0xffff</code> \u5f00\u5934\uff09\u3002</p> <code>Base Address</code> Description <code>0x0000_0000_xxxx_xxxx</code> Userspace <code>0x0000_003f_ffff_e000</code> Trapframe <code>0x0000_003f_ffff_f000</code> Trampoline <code>0xffff_ffc0_0000_0000</code> Kernel Direct Mapping of all available physical pages <code>0xffff_fffd_0000_0000</code> Kernel Heap (fixed-size object) <code>0xffff_ffff_8020_0000</code> Kernel Image (.text, .data, .bss) <code>0xffff_ffff_a000_0000</code> Device Memory-Mapped IO <code>0xffff_ffff_d000_0000</code> Kernel stack for processes <code>0xffff_ffff_ff00_0000</code> Kernel stack for per-cpu scheduler <ul> <li>Trampoline (n. \u8e66\u5e8a) \u662f\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u7684\u8df3\u677f\uff0c\u6211\u4eec\u5c06\u5b83\u653e\u5728\u4f4e 128 GiB \u7684\u6700\u9ad8\u5904\u3002</li> <li>\u7136\u540e\uff0c\u6211\u4eec\u5c06\u5185\u6838\u7684\u955c\u50cf\uff0c\u5373 <code>build/kernel</code> ELF \u6587\u4ef6\uff0c\u6211\u4eec\u4ee4\u5b83\u6620\u5c04\u5230\u865a\u62df\u5730\u5740 <code>0xffff_ffff_8020_0000</code>\uff0c\u4e0e\u5b9e\u9645\u7684\u7269\u7406\u5730\u5740 <code>0x8020_0000</code> \u76f8\u5dee\u4e00\u4e2a\u5e38\u6570 <code>0xffff_ffff_0000_0000</code>\u3002</li> <li>\u5176\u6b21\uff0c\u6620\u5c04\u4e00\u4e9b\u5185\u6838\u6240\u9700\u8981\u7684\u9875\u9762\uff0c\u5982\u6bcf\u4e2a CPU \u7684 scheduler \u6240\u7528\u7684\u6808\uff0c\u4ee5\u53ca\u5916\u8bbe\u6240\u9700\u8981\u7684 MMIO\u3002</li> <li>\u6700\u540e\uff0c\u5269\u4e0b\u7684\u6240\u6709\u53ef\u7528\u7684\u7269\u7406\u9875\u9762\u5c06\u88ab Direct Mapping \u5230 <code>0xffff_ffc0_80xx_xxxx</code>\uff0c\u5e76\u4ea4\u7ed9 kalloc \u7ba1\u7406\u3002</li> </ul> <p></p> <p>Direct Mapping</p> <p>\u5bf9\u4e8e\u53ef\u7528\u7684\u7269\u7406\u5185\u5b58\u7a7a\u95f4\uff0c\u6211\u4eec\u4f7f\u7528 Direct Mapping \u7684\u65b9\u5f0f\u5efa\u7acb\u5730\u5740\u6620\u5c04\uff0c\u5373 <code>\u865a\u62df\u5730\u5740 = \u7269\u7406\u5730\u5740 + \u5e38\u6570\u504f\u79fb\u91cf</code> \u3002</p> <p>Direct Mapping \u7684\u4f5c\u7528\u662f\u8ba9 Kernel \u80fd\u76f4\u63a5\u64cd\u7eb5\u6240\u6709\u53ef\u7528\u7684\u7269\u7406\u5185\u5b58\uff0c\u4f46\u662f\u9664\u4e86\u5185\u6838\u672c\u8eab\u955c\u50cf\u4ee5\u5916\u3002</p> <p>\u5982\u679c\u6ca1\u6709 Direct Mapping\uff0c\u6211\u4eec\u6bcf\u6b21\u90fd\u9700\u8981\u5c06\u65b0\u5206\u914d\u7684\u9875\u9762\u6620\u5c04\u5230\u5185\u6838\u865a\u62df\u5730\u5740\u7a7a\u95f4\u4e0a\uff0c\u624d\u80fd\u901a\u8fc7\u865a\u62df\u5730\u5740\u53bb\u8bbf\u95ee\u8be5\u7269\u7406\u9875\u9762\u3002\u800c\u6709\u4e86 Direct Mapping \u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5c06\u7269\u7406\u5730\u5740\u52a0\u4e0a\u4e00\u4e2a\u5e38\u91cf\u504f\u79fb\u91cf\uff0c\u5373\u53ef\u5f97\u5230\u4e00\u4e2a\u5185\u6838\u53ef\u8bbf\u95ee\u7684\u865a\u62df\u5730\u5740\uff1a</p> <pre><code>#define KERNEL_DIRECT_MAPPING_BASE  0xffffffc000000000ull\n\n#define KVA_TO_PA(x) (((uint64)(x)) - KERNEL_DIRECT_MAPPING_BASE)\n#define PA_TO_KVA(x) (((uint64)(x)) + KERNEL_DIRECT_MAPPING_BASE)\n</code></pre> <p>\u5728\u8bbe\u8ba1\u5b8c\u5185\u6838\u5185\u5b58\u5e03\u5c40\u540e\uff0c\u6211\u4eec\u9700\u8981\u4ee4\u5185\u6838\u4ece\u7269\u7406\u5730\u5740\u5207\u6362\u5230\u865a\u62df\u5730\u5740\u7ee7\u7eed\u8fd0\u884c\uff0c\u8fd9\u4e00\u6b65\u9700\u8981\u9996\u5148\u505a\u4e00\u4e2a\u91cd\u5b9a\u4f4d\u7684\u64cd\u4f5c\uff1a</p>"},{"location":"lab/xv6lab-paging/#relocation","title":"\u91cd\u5b9a\u4f4d\uff08Relocation\uff09","text":"<p>\u5bf9\u4e8e\u5185\u6838\u672c\u8eab\uff08\u5373\u7f16\u8bd1\u51fa\u6765\u7684 ELF \u6587\u4ef6\uff1a<code>build/kernel</code>\uff0c\u4e5f\u79f0\u4e3a\u5185\u6838\u955c\u50cf\uff09\uff0c\u4e00\u76f4\u662f\u653e\u7f6e\u5728 <code>0x8020_0000</code> \u7684\u7269\u7406\u5730\u5740\u4e0a\u7684\u3002\u73b0\u5728\uff0c\u6211\u4eec\u9700\u8981\u628a\u5b83\u6620\u5c04\u5230\u9ad8\u5730\u5740\u4e0a\u3002\u6211\u4eec\u5c06\u91c7\u7528\u56fa\u5b9a\u504f\u79fb\u91cf\u6765\u6620\u5c04\u6574\u4e2a ELF \u6587\u4ef6\u3002</p> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u5185\u6838\u4e2d\u5b9a\u4e49 (Defined) \u7684\u7b26\u53f7\uff08\u53d8\u91cf\u3001\u51fd\u6570\uff09\uff0c\u5b83\u4eec\u4f1a\u88ab OpenSBI \u52a0\u8f7d\u5230\u6307\u5b9a\u7684\u7269\u7406\u5730\u5740 <code>0x0000_0000_8020_abcd</code>\uff0c\u800c\u6211\u4eec\u6700\u7ec8\u4f1a\u5c06\u8be5\u7b26\u53f7\u52a0\u8f7d\u5230\u865a\u62df\u5730\u5740 <code>0xffff_ffff_8020_abcd</code> \u4e0a\u3002\u5bf9\u4e8e\u6240\u6709\u7b26\u53f7\uff0c\u8fd9\u4e24\u4e2a\u5730\u5740\u4e4b\u95f4\u6c38\u8fdc\u76f8\u5dee\u4e00\u4e2a\u56fa\u5b9a\u7684\u503c\u3002\u6211\u4eec\u5c06\u8be5\u503c\u5b9a\u4e49\u4e3a\u5185\u6838\u504f\u79fb\u91cf (kernel offset)\u3002</p> <p>\u6211\u4eec\u5c06\u8be5\u503c\u5b9a\u4e49\u4e3a\u5b8f <code>KERNEL_OFFSET</code>\uff0c\u5e76\u5b9a\u4e49\u5b8f <code>KIVA_TO_PA</code> \u548c <code>PA_TO_KIVA</code> \u5728\u4fbf\u4e8e\u4e24\u8005\u4e4b\u95f4\u8f6c\u6362\u3002(KIAV: Kernel Image Virtual Address)</p> <pre><code>#define KERNEL_VIRT_BASE 0xffffffff80200000ull\n#define KERNEL_PHYS_BASE 0x80200000ull\n#define KERNEL_OFFSET    ((uint64)(KERNEL_VIRT_BASE - KERNEL_PHYS_BASE))\n\n// (Kernel Image Virtual Address) TO (Physical Address)\n#define KIVA_TO_PA(x) (((uint64)(x)) - KERNEL_OFFSET)\n#define PA_TO_KIVA(x) (((uint64)(x)) + KERNEL_OFFSET)\n</code></pre> <p>\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u504f\u79fb\u6574\u4e2a\u955c\u50cf\u6587\u4ef6\u52a0\u8f7d\u7684\u57fa\u5730\u5740\u5e76\u4e0d\u4f1a\u6539\u53d8\u4e24\u4e2a\u7b26\u53f7\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u4e5f\u5c31\u662f\u8bf4\uff1a</p> <ol> <li>\u7b26\u53f7 a \u88ab\u52a0\u8f7d\u5230 PA_a <code>0x0000_0000_8020_dead</code>\uff0c\u7b26\u53f7 b \u88ab\u52a0\u8f7d\u5230 PA_b <code>0x0000_0000_8020_beef</code>\u3002</li> <li>\u7b26\u53f7 a \u5c06\u4f1a\u88ab\u6620\u5c04\u5230 VA_a <code>0xffff_ffff_8020_dead</code>\uff0c\u7b26\u53f7 b \u5c06\u4f1a\u88ab\u6620\u5c04\u5230 VA_b <code>0xffff_ffff_8020_beef</code></li> <li><code>PA_a - PA_b = VA_a - VA_b</code></li> </ol> <p>\u8fd9\u4e2a\u6027\u8d28\u5141\u8bb8\u6211\u4eec\u5728\u4f7f\u7528 <code>PC-relative</code> \u5bfb\u5740\u65f6\uff0c\u5bf9\u6574\u4e2a\u5185\u6838\u955c\u50cf\u8fdb\u884c\u91cd\u5b9a\u4f4d\u3002\u4f7f\u7528 <code>PC-relative</code> \u5bfb\u5740\u65f6\uff0c\u6211\u4eec\u4f1a\u901a\u8fc7\u5f53\u524d PC \u4e0e\u76ee\u6807\u7b26\u53f7\u7684\u504f\u79fb\u91cf\u6765\u8ba1\u7b97\u76ee\u6807\u7b26\u53f7\u7684\u5730\u5740\uff0c\u5177\u4f53\u800c\u8a00\uff0c\u5728\u6c47\u7f16\u4e0a\u4f7f\u7528 <code>auipc</code> \u548c <code>addi</code> \u6765\u8ba1\u7b97 <code>target = pc + offset</code>\uff0c\u800c\u4e0d\u662f <code>target = immediate</code>\uff08\u7acb\u5373\u6570\u5bfb\u5740\uff09\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6574\u4e2a\u5185\u6838\u955c\u50cf\u6574\u4f53\u91cd\u5b9a\u4f4d\u5230\u4efb\u4f55\u8d77\u59cb\u5730\u5740\uff0c\u53ea\u9700\u8981\u4fdd\u8bc1\u6240\u6709\u7b26\u53f7\u4e4b\u95f4\u7684\u504f\u79fb\u91cf\u5728\u7f16\u8bd1\u671f\u95f4\u548c\u88ab\u52a0\u8f7d\u65f6\u662f\u56fa\u5b9a\u7684\u5373\u53ef\u3002\u8fd9\u4e00\u6761\u6027\u8d28\u4e5f\u662f Linux Kernel \u80fd\u5b9e\u73b0\u5bf9\u81ea\u8eab\u955c\u50cf\u7684 KASLR (Kernel address space layout randomization, See also: https://lwn.net/Articles/569635/) \u7684\u539f\u7406\u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5b8c\u6210\u4e24\u6b65\u5373\u53ef\u5b9e\u73b0\u5185\u6838\u955c\u50cf\u7684\u91cd\u5b9a\u4f4d\uff1a</p> <ol> <li>\u5c06\u5185\u6838\u955c\u50cf\u6620\u5c04\u5230\u865a\u62df\u5730\u5740 <code>0xffff_ffff_8020_0000</code> \u4e0a\u3002</li> <li>\u5c06 PC \u8df3\u8f6c\u5230 <code>0xffff_ffff_8020_xxxx</code> \u7684\u9ad8\u5730\u5740\u4e0a\u3002</li> </ol> <p>\u6211\u4eec\u9884\u671f\u5185\u6838\u4f1a\u8fd0\u884c\u5728 <code>0xffff_ffff_8020_0000</code> \u7684\u9ad8\u5730\u5740\u4e0a\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539 <code>kernel.ld</code> \u4f7f\u94fe\u63a5\u5668\u80fd\u6b63\u786e\u94fe\u63a5\u5185\u6838\u3002</p> <pre><code>OUTPUT_ARCH(riscv)\nENTRY(_entry)\nBASE_ADDRESS = 0xffffffff80200000;\n</code></pre> <p>\u4f46\u662f\uff0c\u6b64\u65f6 OpenSBI \u65e0\u6cd5\u6b63\u786e\u52a0\u8f7d kernel ELF \u5230\u7269\u7406\u5730\u5740\u4e0a\uff0c\u56e0\u4e3a kernel ELF \u7684 Program Header \u7684\u9884\u8ba1\u52a0\u8f7d\u7684\u7269\u7406\u5730\u5740 (PhysAddr) \u662f <code>0xffff_ffff_8020_0000</code> \u7684\u9ad8\u5730\u5740\uff0c\u7136\u800c\u8fd9\u4e2a\u5730\u5740\u5728 OpenSBI \u52a0\u8f7d\u5185\u6838\u65f6\u662f\u975e\u6cd5\u7684\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u5728\u7b2c\u4e00\u4e2a\u6bb5 <code>.text</code> \u540e\u9762\u6ce8\u660e <code>AT(0x80200000)</code>\uff0c\u8868\u793a\u8fd9\u4e2a\u6bb5\u5e94\u8be5\u88ab\u52a0\u8f7d\u5230\u7269\u7406\u5730\u5740 <code>0x8020_0000</code>\u3002\u8fd9\u6837\u80fd\u4f7f\u94fe\u63a5\u5668\u4ea7\u751f\u7684 ELF \u7684 Program Headers \u62e5\u6709 <code>VirtAddr = 0xffff_ffff_8020_0000</code>\uff0c\u4ee5\u53ca <code>PhysAddr = 0x8020_0000</code>\u3002</p> <pre><code>BASE_ADDRESS = 0xffffffff80200000;\nSECTIONS\n{\n    . = BASE_ADDRESS;\n    skernel = .;\n    s_text = .;\n\n    .text : AT(0x80200000) {\n        *(.text.entry)\n        // ...\n    }\n    // ...\n}\n</code></pre> <p>\u6b64\u65f6\u518d <code>make run</code> \u8fd0\u884c\u5185\u6838\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 OpenSBI \u6b63\u786e\u627e\u5230\u4e86\u6211\u4eec\u5185\u6838\u7684\u5165\u53e3\u70b9\uff1a</p> <pre><code>Domain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\n...\nclean bss: 0x00000000802ac000 - 0x00000000802b3000\nKernel is Relocating...\n</code></pre> <p>\u63a5\u7740\uff0c\u6211\u4eec\u9700\u8981\u6784\u5efa\u9875\u8868\u6765\u8ba9MMU\u53ef\u4ee5\u6309\u7167\u6211\u4eec\u8bbe\u8ba1\u7684\u5e03\u5c40\u7ffb\u8bd1\u6211\u4eec\u7684\u865a\u62df\u5730\u5740\u3002</p> <p>\u5982\u679c\u6211\u4eec\u76f4\u63a5\u6309\u7167\u8bbe\u8ba1\u597d\u7684\u5185\u6838\u5185\u5b58\u5e03\u5c40\u6784\u5efa\u9875\u8868\uff0c\u6211\u4eec\u5c06\u9700\u8981\u5982\u4e0b\u4e24\u6761\u6216\u66f4\u591a\u6307\u4ee4\u6765\u5b8c\u6210\u5207\u6362\u9875\u8868+\u8df3\u8f6c\u5230\u9ad8\u5730\u5740\uff1a</p> <ol> <li><code>csrw satp</code>: \u8bbe\u7f6e satp \u5bc4\u5b58\u5668\uff0c\u542f\u7528 Sv39 \u5730\u5740\u7ffb\u8bd1</li> <li><code>...</code></li> </ol> <p>\u4f46\u662f\uff0c\u5f53\u6267\u884c\u7b2c\u4e00\u6761\u6307\u4ee4\u65f6\uff0c\u6211\u4eec\u7684 PC \u6307\u5411\u5728 <code>0x8020_xxxx</code> \u7684\u7269\u7406\u5730\u5740\u4e0a\u3002 \u53ef\u662f\uff0c\u5f53\u6211\u4eec\u6267\u884c\u5b8c\u7b2c 1 \u6761\u6307\u4ee4\u8bbe\u7f6e\u5b8c satp \u540e\uff0c\u9a6c\u4e0a\u5c06\u5f00\u59cb\u6267\u884c\u7b2c\u4e8c\u6761\u6307\u4ee4\uff0c\u800c\u6211\u4eec\u7684 PC \u8fd8\u6307\u5411\u7b2c\u4e8c\u6761\u6307\u4ee4\u7684\u7269\u7406\u5730\u5740\uff0c\u800c\u8fd9\u4e2a\u7269\u7406\u5730\u5740\u7684 PC \u5728\u5f53\u524d\u7684\u9875\u8868\u4e2d\u662f\u975e\u6cd5\u7684\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u7684\u7b2c\u4e8c\u6761\u6307\u4ee4\u5c31\u4f1a\u89e6\u53d1 Instruction Page Fault \u5f02\u5e38\u3002</p> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6211\u4eec\u8bbe\u7f6e\u5b8c\u5185\u6838\u9875\u8868\u540e\uff0c\u6211\u4eec\u5e76\u4e0d\u80fd\u76f4\u63a5\u5207\u6362\u5230\u4ec5\u5305\u542b\u9ad8\u5730\u5740\u7684\u9875\u8868\u4e0a\uff0c\u56e0\u4e3a\u6b64\u65f6\u6211\u4eec\u7684 PC \u6307\u9488\u8fd8\u6307\u5411\u4f4e\u5730\u5740\uff0c\u800c\u6211\u4eec\u65e0\u6cd5\u5728\u540c\u65f6\u5b8c\u6210\u5207\u6362 PC + \u5207\u6362 satp \u4e24\u4ef6\u4e8b\u60c5\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u4e34\u65f6\u9875\u8868\uff0c\u5176\u4e2d\u5305\u542b\u4e86\u4e24\u90e8\u4efd\u6620\u5c04\uff1a</p> <ol> <li>VA <code>0x0000_0000_8020_0000</code> -&gt; PA <code>0x8020_0000</code></li> <li>VA <code>0xffff_ffff_8020_0000</code> -&gt; PA <code>0x8020_0000</code></li> </ol> <p>\u5f53\u6267\u884c\u5b8c\u4e0a\u8ff0\u7b2c\u4e00\u6761\u6307\u4ee4\u542f\u7528 Sv39 \u540e\uff0c\u6211\u4eec\u76ee\u524d\u7684 PC \u867d\u7136\u662f\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u7269\u7406\u5730\u5740\uff0c\u4f46\u662f\u5b83\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u865a\u62df\u5730\u5740\u3002\u6211\u4eec\u53ef\u4ee5\u52a0\u8f7d\u4e00\u4e2a\u7acb\u5373\u6570\u5230\u5bc4\u5b58\u5668\u4e2d\uff0c\u7136\u540e\u4f7f\u7528 <code>jr</code> \u6307\u4ee4\u8df3\u8f6c\u5230\u8be5\u5bc4\u5b58\u5668\u7684\u503c\uff0c\u4ece\u800c\u8fdb\u5165\u5230\u9ad8\u5730\u5740\u3002</p> <p>\u6211\u4eec\u5c06\u8fd9\u4e00\u7cfb\u5217\u6b65\u9aa4\u79f0\u4e3a Relocate (\u91cd\u5b9a\u4f4d)\u3002</p> <p>See also: https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-6.html</p>"},{"location":"lab/xv6lab-paging/#relocation_start","title":"<code>relocation_start</code> \u4ee3\u7801\u89e3\u91ca","text":"<p>\u5728 relocation_start \u7684\u4e34\u65f6\u9875\u8868\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 2 MiB \u7684\u5927\u9875\u6620\u5c04\u3002\u6211\u4eec\u5148\u5f00\u8f9f\u56db\u4e2a\u5bf9\u9f50\u7684\u7269\u7406\u9875\u9762\uff1a</p> <pre><code>static char relocate_pagetable[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_ident[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_direct_mapping[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_high[PGSIZE] __attribute__((aligned(PGSIZE)));\n</code></pre> <p>\u6211\u4eec\u8ba1\u7b97\u5185\u6838\u955c\u50cf\u7684\u7ec8\u6b62\u70b9 <code>ekernel</code> \u5411\u4e0a\u5bf9\u9f50\u5230 2MiB \u7684\u5927\u5c0f\u3002\u8fd9\u662f\u56e0\u4e3a 2 MiB \u7684\u5927\u9875\u6620\u5c04\u8981\u6c42\u865a\u62df\u5730\u5740\u548c\u7269\u7406\u5730\u5740\u540c\u65f6\u5bf9\u9f50\u5230 2MiB \u4e0a\u3002</p> <pre><code>// Kernel Start Point must be aligned to 2MiB\nassert(IS_ALIGNED(KERNEL_PHYS_BASE, PGSIZE_2M));\n\n// Calculate Kernel image size, and round up to 2MiB.\nuint64 kernel_size = (uint64)ekernel - (uint64)skernel;\nuint64 kernel_size_4K = ROUNDUP_2N(kernel_size, PGSIZE);\nuint64 kernel_size_2M = ROUNDUP_2N(kernel_size, PGSIZE_2M);\n\nkernel_image_end_4k = KERNEL_PHYS_BASE + kernel_size_4K;\nkernel_image_end_2M = KERNEL_PHYS_BASE + kernel_size_2M;\n\nprintf(\"Kernel size: %p, Rounded to 2MiB: %p\\n\", kernel_size, kernel_size_2M);\n</code></pre> <p>\u5728 <code>kernel_image_end_2M</code> \u540e\u9762\uff0c\u6211\u4eec\u518d\u5f00\u8f9f\u4e00\u4e2a 2MiB \u7684\u9875\u9762\u4f5c\u4e3a Kernel Direct Mapping \u7684\u7b2c\u4e00\u4e2a\u5185\u5b58\u6c60\uff0c\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u8bb2\u5230\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u4e48\u505a\u3002</p> <pre><code>// Calculate Kernel Mapping Base &amp; End\nuint64 kernel_phys_base = KERNEL_PHYS_BASE;\nuint64 kernel_phys_end = kernel_phys_base + kernel_size_2M;\nuint64 kernel_virt_base = KERNEL_VIRT_BASE;\nuint64 kernel_virt_end = kernel_virt_base + kernel_size_2M;\n\n// Calculate the first Direct Mapping Base &amp; End\nuint64 kernel_la_phy_base = kernel_image_end_2M;\nuint64 kernel_la_base = KERNEL_DIRECT_MAPPING_BASE + kernel_la_phy_base;\nuint64 kernel_la_end = kernel_la_base + PGSIZE_2M;\n</code></pre> <p>\u7136\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u6620\u5c04\uff1aVA <code>0x0000_0000_8020_0000</code> -&gt; PA <code>0x8020_0000</code></p> <ol> <li>\u5728 <code>pgt_root</code> \u4e0a\u6dfb\u52a0\u4e00\u6761 PTE\uff0c\u4f7f\u5176\u6307\u5411\u7b2c\u4e00\u7ea7\u9875\u8868 <code>pgt_ident</code>\u3002</li> <li>\u4ece <code>kernel_phys_base</code> \u5230 <code>kernel_phys_end</code>\uff0c\u6bcf 2 MiB \u6dfb\u52a0\u4e00\u4e2a PTE \u6620\u5c04</li> <li>\u8ba1\u7b97\u8be5\u7269\u7406\u5730\u5740\u5e94\u8be5\u88ab\u6620\u5c04\u5230\u54ea\u4e2a\u865a\u62df\u5730\u5740\u4e0a\uff0c\u5728\u8fd9\u4e2a\u6620\u5c04\u4e2d\uff0c<code>va = pa</code>\u3002</li> <li>\u8ba1\u7b97 <code>VPN1</code>\uff0c\u5e76\u5728 <code>pgt_ident</code> \u4e2d\u6dfb\u52a0\u6620\u5c04\u3002</li> </ol> <pre><code>// We will still have some instructions executed on pc 0x8020xxxx before jumping to KIVA.\n// Step 2. Setup Identity Mapping for 0x80200000 -&gt; 0x80200000, using 2MiB huge page.\n{\n    uint64 VPN2 = PX(2, kernel_phys_base);\n    pgt_root[VPN2] = MAKE_PTE((uint64)pgt_ident, 0);\n\n    for (uint64 pa = kernel_phys_base; pa &lt; kernel_phys_end; pa += PGSIZE_2M) {\n        uint64 va = pa;\n        uint64 vpn1 = PX(1, va);\n        pgt_ident[vpn1] = MAKE_PTE(pa, PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);\n        printf(\"Mapping Identity: %p to %p\\n\", va, pa);\n    }\n}\n</code></pre> <p>\u7136\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u6620\u5c04\u5185\u6838 ELF \u7684\u865a\u62df\u5730\u5740\uff1aVA <code>0xffff_ffff_8020_0000</code> -&gt; PA <code>0x8020_0000</code>\u3002 \u6b64\u65f6 <code>va = pa + KERNEL_OFFSET</code>\u3002</p> <p>\u6700\u540e\uff0c\u6211\u4eec\u6620\u5c04\u7b2c\u4e00\u5757 Direct Mapping\uff1aVA <code>0xffff_ffc0_80xx_0000</code> -&gt; \u7b2c\u4e00\u4e2a\u7a7a\u95f2\u7684 2 MiB \u7269\u7406\u9875 <code>0x80xx_0000</code>\u3002</p>"},{"location":"lab/xv6lab-paging/#_9","title":"\u5185\u6838\u9875\u8868","text":"<p>code: <code>os/kvm.c</code></p> <p>\u5728\u5b8c\u6210 Relocation \u540e\uff0c\u6211\u4eec\u7684 pc \u4f4d\u4e8e\u9ad8\u5730\u5740\uff0csp \u4f4d\u4e8e <code>boot_stack</code> \u7684\u9ad8\u5730\u5740\uff1a</p> <pre><code>Mapping Identity: 0x0000000080200000 to 0x0000000080200000\nMapping kernel image: 0xffffffff80200000 to 0x0000000080200000\nMapping Direct Mapping: 0xffffffc080400000 to 0x0000000080400000\nEnable SATP on temporary pagetable.\nBoot HART Relocated. We are at high address now! PC: 0xffffffff80203d68, SP: 0xffffffff80223ff0\n</code></pre> <p>\u6211\u4eec\u5728 <code>bootcpu_relocating</code> \u4e2d\u8c03\u7528 <code>kvm_init()</code> \u6765\u6784\u9020\u6700\u7ec8\u7684\u5185\u6838\u9875\u8868\uff0c\u5e76\u5207\u6362\u5230\u8be5\u9875\u8868\u4e0a\u3002</p> <p>\u5728\u6784\u5efa\u5185\u6838\u9875\u8868\u65f6\uff0c\u6211\u4eec\u4f1a\u9700\u8981\u7533\u8bf7\u7269\u7406\u9875\u9762\u6765\u653e\u7f6e\u9875\u8868\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a <code>boot-stage page allocator</code>\uff0c\u8fd9\u4e9b\u9875\u9762\u7684\u751f\u547d\u5468\u671f\u662f\u6301\u4e45\u7684\uff0c\u6c38\u8fdc\u4e0d\u4f1a\u88ab\u91ca\u653e\u3002 \u4f46\u662f\u540e\u7eed\u6211\u4eec\u4f1a\u9700\u8981\u8bbf\u95ee\u8fd9\u4e9b\u9875\u8868\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee4\u5b83\u7684\u7269\u7406\u5730\u5740\u533a\u57df\u4f4d\u4e8e Direct Mapping \u533a\u95f4\u4e0a\uff0c\u5e76\u4e14\u4ee5\u540e\u80fd\u901a\u8fc7 Direct Mapping \u7684\u865a\u62df\u5730\u5740\u8fdb\u884c\u8bbf\u95ee\u3002 Relocation \u65f6\uff0c\u6211\u4eec\u4f1a\u5728 Direct Mapping \u533a\u95f4\u5148\u501f\u7528\u4e00\u4e2a 2MiB \u7684\u533a\u57df\uff0c\u5373 <code>e_kernel</code> (0x802x_0000) \u5bf9\u9f50\u5230 2MiB (0x8040_0000) \u540e\u7684\u4e0b\u4e00\u4e2a 2MiB \u533a\u57df <code>[0x8040_0000, 0x8060_0000)</code>\u3002 <pre><code>[INFO  0,-1] kvm_init: boot-stage page allocator: base 0xffffffc080400000, end 0xffffffc080600000\n</code></pre></p> <p><code>kvmmake</code> \u51fd\u6570\u4f1a\u8c03\u7528 <code>kvmmap</code> \u4f9d\u6b21\u6620\u5c04\u6bcf\u4e2a\u533a\u57df\u3002</p> <pre><code>static pagetable_t kvmmake() {\n    pagetable_t kpgtbl;\n    kpgtbl = (pagetable_t)allocsetuppage();\n    memset(kpgtbl, 0, PGSIZE);\n\n    // Step.1 : Kernel Image\n    // Step.2 : Kernel Trampoline\n    // Step.3 : Kernel Device MMIO :\n    // Step.4 : Kernel Scheduler stack:\n    // Step.5 : Kernel Direct Mapping\n}\n</code></pre> <p><code>kvmmap</code> \u7684\u539f\u578b\u4e3a <code>void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)</code>\uff0c\u8868\u793a\u5c06 <code>[va, va+sz)</code> \u6620\u5c04\u5230 <code>[pa, pa+sz)</code> \u7684\u533a\u57df\u4e0a\u3002</p> <ol> <li>\u5bf9\u4e8e Kernel Image\uff0c\u6211\u4eec\u6620\u5c04\u4e09\u4e2a\u5206\u533a\uff1a<code>.text</code> (RX), <code>.rodata</code> (RO), <code>.data (.bss)</code> (RW)\u3002\u6211\u4eec\u53ef\u4ee5\u5f15\u7528\u5728 <code>kernel.ld</code> \u4e2d\u5bfc\u51fa\u7684\u5730\u5740\u7b26\u53f7 <code>e_text</code> \u7b49\u6765\u5f97\u5230\u6bcf\u4e2a\u5206\u533a\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\u3002\u6ce8\u610f\u6211\u4eec\u76f4\u63a5\u5f15\u7528\u7b26\u53f7 <code>s_text</code> \u65f6\uff0c\u6211\u4eec\u4f1a\u901a\u8fc7 auipc \u6307\u4ee4\u5f97\u5230\u5b83\u7684\u865a\u62df\u5730\u5740\uff1b\u800c\u5b83\u7684\u7269\u7406\u5730\u5740\u5219\u53ef\u4ee5\u901a\u8fc7 <code>KIVA_TO_PA</code> \u8f6c\u6362\u5f97\u5230\u3002</li> </ol> <p>\u5728 <code>kernel.ld</code> \u4e2d\u7684 <code>.text</code> \u5b58\u5728\u53e6\u4e00\u4e2a\u7279\u6b8a\u7684\u9875\u9762\uff0c\u79f0\u4e3a trampoline\uff0c\u6211\u4eec\u4f1a\u5728\u4e0b\u4e00\u8282\u8bfe\u8bb2\u5230\u5b83\u3002\u6211\u4eec\u5c06\u5b83\u6620\u5c04\u5230\u865a\u62df\u5730\u5740 <code>0x3f_ffff_f000</code> \u4e0a\u3002</p> <pre><code>    // map kernel text executable and read-only.\n    // 0xffff_ffff_8020_0000 -&gt; 0x8020_0000\n    kvmmap(kpgtbl, (uint64)s_text, KIVA_TO_PA(s_text), (uint64)e_text - (uint64)s_text, PTE_A | PTE_R | PTE_X);\n\n    // map kernel ro_data: s_rodata to e_rodata\n    kvmmap(kpgtbl, (uint64)s_rodata, KIVA_TO_PA(s_rodata), (uint64)e_rodata - (uint64)s_rodata, PTE_A | PTE_R);\n\n    // map kernel .s_data to .e_bss,\n    uint64 kimage_data_size = KIVA_TO_PA(e_bss) - KIVA_TO_PA(s_data);\n    kvmmap(kpgtbl, (uint64)s_data, KIVA_TO_PA(s_data), kimage_data_size, PTE_A | PTE_D | PTE_R | PTE_W);\n\n    // map trampoline\n    kvmmap(kpgtbl, (uint64)TRAMPOLINE, KIVA_TO_PA(trampoline), PGSIZE, PTE_A | PTE_R | PTE_X);\n</code></pre> <p>\u6b64\u65f6\uff0c<code>kernel_pagetable</code> \u7684\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>=== PageTable at 0xffffffc080400000 ===\n[ff], pte[0xffffffc0804007f8]: 0x0000003fc0000000 -&gt; 0x0000000080403000 -------V\n  [1ff], pte[0xffffffc080403ff8]: 0x0000003fffe00000 -&gt; 0x0000000080404000 -------V\n    [1ff], pte[0xffffffc080404ff8]: 0x0000003ffffff000 -&gt; 0x000000008020a000 -A--X-RV\n[1fe], pte[0xffffffc080400ff0]: 0xffffffff80000000 -&gt; 0x0000000080401000 -------V\n  [1], pte[0xffffffc080401008]: 0xffffffff80200000 -&gt; 0x0000000080402000 -------V\n    [0], pte[0xffffffc080402000]: 0xffffffff80200000 -&gt; 0x0000000080200000 -A--X-RV\n    ...\n    [9], pte[0xffffffc080402048]: 0xffffffff80209000 -&gt; 0x0000000080209000 -A--X-RV\n    [b], pte[0xffffffc080402058]: 0xffffffff8020b000 -&gt; 0x000000008020b000 -A----RV\n    ...\n    [20], pte[0xffffffc080402100]: 0xffffffff80220000 -&gt; 0x0000000080220000 -A----RV\n    [21], pte[0xffffffc080402108]: 0xffffffff80221000 -&gt; 0x0000000080221000 DA---WRV\n    ...\n    [2c], pte[0xffffffc080402160]: 0xffffffff8022c000 -&gt; 0x000000008022c000 DA---WRV\n=== END ===\n</code></pre> <ol> <li>\u7136\u540e\uff0c\u6211\u4eec\u6620\u5c04\u5916\u8bbe\u7684 MMIO \u533a\u57df\uff0c\u76ee\u524d\u6211\u4eec\u4f1a\u4f7f\u7528\u5230 PLIC \u548c UART0 \u4e24\u4e2a\u5916\u8bbe\u3002</li> </ol> <pre><code>    // Step.3 : Kernel Device MMIO :\n    kvmmap(kpgtbl, KERNEL_PLIC_BASE, PLIC_PHYS, KERNEL_PLIC_SIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n    kvmmap(kpgtbl, KERNEL_UART0_BASE, UART0_PHYS, KERNEL_UART0_SIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n</code></pre> <ol> <li>\u7136\u540e\uff0c\u6211\u4eec\u6620\u5c04\u6bcf\u4e2a cpu \u7684 scheduler \u6240\u7528\u7684\u6808\u3002\u6211\u4eec\u4ee4\u6bcf\u4e2a scheduler \u7684\u5185\u6838\u4e3a\u4e24\u4e2a <code>PGSIZE</code>\uff0c\u5e76\u4e14\u76f8\u90bb\u7684\u4e24\u4e2a\u6808\u7a7a\u95f4\u76f8\u9694\u4e00\u6bb5\u975e\u6cd5\u7684\u5730\u5740\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a <code>guard page</code>\u3002\u5982\u679c\u6211\u4eec\u5728\u5185\u6838\u6808\u4e0a\u53d1\u751f\u6808\u6ea2\u51fa\uff0c\u6211\u4eec\u4f1a\u5f97\u5230\u4e00\u4e2a Page Fault \u800c\u4e0d\u662f\u5185\u6838\u5e26\u7740\u9519\u8bef\u6084\u65e0\u58f0\u606f\u7684\u7ee7\u7eed\u8fd0\u884c\u3002</li> </ol> <pre><code>    // Step.4 : Kernel Scheduler stack:\n    uint64 sched_stack = KERNEL_STACK_SCHED;\n    for (int i = 0; i &lt; NCPU; i++) {\n        struct cpu *c = getcpu(i);\n        // allocate #KERNEL_STACK_SIZE / PGSIZE pages\n        for (uint64 va = sched_stack; va &lt; sched_stack + KERNEL_STACK_SIZE; va += PGSIZE) {\n            uint64 __pa newpg = KVA_TO_PA(allockernelpage());\n            debugf(\"map halt %d, va:%p, pa:%p\", i, va, newpg);\n            kvmmap(kpgtbl, va, newpg, PGSIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n        }\n        c-&gt;sched_kstack_top = sched_stack + KERNEL_STACK_SIZE;\n        // double the sched_stack to make a significant gap between different cpus.\n        //  if any kernel stack overflows, it will page fault.\n        sched_stack += 2 * KERNEL_STACK_SIZE;\n    }\n</code></pre> <p>\u5185\u6838 scheduler \u6808\u7684\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff0c\u5c3d\u7ba1\u6240\u5206\u914d\u7684\u9875\u9762\u5728\u7269\u7406\u5730\u5740\u5927\u6982\u7387\u662f\u8fde\u7eed\u7684\uff0c\u4f46\u662f\u5728\u865a\u62df\u5730\u5740\u4e0a\u6211\u4eec\u53ef\u4ee5\u6545\u610f\u4ee4\u5b83\u4e0d\u8fde\u7eed\u3002</p> <pre><code>[1ff], pte[0xffffffc080400ff8]: 0xffffffffc0000000 -&gt; 0x0000000080405000 -------V\n  [1f8], pte[0xffffffc080405fc0]: 0xffffffffff000000 -&gt; 0x0000000080408000 -------V\n    [0], pte[0xffffffc080408000]: 0xffffffffff000000 -&gt; 0x0000000080407000 DA---WRV\n    [1], pte[0xffffffc080408008]: 0xffffffffff001000 -&gt; 0x0000000080409000 DA---WRV\n    [4], pte[0xffffffc080408020]: 0xffffffffff004000 -&gt; 0x000000008040a000 DA---WRV\n    [5], pte[0xffffffc080408028]: 0xffffffffff005000 -&gt; 0x000000008040b000 DA---WRV\n    [8], pte[0xffffffc080408040]: 0xffffffffff008000 -&gt; 0x000000008040c000 DA---WRV\n    [9], pte[0xffffffc080408048]: 0xffffffffff009000 -&gt; 0x000000008040d000 DA---WRV\n    [c], pte[0xffffffc080408060]: 0xffffffffff00c000 -&gt; 0x000000008040e000 DA---WRV\n    [d], pte[0xffffffc080408068]: 0xffffffffff00d000 -&gt; 0x000000008040f000 DA---WRV\n</code></pre> <ol> <li>\u6700\u540e\uff0c\u8ba1\u7b97\u7cfb\u7edf\u4e2d\u6240\u6709\u5e94\u8be5\u88ab Direct Mapping \u7ba1\u7406\u7684\u9875\u9762\uff0c\u5373 <code>kernel_image_end_2M</code> \u5f00\u59cb\u5230\u7269\u7406\u5185\u5b58\u7a7a\u95f4\u7684\u7ed3\u675f\uff0c\u4ece <code>0xffffffc0_80400000 -&gt; 0x00000000_80400000</code> \u5904\u5f00\u59cb\u6620\u5c04\u3002\u6ce8\u610f\u5230 <code>boot-stage page allocator</code> \u6240\u7528\u7684\u533a\u57df\uff08<code>[0x8040_0000, 0x8060_0000)</code>\uff09\u4e5f\u4f1a\u5728\u8fd9\u4e2a\u6620\u5c04\u8303\u56f4\u4e4b\u5185\u3002</li> </ol> <p>\u4e4b\u540e\uff0c\u5c06\u5269\u4e0b\u7684\u7a7a\u95f4\u4ea4\u7ed9 <code>kalloc.c</code> \u4e2d\u7684 <code>kpgmgr</code> \u7ba1\u7406\uff0c\u6ce8\u610f <code>boot-stage page allocator</code> \u7684\u533a\u57df\u4e0d\u5728 <code>kpgmgr</code> \u7ba1\u7406\u8303\u56f4\u5185\uff1a</p> <pre><code>    // So page allocator should starts after these used pages.\n    kpage_allocator_base = init_page_allocator;\n    kpage_allocator_size = available_mems - (init_page_allocator - init_page_allocator_base);\n</code></pre>"},{"location":"lab/xv6lab-paging/#kvmmap","title":"kvmmap","text":"<p><code>kvmmap</code> \u8d1f\u8d23\u6309\u7167 Sv39 \u7684\u4e09\u7ea7\u9875\u8868\u683c\u5f0f\u5bf9 <code>vaddr</code> \u9010\u7ea7\u5c55\u5f00\uff0c\u5206\u914d\u76f8\u5e94\u7684\u7269\u7406\u9875\u4f5c\u4e3a\u9875\u8868\uff0c\u5e76\u586b\u5145\u5bf9\u5e94\u7684\u9875\u8868\u9879\u3002\u5f53\u9047\u5230\u672a\u88ab\u5206\u914d\u7684\u6b21\u7ea7\u9875\u8868\u65f6\uff0c\u4ece <code>allockernelpage</code> \u5904\u5206\u914d\u4e00\u4e2a\uff0c\u5e76\u8bbe\u7f6e\u4e0a\u7ea7\u5230\u6b21\u7ea7\u7684 PTE (<code>RWX=000</code>) \u5373\u53ef\u3002\u6700\u540e\uff0c\u5728\u6700\u540e\u4e00\u7ea7\u6309\u7167\u7ed9\u5b9a\u7684 <code>perm</code> \u8bbe\u7f6e PTE \uff1a<code>pgtbl_level0[vpn0] = MAKE_PTE(paddr, perm)</code>\u3002</p> <p>\u5f53\u7136\uff0c\u5f53\u6211\u4eec\u6620\u5c04\u4e00\u5927\u7247\u5bf9\u9f50\u5230 2MiB \u7684\u5185\u5b58\u533a\u57df\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a 2MiB \u7684\u5927\u9875\u6620\u5c04\uff0c\u800c\u4e0d\u662f\u591a\u4e2a 4KiB \u7684\u6620\u5c04\u3002\u8fd9\u9700\u8981\u6ee1\u8db3\u5927\u9875\u6620\u5c04\u7684\u6761\u4ef6\uff1a <code>IS_ALIGNED(vaddr, PGSIZE_2M) &amp;&amp; IS_ALIGNED(paddr, PGSIZE_2M) &amp;&amp; sz &gt;= PGSIZE_2M</code>\u3002</p> <pre><code>void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm) {\n    assert(PGALIGNED(va));\n    assert(PGALIGNED(pa));\n    assert(PGALIGNED(sz));\n\n    debugf(\"va:%p, pa:%p, sz:%x\", va, pa, sz);\n\n    pagetable_t __kva pgtbl_level1, pgtbl_level0;\n    uint64 vpn2, vpn1, vpn0;\n\n    uint64 __kva vaddr     = va;\n    uint64 __kva paddr     = pa;\n    uint64 __kva vaddr_end = vaddr + sz;\n\n    while (vaddr &lt; vaddr_end) {\n        // try to add mapping: vaddr -&gt; pa\n        vpn2 = PX(2, vaddr);\n        vpn1 = PX(1, vaddr);\n        vpn0 = PX(0, vaddr);\n\n        if (!(kpgtbl[vpn2] &amp; PTE_V)) {\n            // kpgtbl[vpn2] is not a valid PTE, allocate the level 1 pagetable.\n            uint64 __kva newpg = allockernelpage();\n            memset((void *)newpg, 0, PGSIZE);\n            pgtbl_level1 = (pagetable_t)newpg;\n            kpgtbl[vpn2] = MAKE_PTE(KVA_TO_PA(newpg), 0);\n        } else {\n            pte_t pte = kpgtbl[vpn2];\n            // check validity: pte must points to next level page table.\n            if ((pte &amp; PTE_R) || (pte &amp; PTE_W) || (pte &amp; PTE_X))\n                panic(\"kvmmap: vaddr %p already mapped at level 2\", vaddr);\n            pgtbl_level1 = (pagetable_t)PA_TO_KVA(PTE2PA(kpgtbl[vpn2]));\n        }\n        if (!(pgtbl_level1[vpn1] &amp; PTE_V)) {\n            // pgtbl_level1[vpn1] is not a valid PTE.\n            //   try to allocate 2M page\n            //   , or allocate the level 1 pagetable.\n            if (IS_ALIGNED(vaddr, PGSIZE_2M) &amp;&amp; IS_ALIGNED(paddr, PGSIZE_2M) &amp;&amp; sz &gt;= PGSIZE_2M) {\n                // it's ok for a huge page.\n                pgtbl_level1[vpn1] = MAKE_PTE(paddr, perm);\n                vaddr += PGSIZE_2M;\n                paddr += PGSIZE_2M;\n                sz -= PGSIZE_2M;\n                continue;\n            }\n            uint64 __kva newpg = allockernelpage();\n            memset((void *)newpg, 0, PGSIZE);\n            pgtbl_level0       = (pagetable_t)newpg;\n            pgtbl_level1[vpn1] = MAKE_PTE(KVA_TO_PA(newpg), 0);\n        } else {\n            pte_t pte = pgtbl_level1[vpn1];\n            // check validity: pte must points to next level page table.\n            if ((pte &amp; PTE_R) || (pte &amp; PTE_W) || (pte &amp; PTE_X))\n                panic(\"kvmmap: vaddr %p already mapped at level 1\", vaddr);\n            pgtbl_level0 = (pagetable_t)PA_TO_KVA(PTE2PA(pgtbl_level1[vpn1]));\n        }\n        // check validity: pte must points to next level page table.\n        if (pgtbl_level0[vpn0] &amp; PTE_V)\n            panic(\"kvmmap: vaddr %p already mapped at level 0\", vaddr);\n        pgtbl_level0[vpn0] = MAKE_PTE(paddr, perm);\n        vaddr += PGSIZE;\n        paddr += PGSIZE;\n        sz -= PGSIZE;\n    }\n    assert(vaddr == vaddr_end);\n    assert(sz == 0);\n}\n</code></pre>"},{"location":"lab/xv6lab-paging/#kalloc","title":"kalloc \u6a21\u5757","text":"<p><code>kalloc.c</code> \u4f1a\u5728\u542f\u52a8\u540e\u63a5\u7ba1 Direct Mapping \u533a\u57df\u7684\u7269\u7406\u9875\u9762\uff0c\u5176\u8d1f\u8d23\u4e24\u4e2a\u529f\u80fd\uff1a</p> <ol> <li>\u5206\u914d\u7269\u7406\u9875\u9762\uff1a<code>void *__pa kallocpage()</code>, <code>void kfreepage(void *__pa pa)</code></li> <li>\u5bf9\u56fa\u5b9a\u7c7b\u578b\u5bf9\u8c61\u7684\u52a8\u6001\u5206\u914d\u548c\u56de\u6536 (\u5bf9\u8c61\u5206\u914d\u5668\u7ba1\u7406)\uff1a<code>allocator_init</code>, <code>kalloc</code>, <code>kfree</code>\u3002</li> </ol> <p>\u5728 kalloc \u63a5\u7ba1\u5185\u6838\u542f\u52a8\u540e\u5269\u4f59\u7684\u7269\u7406\u5185\u5b58\uff08\u5373\u4e0a\u56fe\u7d2b\u8272\u90e8\u5206\uff09\u540e\uff0c\u6211\u4eec\u9700\u8981\u4ece\u5b83\u5206\u914d\uff1a</p> <ol> <li>\u6bcf\u4e2a object allocator\uff08\u5bf9\u8c61\u5206\u914d\u5668\uff09\u6240\u7528\u7684\u5185\u5b58\u6c60</li> <li>\u6bcf\u4e2a process \u7684 kernel stack</li> <li>\u6bcf\u4e2a cpu scheduler \u7684 kernel stack</li> </ol> <p>\u968f\u540e\uff0c\u7528\u6237\u7a7a\u95f4\u6240\u9700\u8981\u7684\u9875\u9762\uff0c\u548c\u914d\u7f6e\u9875\u8868\u6240\u9700\u8981\u7684\u9875\u9762\u5747\u7531 <code>kalloc</code> \u6a21\u5757\u7ba1\u7406\u3002</p>"},{"location":"lab/xv6lab-paging/#_10","title":"\u5b9e\u9a8c\u90e8\u5206\u601d\u8003\u9898","text":"<p>\u6ce8\uff1a\u8fd9\u90e8\u5206\u4e0d\u8981\u6c42\u5728\u8bfe\u5802\u5b9e\u9a8c\u62a5\u544a\u4e0a\u63d0\u4ea4\u3002</p> <p>Question</p> <p>\u6211\u4eec\u5728 <code>kernel.ld</code> \u91cc\u9762\u4e3a <code>_entry</code> \u7b26\u53f7\u6307\u5b9a\u7684\u865a\u62df\u5730\u5740\u662f <code>0xffff_ffff_8020_0000</code>\uff0c<code>entry.S</code> \u4e2d\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u8fdb\u884c\u8df3\u8f6c</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 code:riscv:RISCV \u2500\u2500\u2500\u2500\n\u25cf\u2192  0x80200000 &lt;skernel+0000&gt;   auipc  sp, 0xac\n    0x80200004 &lt;skernel+0004&gt;   mv     sp, sp\n    0x80200008 &lt;skernel+0008&gt;   auipc  ra, 0x2\n    0x8020000c &lt;skernel+000c&gt;   jalr   488(ra)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:os/entry.S+4 \u2500\u2500\u2500\u2500\n    3  _entry:\n\u2192   4      lla sp, boot_stack_top\n    5      call bootcpu_entry\n</code></pre> <p>\u8bf7\u601d\u8003\uff1a\u4e3a\u4ec0\u4e48\u5728\u7a0b\u5e8f\u8fd0\u884c\u5728 <code>0x0000_0000_8020_0000</code> \u7684\u5730\u5740\u4e0a\u65f6\uff0c\u4f7f\u7528 <code>lla</code> \u52a0\u8f7d\u7b26\u53f7 <code>boot_stack_top</code> \u548c <code>call bootcpu_entry</code> \u8df3\u8f6c\u65f6 \u80fd\u627e\u5230\u6b63\u786e\u7684\u7269\u7406\u5730\u5740 <code>0x8020_416c</code>\uff0c\u800c\u4e0d\u662f\u5728\u6b64\u65f6\u4e3a\u975e\u6cd5\u7684\u865a\u62df\u5730\u5740 <code>0xffff_ffff_8020_416c</code>\uff1f</p> <p>Hint: \u6211\u4eec\u662f\u5982\u4f55\u5bfb\u5740\u7684\uff1f\u56de\u5fc6\u8ba1\u7b97\u673a\u7ec4\u6210\u539f\u7406\u8bfe\u4e0a\u5b66\u4e60\u7684\u5bfb\u5740\u6a21\u5f0f\u3002</p> <p>\u9875\u8868\u4e0e\u5185\u5b58\u4fdd\u62a4</p> <p>\u5728 <code>main.c</code> \u7684 <code>bootcpu_init</code> \u51fd\u6570\u4e2d\uff0c<code>infof(\"start scheduler!\");</code> \u524d\u63d2\u5165\u4ee5\u4e0b\u4ee3\u7801\uff1a</p> <pre><code>static volatile uint64 number = 0xdeadbeefaabbccdd;\nprintf(\"addr  of number: %p\\n\", &amp;number);\nprintf(\"value of number: %p\\n\", number);\n*(uint64*)&amp;number = 0xdeadbeef00100073; // 00100073 is an ebreak instruction.\nprintf(\"changed value of number: %p\\n\", number);\n((void(*)())&amp;number)(); // execute a function, which address is &amp;number\npanic(\"qwq\");\n</code></pre> <p><code>make run</code> \u8fd0\u884c\u5185\u6838\uff0c\u4f60\u5e94\u8be5\u4f1a\u9047\u5230 Kernel Panic\uff0cCode = 12, \u67e5\u9605\u624b\u518c\u7406\u89e3\u4e3a\u4ec0\u4e48\u4f1a\u4ea7\u751f\u8be5\u5f02\u5e38\u3002</p> <p>\u56de\u5230\u4e0a\u6b21lab\u7684\u5b9e\u9a8c\u76ee\u5f55 <code>xv6lab3</code>\uff0c<code>git reset --hard da5eb84e</code>\uff0c\u7136\u540e\u505a\u51fa\u4e00\u6837\u7684\u4fee\u6539\uff0c<code>make clean &amp;&amp; make run</code> \u8fd0\u884c\u5185\u6838\uff0c\u4f60\u5e94\u8be5\u8fd8\u4f1a\u9047\u5230 Kernel Panic\uff0c\u4f46\u662f Code = 3\uff0c\u8fd9\u8868\u793a ebreak \u6307\u4ee4\u88ab\u6267\u884c\u4e86\u3002</p> <p>\u8fd9\u5373\u662f\u5728\u540c\u4e00\u7279\u6743\u7ea7\u4e0b\u4f7f\u7528\u9875\u8868\u8fdb\u884c\u5185\u5b58\u4fdd\u62a4\u7684\u610f\u4e49\uff1a\u5b83\u53ef\u4ee5\u963b\u6b62\u6267\u884c\u9884\u671f\u4e4b\u5916\u7684\u884c\u4e3a\u3002</p> <p>\u5982\u679c\u5c06 <code>number</code> \u7684\u7c7b\u578b\u4fee\u6539\u4e3a <code>const static volatile</code>\uff0c\u4f60\u5e94\u8be5\u4f1a\u6536\u83b7\u4e00\u4e2a Code = 15 \u7684 Kernel Panic\uff0c\u8fd9\u662f\u56e0\u4e3a const \u4fee\u9970\u7b26\u4f1a\u4f7f\u5f97\u5b83\u88ab\u5206\u914d\u5728 <code>.rodata</code> \u6bb5\uff0c\u800c\u8fd9\u4e2a\u6bb5\u5728\u9875\u8868\u6620\u5c04\u4e2d\u662f <code>R--</code> \u7684\u3002</p> <p>\u7c7b\u4f3c\u7684\uff0c\u4f60\u4e5f\u53ef\u4ee5\u5c1d\u8bd5\u4fee\u6539 <code>scheduler</code> \u51fd\u6570\u7684\u5185\u5bb9\uff1a</p> <pre><code>*(uint32*)&amp;scheduler = 0x00100073; // 00100073: ebreak\ninfof(\"start scheduler!\");\nscheduler();\n</code></pre> <p>\u4f60\u53ef\u4ee5\u5bf9\u6bd4\u5728\u4e24\u6b21 lab \u7684\u4ee3\u7801\u4ed3\u5e93\u4e0b\uff0c\u8fd9\u6837\u7684\u884c\u4e3a\u4f1a\u6709\u600e\u6837\u7684\u5dee\u8ddd\u3002</p>"},{"location":"lab/xv6lab-scheduling/","title":"CPU Scheduling","text":""},{"location":"lab/xv6lab-scheduling/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u638c\u63e1 xv6 \u8c03\u5ea6\u8fc7\u7a0b</li> <li>\u638c\u63e1 Round-Robin \u8c03\u5ea6\u7b97\u6cd5\u7684\u5177\u4f53\u5b9e\u73b0</li> </ol> <p>xv6-lab9 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab9</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab9 xv6lab9</code> \u4e0b\u8f7d xv6-lab9 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u5b83\u4f1a\u542f\u52a8\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b <code>init</code>\uff0c<code>init</code> \u4f1a\u542f\u52a8 Shell \u8fdb\u7a0b <code>sh</code>\u3002\u5728 <code>sh</code> \u4e2d\u8f93\u5165 schedtest \u8fd0\u884c\u7528\u6237\u7a0b\u5e8f\u89c2\u5bdf\u8fd0\u884c\u7ed3\u679c\u3002</p> <p>\u5728\u672c\u6b21\u7684\u5b9e\u9a8c\u60c5\u666f\u4e2d\uff0c\u6211\u4eec\u5c06\u542f\u7528\u65f6\u949f\u4e2d\u65ad\uff0c\u65f6\u949f\u4e2d\u65ad\u4f1a\u6309\u7167\u8bbe\u5b9a\u7684\u95f4\u9694\u65f6\u95f4\u89e6\u53d1\u65f6\u949f\u4e2d\u65ad\uff0c\u65f6\u949f\u4e2d\u65ad\u5904\u7406\u51fd\u6570\u5c06\u8c03\u5ea6\u5230\u4e0b\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\uff0c\u591a\u4e2a\u7528\u6237\u8fdb\u7a0b\u6309\u7167Round-Robin\u8f6e\u6d41\u8fd0\u884c\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u6bcf\u6b21\u6267\u884c\u4e00\u4e2a\u65f6\u95f4\u7247\u7684\u65f6\u95f4\uff0c\u76f4\u5230\u8fd0\u884c\u7ed3\u675f\u3002</p>"},{"location":"lab/xv6lab-scheduling/#_2","title":"\u65f6\u949f\u4e2d\u65ad","text":"<p>\u6211\u4eec\u5728 Week4 \u7684\u5b9e\u9a8c\u8bfe\u4e0a\u5df2\u7ecf\u4e86\u89e3\u8fc7\u4ec0\u4e48\u662f\u65f6\u949f\u4e2d\u65ad\u3002</p> <p>\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\uff0c\u6211\u4eec\u9700\u8981\u6bcf\u9694\u4e00\u5b9a\u65f6\u95f4\u5c31\u89e6\u53d1\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\uff0c\u4f46\u662f\u901a\u8fc7<code>sbi_set_timer()</code>\u63a5\u53e3\u6bcf\u6b21\u53ea\u80fd\u8bbe\u7f6e\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u3002\u6240\u4ee5\u6211\u4eec\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7b2c\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\uff0c\u5728\u6bcf\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u5904\u7406\u4e2d\uff0c\u8bbe\u7f6e\u4e0b\u4e00\u6b21\u7684\u65f6\u949f\u4e2d\u65ad\u3002</p> <p>\u65f6\u949f\u4e2d\u65ad\u7684\u51c6\u5907\u5de5\u4f5c\uff0c\u5305\u62ec\u65f6\u949f\u4e2d\u65ad\u7684\u521d\u59cb\u5316 <code>timer_init()</code> \uff0c\u548c\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\u7684\u8bbe\u7f6e <code>set_next_timer()</code> :</p> <pre><code>//os/timer.c\n\n/// Enable timer interrupt\nvoid timer_init() {\n    // Enable supervisor timer interrupt\n    w_sie(r_sie() | SIE_STIE);\n    set_next_timer();\n}\n\n// /// Set the next timer interrupt\nvoid set_next_timer() {\n    const uint64 timebase = CPU_FREQ / TICKS_PER_SEC;\n    if (on_vf2_board) {\n        set_timer(get_cycle() + timebase);\n    } else {\n        w_stimecmp(r_time() + timebase);\n    }\n}\n</code></pre> <p>\u64cd\u4f5c\u7cfb\u7edf\u542f\u52a8\u540e\uff0c\u4f1a\u8fdb\u884c\u8c03\u7528 <code>timer_init()</code> \u4f7f\u80fd\u65f6\u949f\u4e2d\u65ad\uff0c\u5e76\u8bbe\u7f6e\u7b2c\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\uff1a</p> <pre><code>//os/main.c\n\nstatic void bootcpu_init(){\n    //......\n\n    timer_init();\n\n    //......\n\n}\n</code></pre> <p>\u5728\u7528\u6237\u8fdb\u7a0b\u6267\u884c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e00\u65e6\u89e6\u53d1\u65f6\u949f\u4e2d\u65ad\uff0c\u4f1a\u8df3\u8f6c\u5230trap\u5904\u7406\u6d41\u7a0b\u7684 <code>usertrap()</code> \u8fdb\u884c\u65f6\u949f\u4e2d\u65ad\u7684\u5904\u7406\u3002</p> <p>\u5728\u65f6\u949f\u4e2d\u65ad\u5904\u7406\u65f6\uff0c\u8bbe\u7f6e\u4e0b\u4e00\u6b21\u65f6\u949f\u4e2d\u65ad\uff0c\u5e76\u4e14\u5c06which_dev\u8bbe\u4e3a1\uff0c1\u4ee3\u8868\u9700\u8981\u8fdb\u884c\u8c03\u5ea6\u3002\u4e4b\u540e\u5728 trap \u5904\u7406\u51fd\u6570\u7684\u6700\u540e\u5224\u65adwhich_dev\u7684\u503c\uff0c\u5982\u679c\u4e3a1\uff0c\u5219\u8c03\u7528 <code>yield()</code> \u8ba9\u51fa cpu \u8d44\u6e90\uff0c\u8c03\u5ea6\u5230\u4e0b\u4e00\u4e2a\u8fdb\u7a0b\u3002</p> <pre><code>//os/trap.c\n\nvoid usertrap() {\n    //......\n\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        which_dev = handle_intr();\n    }\n    //......\n\n    // if it's a timer intr, call yield to give up CPU.\n    if (which_dev == 1)\n        yield();\n    //.......\n}\n\nstatic int handle_intr(void) {\n    uint64 cause = r_scause();\n    uint64 code  = cause &amp; SCAUSE_EXCEPTION_CODE_MASK;\n    if (code == SupervisorTimer) {\n        tracef(\"time interrupt!\");\n        if (cpuid() == 0) {\n            acquire(&amp;tickslock);\n            ticks++;\n            wakeup(&amp;ticks);\n            release(&amp;tickslock);\n        }\n        set_next_timer();//set next timer\n        return 1;\n    } else if (code == SupervisorExternal) {\n        tracef(\"s-external interrupt from usertrap!\");\n        plic_handle();\n        return 2;\n    } else {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"lab/xv6lab-scheduling/#-round-robin","title":"\u8c03\u5ea6\u7b97\u6cd5--Round Robin","text":"<p>\u5728 <code>sched.c</code> \u4e2d\uff0c\u6211\u4eec\u4f1a\u6709\u4e00\u4e2a\u961f\u5217 task_queue \u7ba1\u7406\u72b6\u6001\u662f <code>RUNNABLE</code> \u7684\u8fdb\u7a0b\uff0c\u8fd9\u4e2a\u94fe\u8868\u6211\u4eec\u79f0\u4e4b\u4e3a\u5c31\u7eea\u961f\u5217\u3002</p> <p>xv6\u4e2d\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u5728\u4ee5\u4e0b\u65f6\u523b\uff0c\u4f1a\u88ab\u8bbe\u7f6e\u6210Runnable\u5e76\u4e14\u88ab <code>add_task()</code> enqueue \u8fdb\u961f\u5c3e\u3002 - fork  - exec -&gt; load_init_app - wakeup - yield -&gt; sched -&gt; scheduler</p> <p>\u5f53shceduler\u901a\u8fc7 fetch_task \u5f97\u5230\u961f\u5934\u7684\u5c31\u7eea\u8fdb\u7a0b p \u540e\uff0c\u8fdb\u7a0b\u4f1a\u88ab\u79fb\u51fa\u5c31\u7eea\u961f\u5217\uff0c\u5e76\u4e14\u72b6\u6001\u6539\u4e3a <code>RUNNING</code> \u3002</p> <p>\u7531\u4e8e\u6211\u4eec\u6bcf\u6b21\u5c06\u8fdb\u7a0b\u52a0\u5165\u5c31\u7eea\u961f\u5217\u662f\u52a0\u5728\u961f\u5c3e\uff0c\u800c\u9009\u62e9\u4e0b\u4e00\u4e2a\u5c31\u7eea\u8fdb\u7a0b\u662f\u4ece\u961f\u5934\uff0c\u56e0\u6b64\u6211\u4eec\u5df2\u7ecf\u5b9e\u73b0\u4e86Round_Robin\u8c03\u5ea6\u7b97\u6cd5\u3002</p> <pre><code>//os/sched.c\nvoid scheduler() {\n    //.......\n\n    for (;;) {\n        // intr may be on here.\n\n        p = fetch_task();\n        //......\n\n        acquire(&amp;p-&gt;lock);\n        assert(p-&gt;state == RUNNABLE);\n        debugf(\"switch to proc %d(%d)\", p-&gt;index, p-&gt;pid);\n        p-&gt;state = RUNNING;\n        c-&gt;proc  = p;\n        swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context);\n\n        // When we get back here, someone must have called swtch(..., &amp;c-&gt;sched_context);\n        assert(c-&gt;proc == p);\n        assert(!intr_get());        // scheduler should never have intr_on()\n        assert(holding(&amp;p-&gt;lock));  // whoever switch to us must acquire p-&gt;lock\n        c-&gt;proc = NULL;\n\n        if (p-&gt;state == RUNNABLE) {\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n\nvoid sched() {\n    //......\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    //......\n}\n\n// Give up the CPU for one scheduling round.\nvoid yield() {\n    struct proc *p = curr_proc();\n    debugf(\"yield: (%d)%p\", p-&gt;pid, p);\n\n    // lab9 cpu scheduling:\n    infof(\"yield: %d\", p-&gt;pid);\n\n    acquire(&amp;p-&gt;lock);\n    p-&gt;state = RUNNABLE;\n    sched();\n    release(&amp;p-&gt;lock);\n}\n</code></pre> <p>Question</p> <p>\u7ed3\u5408\u672c\u5468\u4e0e Week 5 \u7684\u5b9e\u9a8c\u5185\u5bb9\uff0c\u603b\u7ed3\u65f6\u949f\u4e2d\u65ad\u89e6\u53d1\u65f6\u4ece\u4e00\u4e2a\u8fdb\u7a0b\u5207\u6362\u5230\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u90fd\u4f1a\u7ecf\u8fc7\u54ea\u4e9b\u8fdb\u7a0b\u7684\u54ea\u4e9b\u51fd\u6570\u3002</p>"},{"location":"lab/xv6lab-sync/","title":"\u4e92\u65a5\u4e0e\u540c\u6b65 Mutual Exclusion &amp; Synchronization","text":"<p>synclab &amp; xv6lab8 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab8</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab8 synclab</code> \u4e0b\u8f7d synclab \u4ee3\u7801\u3002</p> <p>\u8fdb\u5165 <code>sync-lab</code> \u6587\u4ef6\u5939\u4e2d\uff0c\u9605\u8bfb <code>README.md</code>\uff08\u5efa\u8bae\u8bfe\u540e\u9605\u8bfb\uff09 \u4ee5\u53ca\u6267\u884c\u91cc\u9762\u7684\u6837\u4f8b\u7a0b\u5e8f\u3002</p> <p>\u5bf9\u4e8e xv6 \u90e8\u5206\u7684\u4ee3\u7801\uff0c\u8bf7\u53c2\u7167\u4e3b\u4ed3\u5e93\uff0c\u4f7f\u7528 <code>git clone https://github.com/yuk1i/SUSTechOS xv6lab8</code> \u4e0b\u8f7d\u4ee3\u7801\u3002</p>"},{"location":"lab/xv6lab-sync/#_1","title":"\u591a\u5904\u7406\u5668\u7f16\u7a0b","text":"<p>Multiple Processes Programming \u591a\u5904\u7406\u5668\u7f16\u7a0b\uff0c\u4ece\u5165\u95e8\u5230\u653e\u5f03\u3002</p> <p>\u6211\u4eec\u5e38\u8bf4\uff1a\u8fdb\u7a0b\u6709\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u800c\u7ebf\u7a0b\u662f\u5171\u4eab\u5730\u5740\u7a7a\u95f4\u3002\u8fd9\u5f15\u5165\u4e86 \u5171\u4eab\u5185\u5b58 \u7684\u6982\u5ff5\uff1a\u5373\u4e00\u4e2a\u8fdb\u7a0b\u5185\u7684\u591a\u4e2a\u7ebf\u7a0b\uff0c\u4f1a\u5171\u4eab\u4e00\u90e8\u5206\u5185\u5b58\u7a7a\u95f4\u3002</p> <p>\u8fd9\u5c31\u4f1a\u5f15\u5165\u4e00\u4e2a\u95ee\u9898\uff1a\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u5728\u8bfb\u5199\u4e00\u4e2a\u5185\u5b58\u5730\u5740\u65f6\uff0c\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u4e5f\u5728\u8bfb\u5199\u540c\u4e00\u4e2a\u5185\u5b58\u5730\u5740\uff0c\u90a3\u8fd9\u65f6\u5019\u4f1a\u53d1\u751f\u4ec0\u4e48\uff1f</p>"},{"location":"lab/xv6lab-sync/#mutual-exclusion","title":"\u4e92\u65a5 Mutual Exclusion","text":"<p>\u51fd\u6570\u58f0\u660e</p> <p>\u6211\u4eec\u4f1a\u5728\u4e4b\u540e\u7684\u4ee3\u7801\u4e2d\u4f7f\u7528\u4e00\u4e9b\u7b80\u5316\u7684\u51fd\u6570\u6765\u8868\u793a\u7ebf\u7a0b\u521b\u5efa\u7b49\u6b65\u9aa4\uff1a</p> <ul> <li> <p><code>create(func)</code>: \u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5b83\u4ece\u7ed9\u5b9a\u7684\u51fd\u6570 <code>func</code> \u8d77\u5f00\u59cb\u8fd0\u884c\u3002</p> </li> <li> <p><code>join()</code>: \u7b49\u5f85\u6240\u6709\u7ebf\u7a0b\u9000\u51fa\u3002</p> </li> <li> <p><code>usleep()</code>: \u7b49\u5f85\u51e0\u4e2aus\u3002</p> </li> </ul> <p>\u5728 <code>synclab</code> \u4ee3\u7801\u5305\u4e2d\uff0c\u6709\u4e00\u4e2a\u6211\u4eec\u81ea\u5df1\u5199\u7684 <code>thread.h</code>\uff0c\u5b83\u662f\u4e00\u4e2a\u5bf9 pthread \u7684\u7b80\u5355\u5c01\u88c5\u3002</p> <p>\u5728\u7406\u89e3\u6211\u4eec\u4e3a\u4ec0\u4e48\u9700\u8981\u4e92\u65a5\u524d\uff0c\u6211\u4eec\u5148\u8981\u660e\u767d Data Race (\u6570\u636e\u7ade\u4e89) \u662f\u600e\u4e48\u56de\u4e8b\u3002</p>"},{"location":"lab/xv6lab-sync/#_2","title":"\u5c71\u5be8\u652f\u4ed8\u5b9d","text":"<p>code</p> <pre><code>// alipay.c\n\n#include \"thread.h\"\n\nunsigned long money = 30;\n\nvoid deduct() {\n    if (money &gt;= 1) {\n        usleep(1);\n        money -= 1;\n    }\n}\n\nint main() {\n    for (int i = 0; i &lt; 100; i++) create(deduct);\n    join();\n    printf(\"money = %lu\\n\", money);\n}\n</code></pre> <p>\u4f7f\u7528 <code>gcc -O2 alipay.c &amp;&amp; ./a.out</code> \u7f16\u8bd1\u5e76\u8fd0\u884c\uff0c\u4f53\u9a8c\u4e00\u628a\u4ebf\u4e07\u5bcc\u7fc1\u3002</p> <pre><code>$ gcc -O2 alipay.c &amp;&amp; ./a.out\nmoney = 18446744073709551547\n</code></pre> <p>\u5c71\u5be8\u652f\u4ed8\u5b9d\u4f1a\u521b\u5efa100\u4e2a\u7ebf\u7a0b\uff0c\u6bcf\u4e2a\u7ebf\u7a0b\u90fd\u68c0\u67e5\u94b1\u5305\u4e2d\u662f\u5426\u6709\u94b1\uff0c\u5982\u679c\u6709\u90a3\u5c31\u6263\u6b3e\uff08\u5c40\u90e8\u5e8f\uff09\u3002<code>usleep</code> \u7528\u4e8e\u5f3a\u5236\u89e6\u53d1\u4e00\u6bb5\u65f6\u95f4\u7684\u7b49\u5f85\u3002</p> <p>\u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u94b1\u5305 <code>money</code> \u5373\u662f\u5171\u4eab\u8d44\u6e90\u3002\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c<code>money</code> \u7a81\u7136\u53d8\u6210\u4e86\u4e00\u4e2a\u5f88\u5927\u7684\u503c\uff0c\u8fd9\u662f\u56e0\u4e3a\u6211\u4eec\u5bf9 <code>unsigned long</code> \u8fdb\u884c\u51cf\u6cd5\u5bfc\u81f4\u4e86\u6ea2\u51fa\u3002\u6211\u4eec\u8003\u8651\u5982\u4e0b\u8fd0\u884c\u56fe\uff0c\u5bf9\u6240\u6709\u767d\u8272\u65b9\u5757\u5f3a\u5236\u6392\u5e8f\uff08\u5168\u5c40\u5e8f\uff09\uff1a</p> <p></p> <p>\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u94b1\u5305\u91cc\u53ea\u5269\u4e0b1\u5143\u65f6\uff0c\u4e24\u4e2a\u7ebf\u7a0b\u90fd\u68c0\u67e5\u5230\u4e86\u94b1\u5305\u4f59\u989d\u4e3a1\u5143\uff0c\u6240\u4ee5\u5b83\u4eec\u4fe9\u90fd\u8fdb\u884c\u4e86\u6263\u6b3e\uff0c\u7136\u540e\u5c31\u5bfc\u81f4\u4e86\u6ea2\u51fa\u3002</p> <p>\u6570\u5b66\u6a21\u578b\u4e0b\u7684\u591a\u7ebf\u7a0b</p> <p>\u5c06 <code>money &gt;= 1 ?</code> \u548c <code>money--</code> \u4e24\u6b65\u9aa4\u79f0\u4e3a A \u4e0e B\u3002A\u6c38\u8fdc\u5728B\u4e4b\u524d\u6267\u884c\uff0c\u6211\u4eec\u5199\u4f5c <code>A &gt; B</code> \uff08 <code>A</code> happens-before <code>B</code> \uff09\u3002</p> <p>\u6211\u4eec\u53d1\u73b0\uff0c\u591a\u7ebf\u7a0b\u7684\u8fd0\u884c\u6b65\u9aa4\uff08\u5168\u5c40\u5e8f\uff09\u662f\u6bcf\u4e2a\u7ebf\u7a0b\u7684\u8fd0\u884c\u6b65\u9aa4\uff08\u5c40\u90e8\u5e8f\uff09\u7684\u4e00\u4e2a\u6392\u5217 (Permutation)\u3002</p> <p>\u5168\u5c40\u5e8f\u662f\u56db\u4e2a\u6b65\u9aa4 <code>{A1, B1, A2, B2}</code> \u8fdb\u884c\u6392\u5217\uff0c\u5176\u4e2d\u6ee1\u8db3\u5c40\u90e8\u5e8f <code>A1 &gt; B1</code> \u548c <code>A2 &gt; B2</code> \u7684\u6392\u5217\u5747\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u5168\u5c40\u5e8f\u3002 \u4f8b\u5982\uff0c<code>(A1, B1, A2, B2)</code>, <code>(A2, B2, A1, B1)</code>, <code>(A1, A2, B1, B2)</code> \u5747\u662f\u5408\u6cd5\u7684\u5168\u5c40\u5e8f\uff0c\u800c\u540e\u8005\u5373\u662f bug \u7684\u6839\u6e90\u3002</p> <p>\u5982\u679c\u4f60\u611f\u5174\u8da3\uff0c\u4f60\u53ef\u4ee5\u8bd5\u7740\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\uff1a\u6211\u4eec\u53ef\u4ee5\u4ece\u6570\u5b66\u4e0a\u9a8c\u8bc1\u4e00\u4e2a\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u7684\u6b63\u786e\u6027\uff0c\u5373\u679a\u4e3e\u6240\u6709\u5168\u5c40\u5e8f\uff0c\u9a8c\u8bc1\u5b83\u4eec\u90fd\u4e0d\u4f1a\u9020\u6210 bug\u3002\u4ece\u8ba1\u7b97\u590d\u6742\u6027\u7406\u8bba (Computational complexity theory) \u7684\u89d2\u5ea6\u800c\u8a00\uff0c\u89e3\u8fd9\u4e2a\u95ee\u9898\u662f P \u95ee\u9898\u3001NP \u95ee\u9898\u3001\u8fd8\u662f NP\u5b8c\u5168\u95ee\u9898\u3002</p> <p>\u5982\u679c\u6211\u4eec\u4e0d\u5728 <code>if (money &gt;= 0)</code> \u540e\u9762\u52a0\u4e0a <code>usleep</code>\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u7a0b\u5e8f\u7684\u8fd0\u884c\u7ed3\u679c \u5927\u6982\u7387 \u662f\u6b63\u786e\u7684\u3002\u8fd9\u662f\u56e0\u4e3a\u68c0\u67e5\u548c\u6263\u6b3e\u7684\u6307\u4ee4\u5e8f\u5217\u592a\u77ed\u4e86\uff0c\u4ee5\u81f3\u4e8e\u6211\u4eec\u4e0d\u592a\u53ef\u80fd\u4f1a\u9020\u6210 data race\u3002\u4f46\u662f\uff0c\u4e0d\u592a\u53ef\u80fd != \u7edd\u5bf9\u4e0d\u4f1a\u3002\u5728\u8003\u8651\u5e76\u53d1\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u9700\u8981\u7684\u662f\u6b63\u786e\u6027\u3002</p> <p>\u6570\u5b66\u6a21\u578b\u4e2d\uff0c<code>(A1, A2, B1, B2)</code> \u8868\u793a\u7ebf\u7a0b1\u548c\u7ebf\u7a0b2\u90fd\u8bc6\u522b\u5230\u4e86 <code>money == 1</code>\uff0c\u5e76\u4e14\u90fd\u5c06\u6267\u884c <code>money--</code>\u3002\u6240\u4ee5\uff0c\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u7684\u65b9\u5f0f\u5c31\u662f\uff1a\u4e0d\u8981\u8ba9 <code>(A, B)</code> \u53d8\u5f97\u53ef\u5206\u5272\u3002\u6211\u4eec\u53ef\u4ee5\u4ece\u591a\u4e2a\u89c6\u89d2\u6765\u7406\u89e3\uff1a</p> <ol> <li> <p>\u6211\u4eec\u4e0d\u518d\u5141\u8bb8 <code>(A1, B1)</code>, <code>(A2, B2)</code> \u4ea4\u9519\uff0c\u5373\u6211\u4eec\u5c06 <code>(A1, A2, B1, B2)</code> \u8fd9\u79cd\u60c5\u51b5\u6392\u9664\u51fa\u201c\u5408\u6cd5\u7684\u5168\u5c40\u5e8f\u201d\u4e2d\u3002</p> </li> <li> <p>\u6211\u4eec\u53ef\u4ee5\u5c06 <code>(A, B)</code> \u6253\u5305 \u4e00\u4e2a\u4e0d\u53ef\u4e2d\u65ad\u7684\u6574\u4f53\u3002\u5373\uff0c\u5728\u5176\u4ed6CPU\u7684\u89c6\u89d2\u4e0b\uff0c\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u662f\u5728\u4e00\u77ac\u95f4\u5c31\u53d1\u751f\u5b8c\u4e86\u7684\uff08\u5373\u539f\u5b50\u7684 (Atomic)\uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5176\u4ed6CPU\u4e0d\u53ef\u80fd\u770b\u5230\u8fd9\u4e2a\u6574\u4f53\u7684\u4e2d\u95f4\u72b6\u6001\u3002</p> </li> <li> <p>\u6ce8\u610f\u5230\u7b2c\u4e8c\u79cd\u63cf\u8ff0\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f Critical Section\u3002</p> </li> </ol> <p>Takeaway Message</p> <p>\u4eba\u662f\u4e00\u79cd\u5355\u7ebf\u7a0b\u751f\u7269\u3002\u5728\u591a\u5904\u7406\u5668\u7f16\u7a0b\u7684\u6a21\u578b\u4e0b\uff0c\u5355\u7ebf\u7a0b\u601d\u7ef4\u4e0d\u518d\u4e00\u5b9a\u6b63\u786e\u4e86\uff0c\u5171\u4eab\u53d8\u91cf\u6709\u53ef\u80fd\u5728\u4efb\u4f55\u65f6\u523b\u88ab\u522b\u4eba\u66f4\u6539\u3002</p>"},{"location":"lab/xv6lab-sync/#_3","title":"\u5355\u6838\u5904\u7406\u5668","text":"<p>\u5982\u679c\u4f60\u6210\u529f\u7406\u89e3\u4e86\u4e0a\u8ff0\u7684\u4e09\u4e2a\u89c6\u89d2\uff0c\u5728\u5355 CPU \u4e0b\uff0c\u89e3\u51b3\u65b9\u6848\u53d8\u5f97\u975e\u5e38\u660e\u6717\uff1a\u6211\u4eec\u4e0d\u5141\u8bb8\u5728 <code>(A, B)</code> \u4e2d\u95f4\u4ea7\u751f Context Switch\u3002\u8fd9\u5373\u662f\u6211\u4eec\u6240\u5b66\u4e60\u7684\u7b2c\u4e00\u79cd\u5b9e\u73b0\u4e92\u65a5\u7684\u65b9\u5f0f\uff1a\u5173\u4e2d\u65ad\u3002\u8fd9\u4e5f\u662f\u5185\u6838\u5b9e\u73b0 \"\u4e0d\u53ef\u4e2d\u65ad\u7684\u6574\u4f53\" \u7684\u65b9\u5f0f\u3002</p> <p>\u4f46\u662f\uff0c\u9700\u8981\u6ce8\u610f\u5230\u5173\u4e2d\u65ad\u4e0d\u662f\u4e07\u80fd\u7684\u3002\u7528\u6237\u6a21\u5f0f\u5173\u4e0d\u4e86\u4e2d\u65ad\u3002\uff08\u56de\u5fc6\uff1a\u5141\u8bb8 Interrupt \u7684\u6761\u4ef6\uff09</p>"},{"location":"lab/xv6lab-sync/#compare-and-swap","title":"\u539f\u5b50 Compare-And-Swap \u6307\u4ee4","text":"<p>\u5bf9\u4e8e\u5c71\u5be8\u652f\u4ed8\u5b9d\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u53e6\u4e00\u4e2a\u89d2\u5ea6\u7406\u89e3\u4e3a\u4ec0\u4e48\u4f1a\u51fa\u95ee\u9898\uff1a\u5f53\u7ebf\u7a0b2\u68c0\u67e5\u5b8c <code>money</code>\uff0c\u5728\u8fdb\u884c <code>money--</code> \u524d\uff0c<code>money</code>\u7684\u503c\u5df2\u7ecf\u88ab\u7ebf\u7a0b1\u6539\u4e86\uff1b\u8fd9\u65f6\uff0c\u7ebf\u7a0b2\u8fdb\u884c <code>money--</code> \u7684\u6761\u4ef6\u5c31\u4e0d\u518d\u6ee1\u8db3\u4e86\uff01</p> <p>\u6211\u4eec\u53ef\u4ee5\u5bf9\u6b64\u8fdb\u884c\u8fdb\u4e00\u6b65\u62bd\u8c61\uff1a\u8981\u4fee\u6539\u67d0\u4e2a\u53d8\u91cf\uff08\u5185\u5b58\u5730\u5740\uff09\u7684\u503c\u65f6\uff0c\u8be5\u53d8\u91cf\u7684\u503c\u5df2\u7ecf\u4e0d\u662f\u539f\u6765\u7684\u503c\u4e86\u3002</p> <p>\u5e78\u8fd0\u7684\u662f\uff0c\u73b0\u4ee3 CPU \u57fa\u672c\u90fd\u5177\u6709\u4e00\u79cd\u7279\u6b8a\u7684\u6307\u4ee4\uff1a\u5f53\u4fee\u6539\u67d0\u4e2a\u5730\u5740\u7684\u503c\u65f6\uff0c\u68c0\u67e5\u8be5\u5730\u5740\u7684\u503c\u662f\u5426\u4e3a\u7ed9\u5b9a\u7684\u539f\u6765\u7684\u503c\u3002\u8fd9\u79cd\u6307\u4ee4\u88ab\u79f0\u4e3a Compare-And-Swap \u6307\u4ee4\u3002\u7edd\u5927\u591a\u6570\u60c5\u51b5\uff0c\u8fd9\u79cd\u6307\u4ee4\u4f1a\u88ab\u4ee5 \u539f\u5b50\u7684 \u65b9\u5f0f\u6267\u884c\uff1b\u5373\uff0c\u5728\u5176\u4ed6 CPU \u7684\u773c\u91cc\uff0c\u8be5\u6307\u4ee4\u662f \u4e00\u77ac\u95f4 \u5c31\u5b8c\u6210\u7684\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u628a <code>deduct</code> \u51fd\u6570\u6539\u6210\u4e0b\u9762\u8fd9\u6837\uff0c\u5b83\u663e\u8457\u5730\u533a\u5206\u4e86\u5171\u4eab\u53d8\u91cf <code>money</code> \u548c\u5b83\u7684\u5c40\u90e8\u526f\u672c <code>local_money</code>\u3002\u6bcf\u5f53\u60f3\u4fee\u6539 <code>money</code> \u7684\u503c\u65f6\uff0c\u6211\u4eec\u4f7f\u7528 <code>__sync_bool_compare_and_swap(&amp;money, local_money, local_money - 1)</code> \u6765\u4fee\u6539 <code>&amp;money</code> \u8fd9\u4e2a\u5185\u5b58\u5730\u5740\u7684\u503c\uff0c\u5e76\u4e14\u671f\u671b\u5b83\u73b0\u5728\u7684\u503c\u548c\u539f\u6765\u6211\u4eec\u8bfb\u5230\u7684\u503c ( <code>local_money</code> ) \u4e00\u81f4\uff1a\u5982\u679c\u4e00\u81f4\uff0c\u5219\u5c06 <code>&amp;money</code> \u4fee\u6539\u4e3a\u65b0\u503c\uff08 <code>local_money-1</code> \uff09\uff0c\u5e76\u8fd4\u56detrue; \u5982\u679c\u4e0d\u4e00\u81f4\uff0c\u5219\u8bf4\u660e\u6709\u5176\u4ed6 CPU \u5bf9\u8be5\u5185\u5b58\u8fdb\u884c\u4e86\u66f4\u65b0\uff0c\u4e0d\u66f4\u65b0\u503c\uff0c\u5e76\u8fd4\u56defalse\u3002\u8be5\u51fd\u6570\u4f1a\u751f\u6210\u4e00\u6761\u539f\u5b50\u6307\u4ee4 <code>lock cmpxchg</code> \u3002\u5728 RISC-V \u5e73\u53f0\u4e0a\uff0c\u8fd9\u4f1a\u662f\u4e00\u6761 <code>amoswap</code> \u6307\u4ee4\u3002</p> <pre><code>// code: alipay2.c\n\n// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval). \n//   -&gt; return true if the comparison is successful and newval is written.\nunsigned long money = 30;\n\nvoid deduct() {\n    long local_money;\n    do {\n        local_money = money;\n        if (local_money == 0)\n            break;\n        usleep(1);\n    } while(!__sync_bool_compare_and_swap(&amp;money, local_money, local_money - 1));\n    // will be compiled to: \n    // 124e:       f0 48 0f b1 15 f1 2d     lock cmpxchg QWORD PTR [rip+0x2df1],rdx\n}\n</code></pre> <p>gcc \u4e0b\u6240\u6709 __sync_ \u5f00\u5934\u7684\u5185\u7f6e\u539f\u5b50\u6307\u4ee4\u5c01\u88c5\uff1ahttps://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fsync-Builtins.html</p>"},{"location":"lab/xv6lab-sync/#lock-primitive","title":"\u9501\u539f\u8bed Lock Primitive","text":"<p>\u5c3d\u7ba1\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 __sync \u7b49\u539f\u5b50\u6307\u4ee4\u6765\u89e3\u51b3\u5c71\u5be8\u652f\u4ed8\u5b9d\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u4ecd\u9700\u8981\u4e00\u79cd\u901a\u7528\u7684\u3001\u5b9e\u73b0\u4e92\u65a5\u7684\u529e\u6cd5\u3002</p> <p>\u56de\u987e Mutual Exclusion \u7684\u6700\u57fa\u672c\u8981\u6c42\uff1a\u540c\u4e00\u65f6\u523b\uff0c\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u80fd\u591f\u6267\u884c\u3002\u6211\u4eec\u5b9a\u4e49\u4e00\u5957\u539f\u8bed\uff1a<code>lock</code>/<code>unlock</code> \uff08\u4e5f\u53ef\u4ee5\u5199\u4f5c <code>acquire</code>/<code>release</code> \uff09\uff1a</p> <ol> <li> <p>\u6240\u6709\u671f\u671b\u5b9e\u73b0 Mutual Exclusion \u7684\u7ebf\u7a0b\u90fd\u9700\u8981\u8c03\u7528 <code>lock</code> \u65b9\u6cd5\u3002\u5728\u540c\u4e00\u65f6\u523b\uff0c\u53ea\u80fd\u6709\u4e00\u4e2a\u7ebf\u7a0b\u5c06\u4ece <code>lock</code> \u65b9\u6cd5\u4e2d\u8fd4\u56de\u3002</p> </li> <li> <p>\u5f53\u67d0\u7ebf\u7a0b\u6210\u529f\u4ece <code>lock</code> \u65b9\u6cd5\u4e2d\u8fd4\u56de\u540e\uff0c\u5728\u8be5\u7ebf\u7a0b\u8c03\u7528 <code>unlock</code> \u524d\uff0c\u5176\u4ed6\u6240\u6709\u7ebf\u7a0b\u4e0d\u5f97\u4ece <code>lock</code> \u4e2d\u8fd4\u56de\u3002</p> </li> </ol> <p>\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff1a\u4ece <code>lock</code> \u8fd4\u56de\u540e\uff0c\u5373\u662f Critical Section \u7684\u5f00\u59cb\uff0c<code>unlock</code> \u5373\u662f Critical Section \u7684\u7ed3\u675f\u3002</p>"},{"location":"lab/xv6lab-sync/#_4","title":"\u9501\u7684\u5b9e\u73b0","text":"<p>\u6211\u4eec\u53ef\u4ee5\u60f3\u5f53\u7136\u5730\u5199\u51fa\u4ee5\u4e0b\u4ee3\u7801\uff0c<code>status</code> \u662f\u4e00\u4e2a\u5171\u4eab\u53d8\u91cf\uff0c\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u8c03\u7528 <code>lock</code> \u65b9\u6cd5\uff0c\u5c1d\u8bd5\u628a <code>status</code> \u6539\u4e3a <code>LOCKED</code>\u3002\u6700\u7ec8\uff0c\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u6210\u529f\u6267\u884c\u5230 <code>status = LOCKED</code> \u5904\uff0c\u5176\u4ed6\u7ebf\u7a0b\u90fd\u5728 <code>retry</code> \u4e2d\u6253\u8f6c\u3002</p> <pre><code>int status = UNLOCKED;\n\nvoid lock() {\nretry:\n    if (status != UNLOCKED) {\n        goto retry;\n    }\n    status = LOCKED;\n}\n\nvoid unlock() {\n    status = UNLOCKED;\n}\n</code></pre> <p>\u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u6309\u7167\u4e0a\u8ff0\u5c71\u5be8\u652f\u4ed8\u5b9d\u4f8b\u5b50\u8fdb\u884c\u5206\u6790\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u53d1\u73b0\u4e00\u5904 data race\uff1a\u5f53\u67d0\u4e2a\u7ebf\u7a0b\u901a\u8fc7\u4e86 <code>if (status != UNLOCKED)</code> \u68c0\u67e5\u540e\uff0c\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u4e86 <code>status = LOCKED</code> \u5904\uff0c\u8fd9\u7834\u574f\u4e86\u8be5\u7ebf\u7a0b\u4e0a\u9501\u7684\u6761\u4ef6\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u5e94\u8be5\u4f7f\u7528\u4e00\u4e2a\u539f\u5b50\u6307\u4ee4\u6765\u66ff\u4ee3 Compare and Set \u8fd9\u4e00\u6b65\uff1a\u6bcf\u4e2a\u7ebf\u7a0b\u90fd\u5c1d\u8bd5\u539f\u5b50\u5730\u5c06 <code>status</code> \u4ece <code>UNLOCKED</code> \u6539\u4e3a <code>LOCKED</code>\uff0cCPU\u7684\u5b9e\u73b0\u4fdd\u8bc1\u4e86\u53ea\u6709\u4e00\u4e2a CPU \u80fd\u6210\u529f\u3002\u5bf9\u4e8e\u90a3\u4e9b\u6ca1\u6709\u6210\u529f\u7684 CPU\uff0c\u5b83\u4eec\u4f1a\u5728\u8fd9\u4e2a while \u5faa\u73af\u4e0a\u4e00\u76f4\u7b49\u5f85\u3002</p> <pre><code>void lock() {\n    while(!__sync_bool_compare_and_swap(&amp;status, UNLOCKED, LOCKED));\n}\n</code></pre> <p>\u5982\u679c\u6ca1\u6709\u539f\u5b50\u6307\u4ee4</p> <p>\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48 Peterson \u7b97\u6cd5\u770b\u8d77\u6765\u6bd4\u8f83\u590d\u6742\u3002\u5728\u7b2c\u4e00\u4e2a\u6b63\u786e\u7684\u4e92\u65a5\u7b97\u6cd5(Dekker's Alg) \u88ab\u53d1\u660e\u7684\u5e74\u4ee3 (1960s)\uff0cCPU \u8fd8\u6ca1\u6709\u539f\u5b50\u6307\u4ee4\u3002</p>"},{"location":"lab/xv6lab-sync/#spinlock-sleeplock","title":"spinlock &amp; sleeplock","text":"<p>\u5728\u4e0a\u9762\u7684\u7ae0\u8282\uff0c\u6211\u4eec\u53ea\u5b9a\u4e49\u4e86\u9501\u7684\u4e00\u4e2a\u57fa\u672c\u5c5e\u6027\uff1a\u5b9e\u73b0\u4e92\u65a5\u3002\u9501\u8fd8\u6709\u4e00\u4e2a\u5c5e\u6027\uff1a\u5982\u679c\u4e00\u4e2a\u7ebf\u7a0b\u62a2\u4e0d\u5230\u9501\uff0c\u90a3\u5b83\u5e94\u8be5\u600e\u4e48\u529e\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u5c06\u9501\u5206\u4e3a\u4e24\u7c7b\uff1a\u81ea\u65cb\u9501 (<code>spinlock</code>) \u548c\u7761\u7720\u9501 (<code>sleeplock</code>)\u3002</p> <p><code>spinlock</code> \u4f1a\u5728\u62a2\u4e0d\u5230\u9501\u7684\u65f6\u5019\u4e00\u76f4\u5c1d\u8bd5\u62a2\uff0c\u5373\u4e0a\u8ff0 <code>lock</code> \u65b9\u6cd5\uff0c\u5b83\u4f1a\u5728 <code>__sync_bool_compare_and_swap</code> \u5931\u8d25\u65f6\u4e00\u76f4\u6267\u884c\uff0cCPU \u5c31\u4f1a\u5728\u8fd9\u4e00\u6761\u6307\u4ee4\u4e0a\u6253\u8f6c\uff0c\u5c31\u597d\u50cf\u81ea\u65cb\u4e00\u6837\u3002\u8fd9\u79cd\u9501\u9002\u7528\u4e8e Critical Section \u8f83\u77ed\u3001\u80fd\u5728\u56fa\u5b9a\u65f6\u95f4\u5185\u6267\u884c\u5b8c\u6bd5\u7684\u60c5\u51b5\u3002</p> <p><code>sleeplock</code> \u4f1a\u5728\u62a2\u4e0d\u5230\u9501\u65f6\u5c06\u8be5\u7ebf\u7a0b\u7f6e\u4e8e\u7761\u7720\u72b6\u6001 <code>SLEEPING</code>\uff0c\u5e76\u653e\u5f03 CPU \u5207\u6362\u5230 <code>scheduler</code>\u3002\u7b49\u5230\u539f\u6765\u6301\u6709\u9501\u7684\u7ebf\u7a0b\u91ca\u653e\u9501\u65f6\uff0c\u5b83\u9700\u8981\u8d1f\u8d23\u5524\u9192\u7b49\u5f85\u8005\u3002\u8fd9\u79cd\u9501\u9002\u7528\u4e8e Critical Section \u8f83\u957f\u3001\u6709\u7740\u4e0d\u786e\u5b9a\u65f6\u95f4\u7684\u60c5\u51b5\uff0c\u4f8b\u5982\u7b49\u5f85 I/O\u3002</p> <p>\u5728 \u5524\u9192\u7b49\u5f85\u8005 \u8fd9\u4ef6\u4e8b\u60c5\u4e0a\uff0c<code>sleeplock</code> \u53ef\u4ee5\u7528\u4e0d\u540c\u7684\u5b9e\u73b0\u65b9\u5f0f\uff1a</p> <ol> <li> <p>\u76f4\u63a5\u5524\u9192\u6240\u6709\u7684\u7b49\u5f85\u8005\uff0c\u53ea\u6709\u62a2\u5230\u9501\u7684\u7ebf\u7a0b\u80fd\u7ee7\u7eed\u6267\u884c\u4e0b\u53bb\uff0c\u6ca1\u62a2\u5230\u9501\u7684\u91cd\u65b0\u8fdb\u5165\u7761\u7720\u3002</p> </li> <li> <p>\u53ea\u5524\u9192\u4e00\u4e2a\u7b49\u5f85\u8005\uff0c\u5176\u4f59\u7684\u4fdd\u6301\u7761\u7720\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-sync/#xv6-spinlock","title":"xv6 spinlock","text":"<p>xv6 \u4e2d\uff0c\u4e00\u4e2a <code>spinlock_t</code> \u7ed3\u6784\u4f53\u5305\u542b\u6700\u6838\u5fc3\u7684\u4e00\u4e2a <code>locked</code> \u6807\u5fd7\uff0c\u548c\u5176\u4ed6\u7528\u4e8e\u8c03\u8bd5\u7684\u5b57\u6bb5\u3002</p> <p><code>acquire</code> \u4e00\u4e2a <code>spinlock_t</code> \u4f1a\u4f7f\u7528 <code>__sync_lock_test_and_set</code>\uff08\u539f\u5b50\u6307\u4ee4 <code>amoswap</code>\uff09 \u5c1d\u8bd5\u5c06 1 \u5199\u5165 <code>locked</code>\uff0c\u5e76\u8fd4\u56de\u4e4b\u524d <code>locked</code> \u7684\u503c\u3002\u5982\u679c\u8fd4\u56de\u503c\u4e3a0\uff0c\u5219\u8868\u793a\u8be5 CPU \u662f\u552f\u4e00\u4e00\u4e2a\u5b8c\u6210\u4e86\u5c06 <code>locked: 0-&gt;1</code> \u7684 CPU\uff0c\u5373\u62a2\u5230\u9501\u4e86\u3002</p> <p><code>release</code> \u5219\u539f\u5b50\u5730\u5c06 0 \u5199\u5165 <code>locked</code>\u3002</p> <pre><code>// Mutual exclusion lock.\nstruct spinlock {\n    uint64 locked;  // Is the lock held?, use AMO instructions to access this field.\n\n    // For debugging:\n    char *name;       // Name of lock.\n    struct cpu *cpu;  // The cpu holding the lock.\n    void *where;      // who calls acquire?\n};\n\n// Acquire the lock.\n// Loops (spins) until the lock is acquired.\nvoid acquire(spinlock_t *lk)\n{\n    uint64 ra = r_ra();\n    push_off();         // disable interrupts to avoid deadlock.\n    if (holding(lk))    // check against reentrance\n        panic(\"already acquired by %p, now %p\", lk-&gt;where, ra);\n\n    // On RISC-V, sync_lock_test_and_set turns into an atomic swap:\n    //   a5 = 1\n    //   s1 = &amp;lk-&gt;locked\n    //   amoswap.d.aq a5, a5, (s1)\n    while (__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)\n        ;\n\n    __sync_synchronize();\n\n    // Record info about lock acquisition for holding() and debugging.\n    lk-&gt;cpu = mycpu();\n    lk-&gt;where = (void *)ra;\n}\n\n// Release the lock.\nvoid release(spinlock_t *lk)\n{\n    if (!holding(lk))\n        panic(\"release\");\n\n    lk-&gt;cpu = 0;\n    lk-&gt;where = 0;\n\n    __sync_synchronize();\n\n    // Release the lock, equivalent to lk-&gt;locked = 0.\n    // On RISC-V, sync_lock_release turns into an atomic swap:\n    //   s1 = &amp;lk-&gt;locked\n    //   amoswap.w zero, zero, (s1)\n    __sync_lock_release(&amp;lk-&gt;locked);\n\n    pop_off();\n}\n\n// Check whether this cpu is holding the lock.\n// Interrupts must be off.\nint holding(spinlock_t *lk)\n{\n    int r;\n    r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());\n    return r;\n}\n</code></pre> <p>__sync_synchronize() &amp; Memory Ordering</p> <p>\u6211\u4eec\u5728\u8bb2\u89e3\u4e2d\u523b\u610f\u5ffd\u7565\u4e86 <code>__sync_synchronize()</code> \u7684\u7ec6\u8282\u3002\u8be5\u51fd\u6570\u4e0e CPU \u7684 Memory Ordering (\u5185\u5b58\u5e8f) \u6709\u5173\uff0c\u5176\u539f\u7406\u548c\u7ec6\u8282\u5df2\u7ecf\u8d85\u51fa\u4e86\u672c\u79d1\u64cd\u4f5c\u7cfb\u7edf\u8bfe\u7a0b\u7684\u8303\u7574\u3002</p> <p>\u7b80\u800c\u8a00\u4e4b\uff0c\u6838\u5fc3\u5bf9\u5185\u5b58\u7684\u5199\u5165\uff0c\u4f1a\u6700\u7ec8 (eventually) \u5bf9\u5176\u4ed6\u6838\u5fc3\u53ef\u89c1\u3002Relaxed Memory Order (RISC-V, ARM) \u6ca1\u6709\u4fdd\u8bc1\uff1a\u67d0\u6838\u5fc3\u524d\u540e\u4e24\u4e2a Store \u5728\u88ab\u5176\u4ed6\u6838\u5fc3 Load \u65f6\uff0c\u89c2\u6d4b\u5230\u7684\u503c\u4e00\u5b9a\u662f Store \u5728\u4ee3\u7801\u4e2d\u7684\u987a\u5e8f\u3002 \u800c x86 (IA-32, amd64) \u5e73\u53f0\u4e3a Total Store Order\uff0c\u6838\u5fc3 Store \u7684\u987a\u5e8f\u5728\u5176\u4ed6\u6838\u5fc3\u7684\u89c6\u89d2\u4e0b\u4e00\u5b9a\u4e3a Store \u5728\u4ee3\u7801\u4e2d\u7684\u987a\u5e8f\u3002\u8fd9\u4e5f\u662f Windows on ARM \u96be\u4ee5\u6a21\u62df x86 \u8f6f\u4ef6\u7684\u539f\u56e0\u3002</p> <p>\u518d\u7b80\u800c\u8a00\u4e4b\uff0c\u5176\u4ed6\u6838\u5fc3\u4f1a\u5148\u89c2\u6d4b\u5230\u9501\u88ab\u91ca\u653e\uff0c\u7136\u540e\u89c2\u6d4b\u5230\u7406\u5e94\u5728 Critical Section \u4e2d\u88ab\u8986\u76d6\u7684\u65e7\u503c\u3002</p> <p>\u5982\u679c\u4f60\u5bf9\u6b64\u611f\u5174\u8da3\uff0c\u63a8\u8350\u9605\u8bfb\u4ee5\u4e0b\u6750\u6599\uff1a</p> <ol> <li> <p>https://jyywiki.cn/OS/2025/lect13.md (13.4 \u653e\u5f03 (3)\uff1a\u5168\u5c40\u7684\u6307\u4ee4\u6267\u884c\u987a\u5e8f)</p> </li> <li> <p>riscv-spec-v2.1.pdf, Section 6.1, Specifying Ordering of Atomic Instructions</p> </li> <li> <p>https://blog.cyyself.name/memory-ordering/</p> </li> <li> <p>https://people.mpi-sws.org/~viktor/papers/asplos2023-atomig.pdf</p> </li> </ol>"},{"location":"lab/xv6lab-sync/#_5","title":"\u5173\u4e2d\u65ad","text":"<p>\u6211\u4eec\u4f7f\u7528 <code>push_off()</code> \u548c <code>pop_off()</code> \u8868\u793a\u4e00\u5bf9 \u5173\u4e2d\u65ad/\u5f00\u4e2d\u65ad\u7684\u64cd\u4f5c\u3002\u5177\u4f53\u7ec6\u8282\u8bf7\u53c2\u7167 Context Switch \u4e00\u7ae0\u3002</p>"},{"location":"lab/xv6lab-sync/#_6","title":"\u9501\u7684\u68c0\u67e5","text":"<p>\u5982\u679c\u6211\u4eec\u5728\u5df2\u7ecf\u6301\u6709\u4e00\u628a\u9501\u7684\u60c5\u51b5\u4e0b\uff0c\u518d\u5c1d\u8bd5\u5bf9\u8fd9\u628a\u9501\u4e0a\u9501\u4f1a\u600e\u4e48\u6837\uff1f\u6211\u4eec\u4f1a\u6c38\u8fdc\u5361\u5728\u4e0a\u9501\u7684 spin loop \u4e2d\u3002 \u4ee5\u53ca\uff0c\u5728\u4e00\u4e2a\u8fdb\u7a0b\u6301\u6709\u4e00\u628a\u9501\u5e76\u9677\u5165\u7761\u7720\u65f6\uff0c\u5176\u4ed6\u8fdb\u7a0b\u5c1d\u8bd5\u4e0a\u9501\u4e5f\u4f1a\u6c38\u8fdc\u5361\u6b7b\u3002</p> <p>\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u5728 <code>sched()</code> \u4e2d\u68c0\u67e5\u4e86\u5f53\u524d CPU \u6301\u6709\u4e86\u591a\u5c11\u628a\u81ea\u65cb\u9501\u3002</p> <pre><code>void sched() {\n    // ...\n\n    if (mycpu()-&gt;noff != 1)\n        panic(\"holding another locks\");\n\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    // ...\n}\n</code></pre> <p>\u5bf9\u4e8e Kernel Trap\uff0c\u6211\u4eec\u4e0d\u5e0c\u671b\u51fa\u73b0\u5d4c\u5957\u4e2d\u65ad\u3002 \u6211\u4eec\u4f1a\u5728 <code>kernel_trap</code> \u4e2d\u68c0\u67e5 Trap \u6df1\u5ea6\uff0c\u5982\u679c\u9047\u5230\u4e86\u5d4c\u5957\u4e2d\u65ad\uff0c\u5219panic\u62a5\u9519\u3002</p> <pre><code>void kernel_trap(struct ktrapframe *ktf) {\n    mycpu()-&gt;inkernel_trap++;\n\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        if (mycpu()-&gt;inkernel_trap &gt; 1) {\n            // should never have nested interrupt\n            print_sysregs(true);\n            print_ktrapframe(ktf);\n            panic(\"nested kerneltrap\");\n        }\n    }\n}\n</code></pre> <p>\u6211\u4eec\u9700\u8981\u786e\u4fdd\u5728 <code>kernel_trap</code> \u4e0b\u4e2d\u65ad\u4e00\u76f4\u4e3a\u5173\u7684\u3002\u6240\u4ee5\uff0c\u5f53\u6211\u4eec\u5c1d\u8bd5\u5728 Kernel Trap \u4e0a\u4e0b\u6587\u4e2d\u901a\u8fc7\u91ca\u653e\u9501\u6253\u5f00\u4e2d\u65ad\uff0c\u5185\u6838\u4e5f\u4f1a\u62a5\u9519\uff1a</p> <pre><code>void pop_off(void) {\n    struct cpu* c = mycpu();\n    c-&gt;noff -= 1;\n    if (c-&gt;noff == 0 &amp;&amp; c-&gt;interrupt_on) {\n        if (c-&gt;inkernel_trap)\n            panic(\"pop_off-&gt;intr_on happens in kernel trap\");\n\n        // we will enable the interrupt, must not happen in kernel trap context.\n        intr_on();\n    }\n}\n</code></pre>"},{"location":"lab/xv6lab-sync/#_7","title":"\u4e92\u65a5\u4e0e\u540c\u6b65","text":"<p>\u4e92\u65a5 (Mutual Exclusion) \u662f\u6307 \u5728\u540c\u4e00\u65f6\u523b\uff0c\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b \u80fd\u591f\u6267\u884c\u3002</p> <p>\u540c\u6b65 (Synchronization) \u662f\u6307\u591a\u4e2a\u7ebf\u7a0b\u4e4b\u95f4\u7684\u4e8b\u4ef6 \u6309\u67d0\u79cd\u987a\u5e8f\u6267\u884c \uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a <code>happens-before</code>\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u7528\u73b0\u5b9e\u7684\u4f8b\u5b50\u6765\u63cf\u8ff0\u8fd9\u4e24\u4ef6\u4e8b\u60c5\u3002</p> <ol> <li> <p>\u8003\u8651\u6709\u4e00\u4e2a\u5395\u6240\u5355\u95f4\uff0c\u6709\u8bb8\u591a\u4eba\u9700\u8981\u4e0a\u5395\u6240\u3002\u4f46\u662f\uff0c\u5728\u540c\u4e00\u65f6\u523b\uff0c\u53ea\u6709\u4e00\u4e2a\u4eba\u80fd\u5446\u5728\u8fd9\u4e2a\u5395\u6240\u5355\u95f4\u91cc\u9762\u3002</p> <p>\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u201c\u5395\u6240\u201d \u5373\u662f\u5171\u4eab\u8d44\u6e90\u3002</p> </li> <li> <p>\u8003\u8651\u4e00\u4e2a\u5341\u5b57\u8def\u53e3\u7684\u7ea2\u7eff\u706f\uff1a\u6bcf\u4e2a\u65b9\u5411\u4e0a\uff0c\u6709\u673a\u52a8\u8f66\u9053\u7684\u7ea2\u7eff\u706f\uff1b\u4e0e\u4e4b\u5782\u76f4\u7684\uff0c\u6709\u4eba\u884c\u6591\u9a6c\u7ebf\u7684\u7ea2\u7eff\u706f\u3002\u6211\u4eec\u8981\u6c42\uff0c\u5728\u673a\u52a8\u8f66\u9053\u4eae\u7eff\u706f\u524d\uff0c\u4e0e\u4e4b\u5782\u76f4\u7684\u6591\u9a6c\u7ebf\u4e00\u5b9a\u5df2\u7ecf\u4eae\u7ea2\u706f\u3002</p> <p>\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u6211\u4eec\u5b9a\u4e49\u4e86 <code>\u6591\u9a6c\u7ebf\u4eae\u7eff\u706f</code> happens-before <code>\u673a\u52a8\u8f66\u9053\u4eae\u7ea2\u706f</code>\u3002</p> </li> </ol> <p>\u6211\u4eec\u9700\u8981\u6ce8\u610f\u5230\uff0c\u4e92\u65a5\u5e76\u4e0d\u4e00\u5b9a\u4ee3\u8868\u7740\u540c\u6b65\uff1a\u4f8b\u5982 A\u3001B\u3001C \u4e09\u4e2a\u4e8b\u4ef6\u4e92\u65a5\uff0c\u8fd9\u8868\u793a\u5b83\u4eec\u4e0d\u80fd\u540c\u65f6\u6267\u884c\uff1b\u4f46\u8fd9\u5e76\u4e0d\u4ee3\u8868\u7740\u5b83\u4eec\u6267\u884c\u7684\u987a\u5e8f\u4e00\u5b9a\u662f A &gt; B &gt; C\u3002</p>"},{"location":"lab/xv6lab-sync/#synchronization","title":"\u540c\u6b65 Synchronization","text":"<p>\u540c\u6b65 \u8868\u793a\u6211\u4eec\u5e0c\u671b\u63a7\u5236\u4e8b\u4ef6\u53d1\u751f\u7684\u5148\u540e\u987a\u5e8f\uff1aA &gt; B &gt; C\uff0c\u5f62\u6210\u53d7\u6211\u4eec\u63a7\u5236\u7684 \"happens-before\" \u5173\u7cfb\u3002</p>"},{"location":"lab/xv6lab-sync/#_8","title":"\u7406\u89e3\u540c\u6b65","text":"<p>\u540c\u6b65\u901a\u5e38\u7528 \u7b49\u5f85 \u6765\u63cf\u8ff0\u3002</p> <p>\u4f8b\u5982\uff0c\u4e09\u4e2a\u4eba\u4e00\u8d77\u7ea6\u996d\uff0c\u4ed6\u4eec\u5148\u7ea6\u5b9a\u5728\u4e00\u53f7\u95e8\u96c6\u5408\uff0c\u518d\u4e00\u8d77\u524d\u5f80\u5b9d\u80fd\u57ce\u3002\u5728\u8fd9\u6837\u7684\u8868\u8ff0\u4e2d\uff0c\u4e09\u4eba\u5c31 \"\u5728\u4e00\u53f7\u95e8\u96c6\u5408\" \u8fd9\u4ef6\u4e8b\u60c5\u4e0a\u5b8c\u6210\u4e86\u540c\u6b65\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u4eba\u800c\u8a00\uff0c\u5b83\u9700\u8981\u7b49\u5f85\u53e6\u5916\u4e24\u4e2a\u4eba\u5230\u6765\uff0c\u624d\u6267\u884c\u4e0b\u4e00\u4e2a\u64cd\u4f5c\uff1a\u524d\u5f80\u5b9d\u80fd\u57ce\u3002</p> <p>\u4e8b\u4ef6\u5373\u662f\u4ee3\u7801\u7684\u6267\u884c\uff0c\u800c\u987a\u5e8f\u5219\u662f\u6bcf\u6761\u4ee3\u7801\u4e4b\u95f4\u7684 \"happens-before\" \u5173\u7cfb\u3002</p> <ul> <li>\u5728\u5355\u7ebf\u7a0b\u7a0b\u5e8f\u4e2d\uff0c\u4ee3\u7801\u662f\u5929\u7136\u5730\u6309\u7167\u987a\u5e8f \"happens-before\"\u3002</li> <li>\u5728\u591a\u7ebf\u7a0b\u7a0b\u5e8f\u4e2d\uff0c\u540c\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\u7684\u4e8b\u4ef6\uff08\u4ee3\u7801\u7684\u6267\u884c\uff09\u4ecd\u7136\u4fdd\u6301\u7740\u5b83\u4eec\u7684 \"happens-before\" \u5173\u7cfb\uff1b\u800c\u4e0d\u540c\u7ebf\u7a0b\u4e4b\u95f4\u7684\u4e8b\u4ef6\uff08\u4ee3\u7801\u7684\u6267\u884c\uff09\u5219\u6ca1\u6709\u4efb\u4f55\u7ea6\u675f\u3002</li> </ul> <p>\u540c\u6b65\u5219\u662f\u8ba9\u4e0d\u540c\u7ebf\u7a0b\u4e4b\u95f4\uff0c\u5728\u67d0\u4e2a\u4e8b\u4ef6\uff08\u4ee3\u7801\u7684\u6267\u884c\uff09\u70b9\u4e0a\uff0c\u91cd\u65b0\u6784\u5efa \"happens-before\" \u5173\u7cfb\u3002</p> <p></p> <p>\u6211\u4eec\u4f9d\u7136\u7528 <code>A &gt; B</code> \u8868\u793a <code>A happens-before B</code>\u3002\u6211\u4eec\u53ef\u4ee5\u5206\u522b\u5217\u51fa T1 \u548c T2 \u7684\u5185\u90e8\u7684 \"happens-before\" \u5173\u7cfb\uff1a</p> <ul> <li> <p>T1: <code>A &gt; B</code>, <code>B &gt; sync</code>, <code>sync &gt; C</code>, <code>C &gt; D</code></p> </li> <li> <p>T2: <code>E &gt; F</code>, <code>F &gt; sync</code>, <code>sync &gt; G</code>, <code>G &gt; H</code></p> </li> </ul> <p>\u5047\u8bbe T1 \u548c T2 \u5728 <code>sync</code> \u8fd9\u4e2a\u4e8b\u4ef6\u4e0a\u90fd\u4f1a\u7b49\u5f85\u5bf9\u65b9\u6267\u884c\u5230\u8fd9\u91cc\u518d\u7ee7\u7eed\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bf4 T1 \u548c T2 \u5b8c\u6210\u4e86\u4e00\u6b21\u540c\u6b65\uff0c\u6211\u4eec\u5b9e\u73b0\u4e86\u4e0d\u540c\u7ebf\u7a0b\u4e4b\u95f4\u7684 \"happens-before\" \u5173\u7cfb\uff1a <code>B &gt; sync &gt; G</code>, <code>F &gt; sync &gt; C</code>\u3002</p>"},{"location":"lab/xv6lab-sync/#_9","title":"\u6761\u4ef6\u53d8\u91cf","text":"<p>\u5047\u8bbe\u6211\u4eec\u6709\u4e09\u4e2a\u7ebf\u7a0b\uff0c\u5b83\u4eec\u5404\u81ea\u6b7b\u5faa\u73af\u5730\u6267\u884c A\u3001B\u3001C \u4e09\u4e2a\u51fd\u6570\uff0c\u6211\u4eec\u671f\u671b\u8fd9\u4e09\u4e2a\u51fd\u6570\u603b\u662f\u4ee5 <code>A -&gt; B -&gt; C -&gt; A</code> \u7684\u987a\u5e8f\u88ab\u8fd0\u884c\uff1a</p> <p></p> <p>\u8003\u8651 T2\uff0c\u5b83\u4ec0\u4e48\u65f6\u5019\u80fd\u6267\u884c <code>B</code> \uff1f\u6211\u4eec\u8981\u6c42 <code>A</code> happens-before <code>B</code>\uff1a\u53ea\u6709 <code>A</code> \u4e8b\u4ef6\u53d1\u751f\u540e\uff0c<code>B</code> \u624d\u80fd\u5f97\u5230\u6267\u884c\u3002</p> <p>\u6211\u4eec\u975e\u5e38\u987a\u5229\u5730\u5199\u51fa\u4e86 <code>B</code> \u80fd\u591f\u6267\u884c\u7684\u6761\u4ef6\u3002\u6211\u4eec\u56e0\u6b64\u4e5f\u5c06\u540c\u6b65\u95ee\u9898\u8f6c\u6362\u6210\u4e86\uff1a\u68c0\u67e5\u6761\u4ef6\u662f\u5426\u6ee1\u8db3\u3002</p> <pre><code>int last = 'C';\n\nvoid T1() {\n    while (1) {\n        while (last != 'C');    // wait for last == 'C'\n        A();\n        last = 'A';\n    }\n}\n\nvoid T2() {\n    while (1) {\n        while (last != 'A');    // wait for last == 'A'\n        B();\n        last = 'B';\n    }\n}\n\nvoid T3() {\n    while (1) {\n        while (last != 'B');    // wait for last == 'B'\n        C();\n        last = 'C';\n    }\n}\n</code></pre> <p>\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u8003\u8651\u4e24\u4e2a\u95ee\u9898\uff1a\u5982\u4f55\u6b63\u786e\u8bbe\u7f6e Critical Section\uff0c\u4ee5\u53ca\u5728\u7b49\u5f85\u6761\u4ef6\u65f6\u5e94\u8be5\u5e72\u4ec0\u4e48\u3002</p> <p><code>last</code> \u72b6\u6001\u53d8\u91cf\u663e\u7136\u662f\u4e00\u4e2a\u5171\u4eab\u53d8\u91cf\uff0c\u5b83\u4f1a\u88ab\u4e09\u4e2a\u7ebf\u7a0b\u5206\u522b\u8bfb\u5199\u3002\u6240\u4ee5\uff0c\u5bf9\u5b83\u7684\u8bbf\u95ee\u9700\u8981\u52a0\u9501\u4fdd\u62a4\u3002</p> <pre><code>mutex_t mtx;\nint last = 'C';\n\nvoid T1() {\n    while (1) {\n        lock(&amp;mtx);\n        while (last != 'C');    // wait for last == 'C'\n        A();\n        last = 'A';\n        unlock(&amp;mtx);\n    }\n}\n</code></pre> <p>\u800c\u5728 <code>while</code> \u7b49\u5f85\u5faa\u73af\u4e2d\uff0c\u6211\u4eec \u4e0d\u80fd\u4e00\u76f4\u6301\u6709\u4e92\u65a5\u9501 mtx \uff0c\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u5176\u4ed6\u7ebf\u7a0b\u6765\u66f4\u6539 <code>last</code> \u72b6\u6001\u53d8\u91cf\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u5728\u5224\u65ad\u6761\u4ef6\u540e\uff0c\u5982\u679c\u53d1\u73b0\u6761\u4ef6\u4e0d\u6ee1\u8db3\uff0c\u5219\u91ca\u653e\u9501\u5e76\u5c06\u81ea\u5df1\u9677\u5165\u7761\u7720\uff0c\u5e76\u5728\u81ea\u5df1\u88ab\u5524\u9192\u540e\u91cd\u65b0\u4e0a\u9501\u3002 \u56e0\u6b64\uff0c\u5728\u4fee\u6539\u6761\u4ef6\u540e\uff0c\u6211\u4eec\u9700\u8981\u5524\u9192\u6240\u6709\u4eba\u6765\u518d\u6b21\u68c0\u67e5\u6761\u4ef6\u3002</p> <p>\u8fd9\u6837\u7684\u8bbe\u8ba1\u6ee1\u8db3\u4e86\u4e24\u4e2a\u8981\u6c42\uff1a</p> <ol> <li>\u68c0\u67e5\u540c\u6b65\u6761\u4ef6 <code>last</code> \u65f6\uff0c\u5f53\u524d\u7ebf\u7a0b\u6301\u6709\u9501\u3002</li> <li>\u540c\u6b65\u6761\u4ef6\u68c0\u67e5\u901a\u8fc7\u540e\uff0c\u5f53\u524d\u7ebf\u7a0b\u6301\u6709\u9501\uff08\u5373\u6267\u884c <code>A</code> \u7684\u90e8\u5206\uff09\u3002</li> </ol> <pre><code>mutex_t mtx;\nint last = 'C';\n\nvoid T1() {\n    while (1) {\n        lock(&amp;mtx);\n        while (last != 'C') {\n            unlock(&amp;mtx);\n            sleep(myself);\n            lock(&amp;mtx);\n        }\n        A();\n        last = 'A';\n        unlock(&amp;mtx);\n        wakeup(all);\n    }\n}\n</code></pre> <p>\u4f46\u662f\uff0c\u8fd9\u91cc\u9762\u5b58\u5728\u4e00\u70b9\u95ee\u9898\uff0c\u8003\u8651\u5982\u4e0b\u7684\u6267\u884c\u56fe\uff0c\u9ec4\u8272\u90e8\u5206\u4e3a Critical Section\uff0c\u5b83\u4eec\u7684\u6267\u884c\u662f\u4e0d\u53ef\u4e0e\u5176\u4ed6\u7ebf\u7a0b\u7684 Critical Section \u91cd\u53e0\u7684\u3002</p> <p></p> <p>\u5728\u67d0\u79cd\u60c5\u51b5\u4e0b\uff0cT1 <code>unlock</code> \u540e\u5e76\u6ca1\u6709\u7acb\u5373\u9677\u5165 <code>sleep</code>\uff0c\u53cd\u800c T2 \u5728 <code>lock</code> \u5f97\u5230\u9501\u540e\u5148\u4e00\u6b65\u8c03\u7528\u4e86 <code>wakeup</code>\uff0c\u800c\u6b64\u65f6 T1 \u8fd8\u6ca1\u6709\u9677\u5165\u7761\u7720\uff0c\u81ea\u7136\u4e5f\u4e0d\u4f1a\u88ab\u5524\u9192\u3002\u800c\u5728 T1 \u7761\u7720\u540e\uff0c\u518d\u4e5f\u6ca1\u6709\u7ebf\u7a0b\u80fd\u591f\u5524\u9192\u5b83\u4e86\uff0c\u81f3\u6b64\uff0c\u6240\u6709\u7684\u7ebf\u7a0b\u90fd\u8fdb\u5165\u4e86\u7761\u7720\u6a21\u5f0f\u3002</p> <p>\u6211\u4eec\u5c06\u8fd9\u79cd\u95ee\u9898\u79f0\u4e3a \"The Lost Wake-Up Problem\".</p> <p>\u8fd9\u79cd\u95ee\u9898\u7684\u6839\u672c\u539f\u56e0\u662f\uff1a\u6211\u4eec\u5728\u6807\u8bb0\u81ea\u5df1\u4e3a SLEEPING \u524d\uff0c\u5c31\u5c06 <code>mtx</code> \u89e3\u9501\u4e86\u3002\u4f46\u662f\u6211\u4eec\u53c8\u4e0d\u80fd\u5148 <code>sleep()</code> \u518d <code>unlock()</code>\uff0c\u56e0\u4e3a <code>sleep</code> \u4e0d\u4f1a\u5728\u88ab\u5524\u9192\u524d\u8fd4\u56de\uff0c\u5373 <code>unlock()</code> \u6c38\u8fdc\u4e0d\u4f1a\u88ab\u6267\u884c\u5230\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u5c06 \"\u6807\u8bb0\u81ea\u5df1\u4e3a SLEEPING\" \u548c \"\u89e3\u9501 mtx\" \u4e24\u4ef6\u4e8b\u60c5\u89c6\u4e3a\u4e00\u4e2a\u6574\u4f53\uff0c\u5373\u5c06 \"\u6807\u8bb0\u81ea\u5df1\u4e3a SLEEPING\" \u7eb3\u5165 Critical Section\u3002</p> <p>\u81f3\u6b64\uff0c\u6211\u4eec\u5e94\u8be5\u5c31\u80fd\u7406\u89e3\u4e3a\u4ec0\u4e48 xv6 \u4e2d\u7684 <code>sleep</code> \u65b9\u6cd5\uff0c\u53c2\u6570\u4e2d\u5305\u542b\u4e00\u4e2a <code>spinlock_t*</code> \u4e86\u3002</p> <p>\u6ce8\uff1a\u5728 xv6 \u4e2d\uff0c\u8bbf\u95ee <code>p-&gt;state</code> \u5fc5\u987b\u8981\u6301\u6709 <code>p-&gt;lock</code>\uff0c\u6240\u4ee5 \"\u6807\u8bb0\u81ea\u5df1\u4e3a SLEEPING\"\uff08\u6216\u8005\u8bf4\uff0c\u522b\u4eba\u53d1\u73b0\u6211\u662f SLEEPING\uff09 \u548c <code>acquire(&amp;p-&gt;lock)</code> \u662f\u7b49\u4ef7\u7684\u3002</p> <pre><code>void sleep(void *chan, spinlock_t *lk) {\n    struct proc *p = curr_proc();\n\n    // Must acquire p-&gt;lock in order to\n    // change p-&gt;state and then call sched.\n    // Once we hold p-&gt;lock, we can be\n    // guaranteed that we won't miss any wakeup\n    // (wakeup locks p-&gt;lock),\n    // so it's okay to release lk.\n\n    acquire(&amp;p-&gt;lock);  // DOC: sleeplock1\n    release(lk);\n\n    // Go to sleep.\n    p-&gt;sleep_chan = chan;\n    p-&gt;state      = SLEEPING;\n\n    sched();\n\n    // p get waking up, Tidy up.\n    p-&gt;sleep_chan = 0;\n\n    // Reacquire original lock.\n    release(&amp;p-&gt;lock);\n    acquire(lk);\n}\n</code></pre> <p></p> <p>\u4e3a\u4ec0\u4e48\u4e0d\u7528\u539f\u5b50\u6307\u4ee4\u66ff\u4ee3\u6761\u4ef6\u68c0\u67e5</p> <p>\u56e0\u4e3a\u771f\u5b9e\u60c5\u51b5\u4e0b\u7684\u6761\u4ef6\u53ef\u80fd\u6ca1\u6709\u7b80\u5355\u5230\u80fd\u4f7f\u7528\u4e00\u6761\u539f\u5b50\u6307\u4ee4\u8868\u793a\uff0c\u6211\u4eec\u8fd8\u662f\u5e0c\u671b\u4f7f\u7528\u4e92\u65a5\u9501\uff08\u66f4\u52a0\u901a\u7528\uff09\u6765\u4fdd\u62a4\u5bf9\u6761\u4ef6\u7684\u8bbf\u95ee\u3002</p>"},{"location":"lab/xv6lab-sync/#lab","title":"Lab \u7ec3\u4e60","text":"<ol> <li> <p>\u5047\u8bbe <code>sum</code> \u662f\u4e00\u4e2a\u5171\u4eab\u53d8\u91cf\uff0c\u6709\u4e09\u4e2a\u7ebf\u7a0b\u5e76\u53d1\u5730\u6267\u884c <code>T_sum</code> \u51fd\u6570\uff0c\u90a3\u4e48\u7b49\u4e09\u4e2a\u7ebf\u7a0b\u9000\u51fa\u540e\uff0c<code>sum</code> \u53ef\u80fd\u7684\u6700\u5c0f\u503c\u662f\u4ec0\u4e48\uff1f</p> <p>Hint: \u600e\u4e48\u8bc1\u660e\u67d0\u4e2a\u503c\u662f\u53ef\u80fd\u7684\u6700\u5c0f\u503c\uff1a1. \u6240\u6709\u6bd4\u5b83\u5c0f\u7684\u503c\u90fd\u4e0d\u53ef\u80fd\u30022. \u5b58\u5728\u67d0\u79cd\u5e76\u53d1\u987a\u5e8f\uff0c\u4f7f\u5f97\u4ea7\u751f\u8be5\u6700\u5c0f\u503c\u7684\u5e8f\u5217\u662f\u5408\u6cd5\u7684</p> <p>\u91c7\u7528\u6211\u4eec\u7684\u201c\u6570\u5b66\u6a21\u578b\u201d\uff1a\u6bcf\u4e2a\u7ebf\u7a0b\u67096\u4e2a\u90e8\u5206\uff1a(Load, Store, Load, Store, Load, Store)\uff0c\u6709\u4e09\u4e2a\u8fd9\u6837\u7684\u7ebf\u7a0b\uff0c\u5bf9\u5b83\u4eec\u8fdb\u884c\u6392\u5217\uff0c\u6700\u540e\u4e00\u6b21 Store \u5219\u4e3a\u4e09\u4e2a\u7ebf\u7a0b\u9000\u51fa\u540e <code>sum</code> \u7684\u503c\u3002</p> <pre><code>int sum = 0;\nvoid T_sum() {\n    for (int i = 0; i &lt; 3; i++) {\n        int t = load(sum);\n        t += 1;\n        store(sum, t);\n    }\n}\n\nint main() {\n    for (int i = 0; i &lt; 3; i++) create(T_sum);\n    join();\n    printf(\"sum = %d\\n\", sum);\n}\n</code></pre> </li> <li> <p>\u4f7f\u7528 gcc \u5185\u7f6e\u7684\u539f\u5b50 CAS \u51fd\u6570 <code>__sync_bool_compare_and_swap</code> \u6765\u89e3\u51b3\u591a\u7ebf\u7a0b\u81ea\u589e\u7684\u95ee\u9898\u3002</p> <pre><code>volatile int sum = 0;\n\nvoid T_sum() {\n    for(int i=0;i &lt; 10000; i++) {\n        // your code here: increase sum atomically.\n\n    }\n}\n\nint main() {\n    for (int i=0;i&lt;5;i++) create(T_sum);\n    join();\n    printf(\"sum = %d\\n\", sum);\n}\n</code></pre> <p>gcc \u7684\u6587\u6863\uff1ahttps://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fsync-Builtins.html</p> </li> <li> <p>\u5728 \"\u6761\u4ef6\u53d8\u91cf\" \u4e00\u7ae0\u7684\u672b\u5c3e\uff0cT2 \u7684 <code>wakeup</code> \u53ef\u4ee5\u79fb\u51fa <code>lk</code> \u7684 Critical Section \u5417\uff1f\u5373 T2 \u5148 <code>release(lk)</code> \u518d <code>wakeup()</code>\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-sync2/","title":"Week 12 - \u540c\u6b65 2 Synchronization 2","text":""},{"location":"lab/xv6lab-sync2/#synchronization-2","title":"Synchronization 2","text":""},{"location":"lab/xv6lab-sync2/#_1","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u638c\u63e1\u4fe1\u53f7\u91cf\u539f\u7406</li> <li>\u638c\u63e1\u751f\u4ea7\u8005\u6d88\u8d39\u6a21\u578b</li> </ol>"},{"location":"lab/xv6lab-sync2/#data-race","title":"Data Race","text":"<p>\u5728 Sychronization 1 \u7684\u8bfe\u7a0b\u5185\u5bb9\u4e2d\uff0c\u6211\u4eec\u6ca1\u6709\u7ed9\u6570\u636e\u7ade\u4e89\u4e00\u4e2a\u7cbe\u51c6\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u73b0\u5728\u8865\u4e0a\u5b83\uff1a</p> <p>Two (or more) memory operations conflict if they access the same location and at least one of them is a write operation.</p> <p>\u5982\u679c\u591a\u4e2a\u5185\u5b58\u8bbf\u95ee\u5728\u8bbf\u95ee\u540c\u4e00\u4e2a\u5730\u5740\u3001\u5e76\u4e14\u81f3\u5c11\u5176\u4e2d\u4e00\u4e2a\u4e3a\u5199\u8bbf\u95ee\uff0c\u6211\u4eec\u79f0\u8fd9\u79cd\u60c5\u51b5\u4e3a\u6570\u636e\u7ade\u4e89\u3002</p> <p>\u5982\u679c\u6211\u4eec\u4e0d\u8ba9\u5199\uff0c\u90a3\u662f\u4e0d\u662f\u53ef\u4ee5\u5e76\u53d1\u5730\u8bfb\uff1f</p> <p>\u8fd9\u5c31\u662f <code>rwlock</code> \u7684\u8bbe\u8ba1\u539f\u7406\uff0c\u6211\u4eec\u5c06\u5bf9\u5171\u4eab\u8d44\u6e90\uff08\u5185\u5b58\uff09\u7684\u8bbf\u95ee\u5206\u4e3a\u8bfb\u3001\u5199\u4e24\u79cd\u60c5\u51b5\u3002<code>lock</code> \u64cd\u4f5c\u5206\u4e3a <code>rdlock</code> \u548c <code>wrlock</code>\u3002</p> <p>\u5728\u540c\u4e00\u65f6\u523b\uff0c\u53ef\u5b58\u5728\u591a\u4e2a\u8bfb\u8005 (reader) \u5e76\u53d1\u5730\u8bfb\uff08\u540c\u65f6\u4ece <code>rdlock</code> \u8fd4\u56de\uff09\uff0c\u6216\u8005\u53ea\u80fd\u6709\u4e00\u4e2a\u5199\u8005 (writer)\u3002\u5355\u4e2a writer \u548c\u6240\u6709 reader \u4ee5\u53ca\u5176\u4ed6 writer \u4e92\u65a5\u3002</p> <p>\u5982\u679c\u6570\u636e\u7ade\u4e89\u6ca1\u6709\u526f\u4f5c\u7528 (side-effect)</p> <p>\u5047\u5982\u8bf4\uff0c\u6211\u4eec\u5141\u8bb8\u6570\u636e\u7ade\u4e89\u7684\u51fa\u73b0\uff0c\u4f46\u662f\u4fdd\u8bc1\u5b83\u4e0d\u5f15\u8d77bug\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u907f\u514d\u4f7f\u7528\u9501\u4e86\u3002</p> <p>RCU (Read-Copy-Update) \u662f\u4e00\u79cd\u540c\u6b65\u673a\u5236\uff0c\u7528\u4e8e\u5728\u7531\u6307\u9488\u94fe\u63a5\uff08\u5982\u94fe\u8868\uff09\u7684\u591a\u4e2a\u5bf9\u8c61\u4e2d\u907f\u514d\u4f7f\u7528\u9501\uff0c\u4ee5\u53ca\u964d\u4f4e\u8bfb\u8005\u7684\u5f00\u9500\u3002</p> <p>\u6307\u9488\u66f4\u65b0\u548c\u89e3\u5f15\u7528\u5b9e\u9645\u4e0a\u662f\u65e0\u9501\u7684\uff1b\u4f46\u662f\uff0c\u6240\u6709\u8bfb\u8005(reader)\u88ab\u4fdd\u8bc1\u770b\u5230\u7684\u90fd\u662f\u65e7\u6307\u9488\u6216\u65b0\u6307\u9488\uff0c\u4e0d\u4f1a\u51fa\u73b0\u8bfb\u5230\u4e00\u4e2a\u975e\u6cd5\u6307\u9488\u7684\u60c5\u51b5\uff1b\u800c\u66f4\u65b0\u8005(updater)\u5219\u53ef\u4ee5\u5728\u6240\u6709\u80fd\u770b\u5230\u65e7\u6307\u9488\u7684\u8bfb\u8005\u9000\u51fa\u540e\u91ca\u653e (reclaimer) \u65e7\u6307\u9488\u7684\u5bf9\u8c61\u3002</p> <p>In computer science, read-copy-update (RCU) is a synchronization mechanism that avoids the use of lock primitives while multiple threads concurrently read and update elements that are linked through pointers and that belong to shared data structures (e.g., linked lists, trees, hash tables).</p> <p>Whenever a thread is inserting or deleting elements of data structures in shared memory, all readers are guaranteed to see and traverse either the older or the new structure, therefore avoiding inconsistencies (e.g., dereferencing null pointers).</p> <p>See also: https://www.kernel.org/doc/html/next/RCU/whatisRCU.html</p>"},{"location":"lab/xv6lab-sync2/#semaphore","title":"Semaphore","text":"<p>\u4fe1\u53f7\u91cf\u662f\u4e00\u79cd \u5e26\u8ba1\u6570\u5668\u7684\u4e92\u65a5\u9501\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u7528 \u201c\u6709\u9650\u4e2a\u6570\u7684\u5171\u4eab\u8d44\u6e90\u201d \u6765\u7406\u89e3 Semaphore\u3002\u4f8b\u5982\u6e38\u6cf3\u9986\u7684\u50a8\u7269\u67dc\u3001\u6216\u8005\u505c\u8f66\u573a\u7684\u8f66\u4f4d\u3002</p> <p>\u6e38\u6cf3\u9986\u6709\u6709\u9650\u4e2a\u624b\u73af\uff0c\u5728\u8fdb\u5165\u6e38\u6cf3\u9986\u65f6\uff0c\u7ed9\u6bcf\u4e2a\u4eba\u53d1\u4e00\u4e2a\u624b\u73af\uff08\u6301\u6709 Semaphore\uff09\uff1b\u53ea\u6709\u6301\u6709\u624b\u73af\u7684\u4eba\u624d\u80fd\u8fdb\u5165\u6e38\u6cf3\u9986\uff08\u4e92\u65a5\uff09\uff1b\u5f53\u50a8\u7269\u67dc\u88ab\u5360\u6ee1\u65f6\uff0c\u6211\u4eec\u65e0\u6cd5\u7ed9\u65b0\u6765\u7684\u4eba\u53d1\u624b\u73af\u4e86\uff0c\u4e8e\u662f\u4ed6\u4eec\u53ea\u80fd\u7b49\u5f85\uff08\u7b49\u5f85\uff09\uff1b\u79bb\u5f00\u6e38\u6cf3\u9986\u7684\u4eba\u8981\u8fd8\u56de\u624b\u73af\uff08\u91ca\u653e\uff09\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e92\u65a5\u9501 mutex \u662f Semaphore \u4e2d N = 1 \u7684\u7279\u6b8a\u60c5\u51b5\u3002</p> <p>\u4fe1\u53f7\u91cf\u6709\u4e24\u79cd\u4e3b\u8981\u884c\u4e3a\uff1a\u8bf7\u6c42\u548c\u91ca\u653e\u3002\u5f53\u4fe1\u53f7\u91cf\u6709\u5269\u4f59\u65f6\uff0c\u5219\u8bf7\u6c42\u7684\u7ed3\u679c\u662f\u6301\u6709\u4fe1\u53f7\u91cf\u76f4\u5230\u91ca\u653e\uff1b\u5f53\u4fe1\u53f7\u91cf\u6ca1\u6709\u5269\u4f59\u65f6\uff0c\u5219\u8bf7\u6c42\u7684\u7ed3\u679c\u662f\u7b49\u5f85\uff0c\u76f4\u5230\u6709\u591a\u4f59\u7684\u4fe1\u53f7\u91cf\u91ca\u653e\u51fa\u6765\u5219\u53d8\u4e3a\u6301\u6709\u4fe1\u53f7\u91cf\u3002</p> <p>\u6211\u4eec\u5b9a\u4e49\u4e00\u5957\u539f\u8bed\uff1a<code>sem_acquire()</code>/<code>sem_release()</code>\uff08\u4e5f\u53ef\u4ee5\u5199\u4f5c <code>P()</code>/<code>V()</code>\u3001<code>wait()</code>/<code>post()</code>\u3001<code>decrease()</code>/<code>increase()</code>\uff09\uff1a</p> <ol> <li>Semaphore \u62e5\u6709\u4e00\u4e2a\u521d\u59cb\u503c\u3002</li> <li>\u5728 <code>acquire</code> \u65f6 Semaphore \u7684\u503c\u51cf 1\uff0c\u5728 <code>release</code> \u65f6 Semaphore \u7684\u503c\u52a0 1\u3002</li> <li>Semaphore \u7684\u503c\u6c38\u8fdc\u4e0d\u4f1a\u4f4e\u81f3 0 \u4ee5\u4e0b\u3002\u5982\u679c\u503c\u4e3a 0\uff0c<code>acquire</code> \u5c06\u4f1a\u963b\u585e(blocking)\u5e76\u7b49\u5f85\uff1b\u53e6\u4e00\u4e2a <code>release</code> \u4f1a\u5524\u9192\u5b83\u5e76\u4f7f\u5b83\u5c1d\u8bd5 <code>acquire</code>\u3002</li> </ol> <p>sem_wait()  decrements  (locks)  the semaphore pointed to by sem.  If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until it becomes possible to perform the decrement (i.e., the semaphore value rises above zero).</p> <p>sem_post()  increments  (unlocks)  the  semaphore  pointed  to  by sem.  If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. </p> <p>\u53e6\u4e00\u4e2a\u989d\u5916\u7684\u6027\u8d28\uff1a<code>acquire</code> (<code>wait</code>) \u53ef\u80fd\u4f1a\u5bfc\u81f4\u7b49\u5f85\uff08\u963b\u585e\uff09\uff0c\u800c <code>release</code> (<code>post</code>) \u6c38\u8fdc\u4e0d\u4f1a\u5bfc\u81f4\u7b49\u5f85\uff08\u963b\u585e\uff09\u3002</p> <p>\u6211\u4eec\u5c06\u5728\u6700\u540e\u4e00\u6b21\u4f5c\u4e1a\u4e2d\uff0c\u5728 xv6 \u4e0a\u5b9e\u73b0\u4fe1\u53f7\u91cf\uff0c\u5e76\u5b9e\u73b0\u54f2\u5b66\u5bb6\u5403\u996d\u95ee\u9898\u3002</p>"},{"location":"lab/xv6lab-sync2/#-","title":"\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b","text":"<p>Producer-Consumer \u6a21\u578b\u662f\u540c\u6b65\u95ee\u9898\u548c\u5e76\u53d1\u7f16\u7a0b\u4e2d\u975e\u5e38\u5e38\u89c1\u7684\u6a21\u578b\u3002</p> <p>\u751f\u4ea7\u8005\uff08Producer\uff09\u8d1f\u8d23\u4ea7\u751f\u6570\u636e\u6216\u4efb\u52a1\uff1b\u6d88\u8d39\u8005\uff08Consumer\uff09\u8d1f\u8d23\u5904\u7406\u3002\u4e8c\u8005\u901a\u8fc7\u7f13\u51b2\u533a\uff08Buffer\uff09\u6216\u961f\u5217\uff08Queue\uff09\u9694\u79bb\uff0c\u4e92\u4e0d\u963b\u585e\u3002 \u751f\u4ea7\u8005\u548c\u6d88\u8d39\u8005\u53ea\u9700\u8981\u5728\u201c\u8bbf\u95ee\u7f13\u51b2\u533a\u201d\u65f6\u8fdb\u884c\u4e92\u65a5\uff0c\u4fdd\u62a4\u7f13\u51b2\u533a\u7684\u5408\u6cd5\u6027\u5373\u53ef\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u6765 Producer \u548c Consumer \u7684\u540c\u6b65\u6761\u4ef6\uff1a</p> <ul> <li> <p>Producer (\u751f\u4ea7\u6570\u636e)\uff1a\u5982\u679c\u7f13\u51b2\u533a\u6709\u7a7a\u4f4d\uff0c\u653e\u5165\uff1b\u5426\u5219\u7b49\u5f85\uff08\u963b\u585e\uff09</p> </li> <li> <p>Consumer (\u6d88\u8d39\u6570\u636e)\uff1a\u5982\u679c\u7f13\u51b2\u533a\u6709\u6570\u636e\uff0c\u53d6\u8d70\uff1b\u5426\u5219\u7b49\u5f85\uff08\u963b\u585e\uff09</p> </li> </ul> <p>\u5728 Producer \u548c Comsumer \u4e4b\u95f4\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u4e00\u79cd\u540c\u6b65\uff1a\u540c\u4e00\u4e2a object \u7684\u751f\u4ea7\u5fc5\u987b happens-before \u6d88\u8d39\u3002</p> <p>\u901a\u5e38\u6765\u8bf4\uff0c\u7f13\u51b2\u533a\u4e00\u822c\u662f\u56fa\u5b9a\u5927\u5c0f\u7684\u6570\u7ec4\uff08\u4e00\u65e6\u521b\u5efa\u540e\u4e0d\u518d\u6269\u5bb9\uff09\uff0c\u4f8b\u5982 Ring Buffer\u3002</p>"},{"location":"lab/xv6lab-sync2/#_2","title":"\u6761\u4ef6\u53d8\u91cf","text":"<p>\u6709\u4e86\u540c\u6b65\u6761\u4ef6\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e0a\u6b21\u8bfe\u7a0b\u4e2d\u5b66\u4e60\u7684\u6761\u4ef6\u53d8\u91cf\u6765\u5b8c\u6210\u540c\u6b65\uff1a\u540c\u6b65\u7684\u5bf9\u8c61 (chan) \u4e3a <code>&amp;buf</code>\uff0c\u4fdd\u62a4\u5b83\u7684 spinlock \u4e3a <code>&amp;buf.lock</code>\uff1b\u6bcf\u5f53\u5f80 buffer \u4e2d\u653e\u7f6e/\u53d6\u8d70\u6570\u636e\u540e\uff0c\u6211\u4eec\u4f7f\u7528 <code>wakeup</code> \u901a\u77e5\u6240\u6709\u5728\u8be5\u5bf9\u8c61\u4e0a <code>sleep</code> \u7684\u7ebf\u7a0b\u3002</p> <pre><code>struct buffer {\n    spinlock_t lock;\n    // ...\n} buf;\n\nbool is_full(struct buffer* b);\nbool is_empty(struct buffer* b);\nvoid put_data(struct buffer* b, void* data);\nvoid* get_data(struct buffer* b);\n\nvoid produce(void* data) {\n    acquire(&amp;buf.lock);\n    while(is_full(&amp;buf))\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_full(&amp;buf));\n    put_data(&amp;buf, data);   // modify the buffer, guarded by buf.lock and cond: !full\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n}\n\nvoid* consume(void* data) {\n    acquire(&amp;buf.lock);\n    while(is_empty(&amp;buf))\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_empty(&amp;buf));\n    void* data = get_data(&amp;buf);    // modify the buffer, guarded by buf.lock and cond: !empty\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n\n    return data;\n}\n</code></pre> <p>\u5177\u4f53\u5b9e\u73b0\u53ef\u4ee5\u53c2\u7167 xv6lab10 \u4e2d\u7684 <code>sync_main.c</code> \u6587\u4ef6\u3002\u4f60\u53ef\u4ee5\u5c1d\u8bd5\u6ce8\u91ca\u6389 <code>producer</code> \u548c <code>consumer</code> \u4e2d\u7684\u6761\u4ef6\u68c0\u67e5\uff0c\u89c2\u5bdf\u662f\u5426\u80fd\u901a\u8fc7\u68c0\u67e5\u3002</p> <pre><code>        while (is_empty(&amp;buf)) sleep(&amp;buf, &amp;buf.lock);\n        assert(!is_empty(&amp;buf));\n</code></pre>"},{"location":"lab/xv6lab-sync2/#semaphore_1","title":"Semaphore","text":"<p>\u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528\u4fe1\u53f7\u91cf\u6765\u5b9e\u73b0\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\uff1a</p> <ol> <li> <p>Producer/Consumer \u5206\u522b\u9700\u8981\u5728\u4e24\u4e2a\u4e8b\u4ef6\u4e0a\u7b49\u5f85\uff1aBuffer \u4e3a\u7a7a\u6216\u8005\u4e3a\u6ee1\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u521b\u5efa\u4e24\u4e2a\u4fe1\u53f7\u91cf <code>avail</code> \u548c <code>empty</code>\uff0c\u8868\u793a\u5f53\u524d Buffer <code>\u6709\u591a\u5c11\u4e2a\u5143\u7d20</code> \u4ee5\u53ca <code>\u6709\u591a\u5c11\u4e2a\u7a7a\u4f4d</code>\uff0c\u5b83\u4eec\u7684\u521d\u59cb\u503c\u4e3a <code>0</code> \u548c <code>N</code>\u3002</p> </li> <li> <p>\u5728 <code>produce</code> \u4e2d <code>wait(empty)</code>\uff0c\u8fd9\u8868\u793a <code>\u6709\u591a\u5c11\u7a7a\u4f4d</code> --\uff0c\u5373\u6211\u4eec\u7b49\u5f85\u4e00\u4e2a\u7a7a\u4f4d\u3002\u62ff\u5230\u7a7a\u4f4d\u540e\uff0c<code>produce</code> \u53ef\u4ee5\u5411 Buffer \u4e2d\u6dfb\u52a0\u4e00\u4e2a\u5bf9\u8c61\uff1b\u7136\u540e <code>post(avail)</code>\uff0c \u8fd9\u8868\u793a <code>\u6709\u591a\u5c11\u5143\u7d20</code> ++\u3002</p> </li> <li> <p>\u76f8\u53cd\u7684\uff0c\u5728 <code>consome</code> \u4e2d <code>wait(avail)</code>\uff0c\u8fd9\u8868\u793a <code>\u6709\u591a\u5c11\u4e2a\u5143\u7d20</code> --\uff0c\u5373\u6211\u4eec\u7b49\u5f85\u4e00\u4e2a\u5143\u7d20\uff1b\u4ee5\u53ca <code>post(empty)</code> \u8fd9\u8868\u793a <code>\u6709\u591a\u5c11\u7a7a\u4f4d</code> ++\u3002</p> </li> <li> <p>\u6700\u540e\uff0c\u6211\u4eec\u5728\u8bbf\u95ee Buffer \u65f6\u9700\u8981\u4e92\u65a5\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e00\u4e2a <code>mutex</code> \u4fe1\u53f7\u91cf\uff0c\u5176\u521d\u59cb\u503c\u4e3a 1\u3002</p> </li> </ol> <pre><code>struct buffer {\n    sem_t mutex;\n    sem_t avail;\n    sem_t empty;\n    // ...\n} buf;\nvoid put_data(struct buffer* b, void* data);\nvoid* get_data(struct buffer* b);\n\nvoid produce(void* data) {\n    wait(&amp;buf.empty);   // empty space --\n\n    wait(&amp;buf.mutex);\n    put_data(&amp;buf, data);   // critical section for buf.\n    post(&amp;buf.mutex);\n\n    post(&amp;buf.avail);   // avail ++\n}\n\nvoid* consume(void* data) {\n    wait(&amp;buf.avail)    // avail --\n\n    wait(&amp;buf.mutex);\n    void* data = get_data(&amp;buf);    // critical section for buf.\n    post(&amp;buf.mutex);\n\n    post(&amp;buf.empty);   // empty space ++\n\n    return data;\n}\n</code></pre>"},{"location":"lab/xv6lab-sync2/#invariant","title":"\u4e0d\u53d8\u91cf Invariant","text":"<p>\u4ec0\u4e48\u662f\u4e0d\u53d8\u91cf Invariant\uff1a\u4e0d\u53d8\u91cf\uff08invariant\uff09\u662f\u5728\u7a0b\u5e8f\u6267\u884c\u7684 \u4efb\u4f55\u65f6\u523b\u90fd\u5fc5\u987b\u6210\u7acb\u7684\u65ad\u8a00(assert)\u3002</p> <p>\u6211\u4eec\u53ef\u80fd\u5728\u6570\u7406\u903b\u8f91\u8bfe\u7a0b\u4e0a\u5b66\u4e60\u8fc7 \u5faa\u73af\u4e0d\u53d8\u91cf (loop invariant) \u7684\u6982\u5ff5\uff0c\u5b83\u8868\u793a\u5728\u4e00\u4e2a\u5faa\u73af\u4e2d\u6c38\u8fdc\u6210\u7acb\u7684\u4e00\u4e2a\u6761\u4ef6\uff0c\u901a\u5e38\u53ef\u4ee5\u7528\u4e8e\u8bc1\u660e\u4e00\u4e2a\u5faa\u73af\u7684\u6027\u8d28\u3002</p> <p>\u5728\u5e76\u53d1\u7f16\u7a0b\u4e2d\uff0c\u67d0\u4e9b\u590d\u6742\u7684\u540c\u6b65\u95ee\u9898\u4e2d\u4f1a\u6d89\u53ca\u5230\u591a\u4e2a\u5171\u4eab\u53d8\u91cf\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u4e0d\u53d8\u91cf\u5c31\u662f\u51e0\u4e2a\u53d8\u91cf\u4e4b\u95f4\u7684\u903b\u8f91\u5173\u7cfb\u3002\u5047\u5982\u6211\u4eec\u4f7f\u7528\u4e24\u4e2a <code>int</code> \u7c7b\u578b\u7684\u53d8\u91cf <code>avail</code> \u548c <code>empty</code> \u8868\u793a\u4e00\u4e2a\u5b9a\u957f\u7684 Ring Buffer \u6709\u591a\u5c11\u4e2a\u5bf9\u8c61\u3001\u591a\u5c11\u4e2a\u7a7a\u4f59\u5bf9\u8c61\u3002\u90a3\u4e48\u5b83\u7684\u4e0d\u53d8\u91cf\u5c31\u662f <code>avail + empty == N</code>\u3002</p> <p>\u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec\u6709\u65f6\u5019\u9700\u8981\u6253\u7834\u4e0d\u53d8\u5f0f\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u4f7f\u7528 Critical Section \u5c06\u5176\u4fdd\u62a4\u8d77\u6765\uff0c\u4f7f\u5f97\u5176\u4ed6 CPU \u6c38\u8fdc\u4e0d\u80fd\u89c2\u6d4b\u5230\u8be5\u4e0d\u53d8\u5f0f\u88ab\u6253\u7834\u4e86\uff0c\u8fd9\u4e5f\u5373\u662f\u6211\u4eec\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\u63d0\u5230\u7684\uff1a</p> <p>\u6211\u4eec\u53ef\u4ee5\u5c06 <code>(A, B)</code> \u6253\u5305 \u4e00\u4e2a\u4e0d\u53ef\u4e2d\u65ad\u7684\u6574\u4f53\u3002\u5373\uff0c\u5728\u5176\u4ed6CPU\u7684\u89c6\u89d2\u4e0b\uff0c\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u662f\u5728\u4e00\u77ac\u95f4\u5c31\u53d1\u751f\u5b8c\u4e86\u7684\uff08\u5373\u539f\u5b50\u7684 (Atomic)\uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5176\u4ed6CPU\u4e0d\u53ef\u80fd\u770b\u5230\u8fd9\u4e2a\u6574\u4f53\u7684\u4e2d\u95f4\u72b6\u6001\u3002</p> <p>\u901a\u5e38\u6765\u8bf4\uff0c\u6211\u4eec\u5728 Critical Section \u4e2d\u4f1a\u8bbf\u95ee\u3001\u4fee\u6539\u591a\u4e2a\u5171\u4eab\u53d8\u91cf\uff0c\u4f46\u662f\u4ed6\u4eec\u5728 Critical Section \u4e4b\u5916\u6052\u5b9a\u5730\u6ee1\u8db3\u67d0\u79cd\u5173\u7cfb\u3002</p>"},{"location":"lab/xv6lab-sync2/#linux-pthread-api","title":"Linux pthread API","text":"<p>pthread (posix thread) \u5e93\u662f Linux \u4e0b\u7684\u591a\u7ebf\u7a0b\u5e93\u3002\u5b83\u6709\u4ee5\u4e0b\u51e0\u7ec4 API\uff1a</p> <ol> <li> <p>\u521b\u5efa\u7ebf\u7a0b\uff1a<code>pthread_create</code>\uff0c\u7b49\u5f85\u7ebf\u7a0b\u9000\u51fa\uff1a<code>pthread_join</code>\u3002</p> </li> <li> <p>\u4e92\u65a5\u9501 mutex\uff08\u4e00\u79cd sleeplock\uff09\uff1a<code>pthread_mutex_t</code></p> </li> </ol> <pre><code>// man pthread_mutex_init\n\n#include &lt;pthread.h&gt;\n\npthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;\n\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n</code></pre> <p>DESCRIPTION    A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.</p> <p>A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread).  A mutex can never be owned by two different threads simultaneously.  A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.</p> <ol> <li>\u6761\u4ef6\u53d8\u91cf\uff1a<code>pthread_cond_t</code></li> </ol> <pre><code>// man pthread_cond_init\n\n#include &lt;pthread.h&gt;\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nint pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\n\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);\n</code></pre> <p>A condition (short for ``condition variable'') is a synchronization device that allows threads to suspend execution and relinquish the processors until some predicate on shared data is  satisfied.  The basic operations on conditions are: signal the condition (when the predicate becomes true), and wait for the condition, suspending the thread execution until another thread signals the condition.</p> <p>A condition variable must always be associated with a mutex, to avoid the race condition where a thread prepares to wait on a condition variable and another thread signals the  condition just before the first thread actually waits on it.</p> <p>pthread_cond_init initializes the condition variable cond, using the condition attributes specified in cond_attr, or default attributes if cond_attr is NULL. Variables of type pthread_cond_t can also be initialized statically, using the constant PTHREAD_COND_INITIALIZER.</p> <p>pthread_cond_signal restarts one of the threads that are waiting on the condition variable cond.  If no threads are waiting on cond, nothing happens. If several threads are waiting on cond, exactly one is restarted, but it is not specified which.</p> <p>pthread_cond_broadcast restarts all the threads that are waiting on the condition variable cond. Nothing happens if no threads are waiting on cond.</p> <p>pthread_cond_wait atomically unlocks the mutex (as per pthread_unlock_mutex) and waits for the condition variable cond to be signaled.  The thread execution is  suspended  and does not consume any CPU time until the condition variable is signaled.  The mutex must be locked by the calling thread on entrance to pthread_cond_wait.  Before returning to the calling thread, pthread_cond_wait re-acquires mutex (as per pthread_lock_mutex).</p> <p>Unlocking  the mutex and suspending on the condition variable is done atomically.  Thus, if all threads always acquire the mutex before signaling the condition, this guarantees that the condition cannot be signaled (and thus ignored) between the time a thread locks the mutex and the time it waits on the condition variable.</p> <ol> <li>Semaphore</li> </ol> <pre><code>#include &lt;semaphore.h&gt;\n\n// man sem_init\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n\n// man sem_post\nint sem_post(sem_t *sem);\n\n// man sem_wait\nint sem_wait(sem_t *sem);\nint sem_trywait(sem_t *sem);\nint sem_timedwait(sem_t *restrict sem, const struct timespec *restrict abs_timeout);\n</code></pre>"},{"location":"lab/xv6lab-sync2/#lab","title":"Lab \u7ec3\u4e60","text":"<ol> <li> <p>\u5047\u8bbe\u6709\u4e24\u79cd\u7ebf\u7a0b\uff0c\u6bcf\u79cd\u7ebf\u7a0b\u82e5\u5e72\u4e2a\uff1a\u7b2c\u4e00\u79cd\u7ebf\u7a0b\u6b7b\u5faa\u73af\u5730\u6253\u5370\u5de6\u62ec\u53f7 <code>(</code>\uff0c\u7b2c\u4e8c\u79cd\u7ebf\u7a0b\u6b7b\u5faa\u73af\u5730\u6253\u5370\u53f3\u62ec\u53f7 <code>)</code>\u3002\u73b0\u5728\u8981\u6c42\uff1a\u5728\u6240\u6709\u65f6\u523b\uff0c\u6253\u5370\u51fa\u6765\u7684\u5b57\u7b26\u4e32\u662f\u5e73\u8861\u7684\u62ec\u53f7\u5b57\u7b26\u4e32\u6216\u5176\u524d\u7f00\u3002\u5982 <code>()(())</code> \u548c <code>((()</code>\u3002\u6700\u591a\u5141\u8bb8 N \u5c42\u5d4c\u5957\u62ec\u53f7\u3002</p> <p>\u4f8b\u5982\uff1a</p> <ul> <li> <p><code>()((()))</code> \u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u5e73\u8861\u62ec\u53f7\uff0c\u6700\u5927\u5d4c\u5957\u6df1\u5ea6\u4e3a 3\u3002</p> </li> <li> <p><code>())</code> \u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u5e73\u8861\u62ec\u53f7\u3002</p> </li> <li> <p><code>((()</code> \u662f <code>((()))</code> \u7684\u524d\u7f00\uff0c\u5d4c\u5957\u6df1\u5ea6\u4e3a 2\u3002</p> </li> </ul> <p>\u5df2\u77e5\u6709\u4e00\u4e2a\u53d8\u91cf <code>count</code> \u8868\u793a\uff1a\u76ee\u524d\u5de6\u62ec\u53f7\u6bd4\u53f3\u62ec\u53f7\u591a\u4e86\u51e0\u4e2a\u3002\u8bf7\u4f60\u5199\u51fa\u8fd9\u4e24\u79cd\u7ebf\u7a0b\u7684\u540c\u6b65\u6761\u4ef6\u3002\u5373\uff0c\u6bcf\u79cd\u7ebf\u7a0b\u5728\u4ec0\u4e48\u65f6\u5019\u53ef\u4ee5\u6253\u5370 <code>(</code> \u6216 <code>)</code>\u3002</p> </li> <li> <p>\u5728\u4f7f\u7528\u6761\u4ef6\u53d8\u91cf\u5b9e\u73b0\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u65f6\uff0c<code>produce</code> \u65b9\u6cd5\u4e2d\u7684 <code>while() sleep</code> \u5faa\u73af\u53ef\u4ee5\u6362\u6210 <code>if() sleep</code> \u5417?</p> <pre><code>void produce(void* data) {\n    acquire(&amp;buf.lock);\n    if (is_full(&amp;buf))       // change while to if\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_full(&amp;buf));\n    put_data(&amp;buf, data);   // modify the buffer, guarded by buf.lock and cond: !full\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n}\n</code></pre> </li> <li> <p>\u4f7f\u7528 Linux \u547d\u4ee4 <code>man xxx</code> \u67e5\u9605 <code>pthread_cond_signal</code> \u548c <code>pthread_cond_broadcast</code> \u7684 manpage\uff0c\u7b80\u8ff0\u5b83\u4eec\u4e4b\u95f4\u7684\u533a\u522b\u3002</p> <p>\u5e76\u56de\u7b54\uff1a\u5728\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u7684\u5b9e\u73b0\u4e2d\uff0c\u6211\u4eec\u5e94\u8be5\u7528\u51e0\u4e2a\u6761\u4ef6\u53d8\u91cf (<code>pthread_cond_t</code>)\uff1f\u4ee5\u53ca\u6211\u4eec\u5728\u901a\u77e5\u6761\u4ef6\u53d8\u66f4 (xv6\u4e2d\u7684<code>wakeup</code>) \u65f6\u5e94\u8be5\u4f7f\u7528 <code>pthread_cond_signal</code> \u8fd8\u662f <code>pthread_cond_broadcast</code> \uff1f</p> </li> </ol>"},{"location":"lab/xv6lab-sync3/","title":"Week 13 - \u540c\u6b65 3 & VFS Synchronization 3 & VFS","text":""},{"location":"lab/xv6lab-sync3/#bug","title":"\u5e76\u53d1 Bug","text":""},{"location":"lab/xv6lab-sync3/#deadlock","title":"Deadlock","text":"<p>\u4e0a\u9501\u662f\u4e00\u4e2a\u975e\u5e38\u7cbe\u7ec6\u7684\u6b65\u9aa4\uff0c\u800c\u6700\u5e38\u89c1\u7684\u95ee\u9898\u5c31\u662f\u6b7b\u9501\u3002\u6b7b\u9501\u95ee\u9898\u901a\u5e38\u5206\u4e3a\u4e24\u79cd\uff1aAA-deadlock \u548c ABBA-deadlock\u3002</p>"},{"location":"lab/xv6lab-sync3/#aa-deadlock","title":"AA-deadlock","text":"<p>AA-deadlock \u8868\u793a\u4f60\u5728\u5bf9\u4e00\u628a\u5df2\u7ecf\u83b7\u5f97\u4e86\u7684\u9501\u91cd\u65b0\u4e0a\u9501\uff1a</p> <pre><code>acquire(&amp;lk);\nassert(holding(&amp;lk));\n// ...\n\n    // maybe in interrupt handler or other methods\n    acquire(&amp;lk);\n    // &lt;-- deadlock here.\n</code></pre> <p>\u5c3d\u7ba1\u6211\u4eec\u770b\u8d77\u6765\u4e0d\u4f1a\u72af\u8fd9\u79cd\u9519\u8bef\uff0c\u4f46\u662f\u771f\u5b9e\u7684\u7cfb\u7edf\u5f80\u5f80\u662f\u5f88\u590d\u6742\u7684\uff0c\u51fd\u6570\u7684\u63a7\u5236\u6d41\u53ef\u80fd\u4e0d\u4f1a\u90a3\u4e48\u7684\u663e\u7136\u3002</p> <p>\u60f3\u8c61\u4f60\u6b63\u5728\u5199\u51fd\u6570 <code>C()</code>\uff0c\u5df2\u7ecf\u5b58\u5728\u51fd\u6570 <code>B</code> \u548c\u51fd\u6570 <code>A</code>\uff0c\u800c <code>B</code> \u8c03\u7528 <code>A</code> \u65f6\u4f1a\u5728 <code>A</code> \u4e2d\u4e0a\u9501\u548c\u89e3\u9501\u3002 \u800c <code>C</code> \u53ef\u80fd\u4e5f\u9700\u8981\u7528\u5230\u540c\u4e00\u628a\u9501\uff0c\u6240\u4ee5\u4f60\u4f1a\u5728 <code>C</code> \u4e2d\u4e5f\u4e0a\u9501\u89e3\u9501\u3002\u800c\u4f60\u53d1\u73b0\u4f60\u4f1a\u9700\u8981\u590d\u7528 <code>A</code> \u7684\u529f\u80fd\uff0c\u4e8e\u662f\u4f60\u5728\u6301\u6709\u9501\u7684\u60c5\u51b5\u4e0b\u8c03\u7528\u4e86 <code>A</code>\u3002</p> <pre><code>void A() {\n    acquire(&amp;lk);\n    // ...\n    release(&amp;lk);\n}\n\nvoid B() {\n    // ...\n    A();\n    // ...\n}\n\nvoid C() {\n    acquire(&amp;lk);\n    A();\n    release(&amp;lk);\n}\n</code></pre> <p>\u5f53\u63a7\u5236\u6d41\u4ece <code>B</code> \u8fdb\u5165 <code>A</code> \u65f6\u662f\u4e0d\u4f1a\u6b7b\u9501\u7684\uff0c\u800c\u4ece <code>C</code> \u8fdb\u5165 <code>A</code> \u65f6\u4f1a\u6b7b\u9501\u3002</p> <p>\u4ee5\u53ca\u60f3\u8c61\u53e6\u4e00\u79cd\u60c5\u51b5\uff0c\u4f60 debug \u627e\u5230\u4e86\u4e00\u4e2a\u5e76\u53d1 bug\uff1b\u4e3a\u4e86\u89e3\u51b3\u5b83\uff0c\u4f60\u5728 <code>A</code> \u4e2d\u52a0\u5165\u4e86\u4e0a\u9501\u89e3\u9501\u7684\u4ee3\u7801\uff1b\u4f60\u53ef\u80fd\u8ba4\u4e3a\u53ea\u6709 <code>B</code> \u4f1a\u8c03\u7528 <code>A</code>\uff0c\u800c\u5b9e\u9645\u4e0a\u5b58\u5728 <code>C -&gt; A</code> \u8fd9\u4e00\u6761\u8c03\u7528\u94fe\uff0c\u800c\u8fd9\u6761\u8c03\u7528\u94fe\u91cc\u9762\u4f60\u5728 <code>C</code> \u4e2d\u4e0a\u4e86\u9501\u3002</p> <p>\u5982\u4f55\u89e3\u51b3\uff1f</p> <p>xv6 \u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u9632\u5fa1\u6027\u7f16\u7a0b\u6765\u907f\u514d\u8fd9\u79cd\u95ee\u9898\uff1a</p> <ol> <li> <p>\u5728 <code>acquire</code> \u4e0a\u9501\u65f6\uff0c\u68c0\u67e5\u5f53\u524d CPU \u662f\u5426\u6301\u6709\u7740\u8fd9\u628a\u9501\u3002\u5982\u679c\u662f\uff0c\u5219\u662f AA \u578b\u6b7b\u9501\uff0c\u4f7f\u7528 <code>panic(\"already acquired by\")</code> \u4e2d\u65ad\u5185\u6838\u6267\u884c\u3002</p> <pre><code>// Acquire the lock.\n// Loops (spins) until the lock is acquired.\nvoid acquire(spinlock_t *lk)\n{\n    uint64 ra = r_ra();\n    push_off(); // disable interrupts to avoid deadlock.\n    if (holding(lk))\n        panic(\"already acquired by %p, now %p\", lk-&gt;where, ra);\n\n    // ...\n}\n</code></pre> </li> <li> <p>\u5bf9\u4e8e\u4e00\u4e9b\u5e38\u7528\u7684\u51fd\u6570\uff0c\u6211\u4eec\u5728\u5165\u53e3\u5904 <code>assert(holding(&amp;lk))</code> \u6765\u65ad\u8a00\u8fdb\u5165\u51fd\u6570\u65f6\u6211\u4eec\u6301\u6709\u8fd9\u628a\u9501\u3002</p> <pre><code>// vm.c\n\npte_t *walk(struct mm *mm, uint64 va, int alloc) {\n    assert(holding(&amp;mm-&gt;lock));\n}\n\nint mm_mappages(struct vma *vma) {\n    // ...\n\n    assert(holding(&amp;vma-&gt;owner-&gt;lock));\n}\n</code></pre> </li> </ol>"},{"location":"lab/xv6lab-sync3/#abba-deadlock","title":"ABBA-deadlock","text":"<p>ABBA \u578b\u6b7b\u9501\u5219\u662f\uff1a\u7ebf\u7a0b 1 \u4ee5 <code>A -&gt; B</code> \u7684\u987a\u5e8f\u4e0a\u9501\uff0c\u7ebf\u7a0b2 \u4ee5 <code>B -&gt; A</code> \u7684\u987a\u5e8f\u4e0a\u9501\u3002 \u5728\u67d0\u4e2a\u6700\u574f\u60c5\u51b5\u4e0b\uff0c\u7ebf\u7a0b1\u548c2\u5206\u522b\u5f97\u5230\u4e86A\u548cB\uff0c\u4f46\u662f\u5b83\u4eec\u53c8\u5404\u81ea\u5728\u7b49\u5f85B\u548cA\uff0c\u800c\u8fd9\u4e24\u628a\u9501\u6070\u597d\u5728\u522b\u4eba\u624b\u4e0a\u3002</p> <p>\u8fd8\u6709\u4e00\u4e9b\u66f4\u52a0\u590d\u6742\u7684\u60c5\u51b5\uff0c\u5982\uff1a</p> <ul> <li>\u7ebf\u7a0b 1 \u4e0a\u9501\u987a\u5e8f\uff1a<code>A -&gt; B</code></li> <li>\u7ebf\u7a0b 2: <code>B -&gt; C</code></li> <li>\u7ebf\u7a0b 3: <code>C -&gt; A</code></li> </ul> <p>\u6211\u4eec\u53ef\u4ee5\u603b\u7ed3\u51fa\u6b7b\u9501\u4ea7\u751f\u7684 \u5fc5\u8981\u6761\u4ef6\uff0c\u5c06\u9501\uff08\u53ef\u4ee5\u63a8\u5e7f\u4e3a\u201c\u5171\u4eab\u8d44\u6e90\u201d\uff09\u89c6\u4e3a\u4e00\u4e2a\u7403\uff1a</p> <ol> <li>Mutual Exclusion: \u62ff\u5230\u7684\u5b8c\u6574\u7684\u7403\uff0c\u4e0d\u53ef\u80fd\u51fa\u73b0\u4e00\u4eba\u4e00\u534a\u7684\u60c5\u51b5</li> <li>Wait-For\uff1a\u6301\u6709\u7403\u7684\u60c5\u51b5\u4e0b\u7b49\u5f85\u989d\u5916\u7684\u7403</li> <li>No-Preemption\uff1a\u4e0d\u80fd\u62a2\u522b\u4eba\u624b\u91cc\u7684\u7403</li> <li>Circular wait\uff1a\u5f62\u6210\u5faa\u73af\u7b49\u5f85\u7684\u5173\u7cfb</li> </ol> <p>\uff08\u63a8\u8350\u9605\u8bfb https://dl.acm.org/doi/10.1145/356586.356588\uff09</p> <p>\u8bba\u6587\u539f\u6587\uff1a This deadlock situation has arisen only because all of the following general conditions were operative: 1) Tasks claim exclusive control of the resources they require (\"mutual exclusion\" condition). 2) Tasks hold resources already allocated to them while waiting for additional resources (\"wait for\" condition). 3) Resources cannot be forcibly removed from the tasks holding them until the resources are used to completion (\"no preemption\" condition). 4) A circular chain of tasks exists, such that each task holds one or more resources that are being requested by the next task in the chain (\"circular wait\" condition). </p> <p>\u65e2\u7136\u8bf4\u8fd9\u662f \u5fc5\u8981\u6761\u4ef6\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u6253\u7834\u4efb\u4f55\u4e00\u4e2a\u5c31\u53ef\u4ee5\u907f\u514d\u6b7b\u9501\u95ee\u9898\u4e86\u3002\u5728\u5927\u578b\u7cfb\u7edf\u4e2d\uff0c\u663e\u7136\u6700\u540e\u4e00\u4e2a\u662f\u6700\u5bb9\u6613\u6253\u7834\u7684\u3002</p> <p>\u4e0a\u9501\u987a\u5e8f\u53ef\u4ee5\u88ab\u89c6\u4e3a\u4e00\u4e2a\u6709\u5411\u8fb9\uff0c\u800c\u5168\u5c40\u7684\u4e0a\u9501\u987a\u5e8f\u5219\u6784\u6210\u4e86\u4e00\u5f20\u56fe(dependency graph)\uff0c\u5982\u679c\u8fd9\u4e2a\u56fe\u4e0a\u5b58\u5728\u73af\uff0c\u5219\u8868\u660e\u6709\u6b7b\u9501\u95ee\u9898\u3002</p> <p>\u5982\u679c\u907f\u514d\u73af\uff1a\u6211\u4eec\u53ef\u4ee5\u7ed9\u9501\u7f16\u53f7(Lock Ordering)\uff0c\u5f3a\u5236\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u4e0a\u9501\u3002</p> <p>\u6b64\u5916\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u52a8\u6001\u68c0\u6d4b\u6b7b\u9501\u3002</p>"},{"location":"lab/xv6lab-sync3/#data-race","title":"Data Race","text":"<p>\u5173\u4e8e\u6570\u636e\u7ade\u4e89\u7684\u5e76\u53d1 bug\uff0c\u4e3b\u8981\u662f\u4ee5\u4e0b\u4e24\u79cd\uff1a</p> <ol> <li>\u4e0a\u9519\u4e86\u9501</li> </ol> <pre><code>void T_1() { spin_lock(&amp;A); sum++; spin_unlock(&amp;A); }\nvoid T_2() { spin_lock(&amp;B); sum++; spin_unlock(&amp;B); }\n</code></pre> <ol> <li>\u5fd8\u8bb0\u4e0a\u9501</li> </ol> <pre><code>void T_1() { spin_lock(&amp;A); sum++; spin_unlock(&amp;A); }\nvoid T_2() { sum++; }\n</code></pre>"},{"location":"lab/xv6lab-sync3/#futex","title":"Futex","text":"<p>\u5728\u4e4b\u524d\u7684\u8bfe\u7a0b\u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u5e76\u53d1\u548c\u540c\u6b65\u7684\u4ee3\u7801\u5747\u662f\u5728\u5185\u6838\u6a21\u5f0f\u4e2d\u4ecb\u7ecd\u7684\u3002\u90a3\u4e48\uff0c\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u7684\u4e92\u65a5\u4e0e\u540c\u6b65\u662f\u600e\u4e48\u5b9e\u73b0\u7684\uff1f</p> <p>\u5171\u4eab\u5185\u5b58</p> <p>\u5728\u672c\u5c0f\u7ae0\u8282\u7684\u4ecb\u7ecd\u90fd\u662f\u57fa\u4e8e\u5171\u4eab\u5185\u5b58\u7684\u6a21\u578b\uff0c\u5728 Linux \u4e0a\uff0c\u5b83\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>mmap(2)</code> \u548c <code>shm(2)</code> \u521b\u5efa\u3002</p> <p>\u5728 xv6 \u4e0a\uff0c\u6211\u4eec\u7684\u8fdb\u7a0b\u6a21\u578b\u5c1a\u672a\u652f\u6301\u5171\u4eab\u5185\u5b58\uff0c\u4f46\u662f\u5176\u6838\u5fc3\u601d\u60f3\u662f\u76f8\u540c\u7684\u3002</p> <p>\u7528\u6237\u6a21\u5f0f\u548c\u5185\u6838\u7684\u533a\u522b</p> <p>\u5f53\u6211\u4eec\u8ba8\u8bba\u5e76\u53d1\u65f6\uff0c\u7528\u6237\u6a21\u5f0f\uff08usermode\uff09\u548c\u5185\u6838\u6a21\u5f0f\uff08kernel\uff09\u6700\u663e\u8457\u7684\u533a\u522b\u662f\uff1a\u5185\u6838\u53ef\u4ee5\u5c4f\u853d\u4e2d\u65ad\uff0c\u800c\u7528\u6237\u7a0b\u5e8f\u4e0d\u53ef\u4ee5\u3002</p> <p>\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\uff0c\u6211\u4eec\u4f9d\u7136\u53ef\u4ee5\u4f7f\u7528\u539f\u5b50\u6307\u4ee4\u6765\u5b9e\u73b0 <code>spinlock</code> \u81ea\u65cb\u9501\u3002\u4f46\u662f\uff0c\u5bf9\u4e8e <code>sleeplock</code> \u6765\u8bf4\uff0c\u4e8b\u60c5\u4f1a\u53d8\u5f97\u66f4\u52a0\u590d\u6742\u3002</p> <p><code>sleeplock</code> \u8981\u6c42\u5728\u62a2\u4e0d\u5230\u9501\u65f6\u7761\u7720\u8fdb\u7a0b\uff0c\u5e76\u5728\u9501\u88ab\u91ca\u653e\u540e\u5524\u9192\u8fdb\u7a0b\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u9700\u8981\u7cfb\u7edf\u8c03\u7528\u6765\u505a\u201c\u7761\u7720\u201d\u548c\u201c\u5524\u9192\u201d\u8fd9\u4e24\u4ef6\u4e8b\u60c5\uff0c\u56e0\u4e3a\u53ea\u6709\u5185\u6838\u624d\u80fd\u4fee\u6539\u67d0\u4e2a\u8fdb\u7a0b\u7684\u72b6\u6001\u3002</p> <pre><code>void sleeplock_acquire(sleeplock_t *lk) {\nretry:\n    if (__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) == 0) {\n        // we succeed in 0-to-1 transition, aka, we get the lock.\n        return;\n    } else {\n        // we fail to get the lock, sleep myself.\n        int mypid = getpid();\n\n        // append myself to the waiter queue.\n        acquire(&amp;lk-&gt;waiters_lock);\n        append_waiter(lk, mypid);\n        release(&amp;lk-&gt;waiters_lock);\n\n        // &lt;-- this process may be wakeup here.\n\n        syscall_sleep();\n\n        // &lt;-- then we will never be woken-up.\n\n        goto retry;\n    }\n}\n\nvoid sleeplock_release(sleeplock_t *lk) {\n\n    // A.\n    __sync_lock_release(&amp;lk-&gt;locked);\n\n    // B.\n    // find the next one to wakeup.\n    acquire(&amp;lk-&gt;waiters_lock);\n    int nextone = pop_waiter(lk);\n    release(&amp;lk-&gt;waiters_lock);\n\n    // C.\n    syscall_wakeup(nextone);\n}\n\n\u7136\u540e\uff0c\u6211\u4eec\u5c31\u4f1a\u9677\u5165\u548c Sync 1 \u8bfe\u4e0a\u8bb2\u7684 \"The Lost Wake-Up Problem\" \u4e00\u6837\u7684\u95ee\u9898\uff0c`syscall_sleep` \u53ef\u80fd\u4f1a\u5bfc\u81f4\u5524\u9192\u4fe1\u53f7\u4e22\u5931\u3002\n\n\u6700\u7b80\u5355\u7684\u6b63\u786e\u65b9\u6cd5\u5373\u662f\u5c06\u6240\u6709\u52a0\u9501\u548c\u89e3\u9501\u7684\u64cd\u4f5c\u90fd\u653e\u7f6e\u5230\u5185\u6838\u5904\u7406\u3002\u4f46\u662f\uff0c\u7cfb\u7edf\u8c03\u7528\u662f\u4e00\u79cd\u76f8\u5f53\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u671f\u671b\u5c06 fast-path \u7559\u5728\u7528\u6237\u6001\u3002\u5bf9\u4e8e `sleeplock` \u800c\u8a00\uff0cfast-path \u5c31\u662f\u6ca1\u6709\u4eba\u4e89\u62a2\u9501\u7684\u60c5\u51b5\u4e0b\uff0c\u53ea\u9700\u8981\u4f7f\u7528\u4e00\u6761\u539f\u5b50\u6307\u4ee4\u6807\u8bb0\u5f53\u524d\u9501\u88ab\u5360\u6709\u3002\n\n&gt; man 7 futex, man 2 futex\n\nfutex \u662f Linux \u5185\u6838\u63d0\u4f9b\u7684\u4e00\u4e2a syscall\uff0c\u7528\u4e8e\u5b9e\u73b0 fast user-space mutexes\uff0c\u5176\u5b9a\u4e49\u5982\u4e0b\uff1a\n\n```c\nlong syscall(SYS_futex, \n    uint32_t *uaddr, int futex_op, uint32_t val,\n    const struct timespec *timeout,   /* or: uint32_t val2 */\n    uint32_t *uaddr2, uint32_t val3);\n</code></pre> <p>\u5b83\u63a5\u53d7\u4e00\u4e2a\u865a\u62df\u5730\u5740 uaddr \u548c\u7528\u6237\u7684\u9884\u671f\u503c val\uff0c\u4ee5\u53ca futex \u7684\u64cd\u4f5c futex_op\u3002 futex \u4f1a\u901a\u8fc7\u865a\u62df\u5730\u5740\u80cc\u540e\u7684\u7269\u7406\u5730\u5740\u6765\u533a\u5206\u4e0d\u540c\u7684 futex \u5bf9\u8c61\u3002\u6240\u4ee5\uff0c\u5bf9\u4e8e\u8de8\u8fdb\u7a0b\u7684 <code>shm</code> \u800c\u8a00\uff0c\u53ea\u8981\u5b83\u4eec\u5404\u81ea\u7684\u865a\u62df\u5730\u5740\u662f\u540c\u4e00\u4e2a\u7269\u7406\u5730\u5740\uff0c\u90a3\u5b83\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7 futex \u5b9e\u73b0\u540c\u6b65\u3002</p> <p>\u6700\u91cd\u8981\u7684\u4e24\u4e2aop\u662f\uff1a</p> <ol> <li> <p><code>FUTEX_WAIT</code>\uff1a\u5982\u679c <code>uaddr</code> \u7684\u503c\u4e0e <code>val</code> \u4e2d\u4e00\u81f4\uff0c\u5219\u9677\u5165\u7761\u7720\uff0c\u5b83\u5c06\u7b49\u5f85\u4e00\u4e2a <code>FUTEX_WAKE</code> \u64cd\u4f5c\u5c06\u5176\u5524\u9192\u3002\u5982\u679c\u5185\u6838\u68c0\u6d4b\u5230 <code>uaddr</code> \u7684\u503c\u4e0e\u7528\u6237\u9884\u671f\u7684 <code>val</code> \u4e0d\u4e00\u81f4\uff08\u8fd9\u8bf4\u660e\u7528\u6237\u8c03\u7528 <code>futex</code> syscall \u7684\u80cc\u666f\u53d1\u751f\u4e86\u53d8\u5316\uff09\uff0c\u90a3\u5b83\u4f1a\u7acb\u523b\u4ece\u7cfb\u7edf\u8c03\u7528\u4e2d\u8fd4\u56de <code>EAGAIN</code>\uff0c\u800c\u4e0d\u9677\u5165\u7761\u7720\u3002\uff08\u8fd9\u5c31\u907f\u514d\u4e86 lost-wakeup \u95ee\u9898\uff09</p> <p>\u5185\u6838\u4e5f\u4f1a\u4f7f\u7528\u539f\u5b50\u6307\u4ee4\u5bf9\u8be5\u865a\u62df\u5730\u5740\u80cc\u540e\u7684\u7269\u7406\u5730\u5740\u8fdb\u884c\u8bbf\u95ee\uff0c\u786e\u4fdd\u539f\u5b50\u6027\u3002</p> <p>This operation tests that the value at the futex word pointed to by the address<code>uaddr</code> still contains the expected value <code>val</code>, and if so, then sleeps waiting for a <code>FUTEX_WAKE</code> operation on the futex word.  </p> <p>If the thread starts to sleep, it is considered a waiter on this futex word.  If the futex value does not match val, then the call fails immediately with the error EAGAIN.</p> <p>The purpose of the comparison with the expected value is to prevent lost wake-ups. If another thread changed the value of the futex word after the calling thread decided to block based on the prior value, and if the other thread executed a <code>FUTEX_WAKE</code> operation after the value change and before this <code>FUTEX_WAIT</code> operation, then the calling thread will observe the value change and will not start to sleep.</p> </li> <li> <p><code>FUTEX_WAKE</code>\uff1a \u5524\u9192\u5728 <code>uaddr</code> \u4e0a\u7b49\u5f85\u7684\u6240\u6709 waiter\u3002</p> <p>This operation wakes at most <code>val</code> of the waiters that are waiting (e.g., inside <code>FUTEX_WAIT</code>) on the futex word at the address <code>uaddr</code>.  Most commonly, val is specified as either 1 (wake up a single waiter) or <code>INT_MAX</code> (wake up all waiters).</p> </li> </ol> <p>\u6211\u4eec\u53ef\u4ee5\u4e00\u63a2\u7a76\u7adf <code>pthread_mutex_t</code> \u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff1a</p> <p>glibc \u6e90\u4ee3\u7801</p> <p>glibc \u6e90\u4ee3\u7801\u975e\u5e38\u590d\u6742\uff0c\u5b83\u4e3a\u4e86\u6027\u80fd\u8fdb\u884c\u4e86\u9ad8\u5ea6\u4f18\u5316\u3002</p> <p>\u8fd9\u4e00\u90e8\u5206\u4ee3\u7801\u4f4d\u4e8e <code>nptl/lowlevellock.c</code> \u4ee5\u53ca <code>sysdeps/nptl/lowlevellock.h</code>\u3002</p> <p><code>pthread_mutex_t</code> \u7684\u57fa\u7840\u529f\u80fd\u662f\u4f9d\u8d56\u4e8e <code>lll</code> lowlevellock \u7684\u3002</p> <p><code>pthread_mutex_t</code> \u4e2d\u6709\u4e00\u4e2a <code>uint32_t</code>\uff0c\u8868\u793a\u9501\u7684\u72b6\u6001\uff1a0 \u8868\u793a\u672a\u4e0a\u9501\uff0c1 \u8868\u793a\u4e0a\u9501\u4e86\u4f46\u662f\u6ca1\u6709 waiter\uff0c<code>&gt;1</code> \u8868\u793a\u4e0a\u9501\u4f46\u662f\u53ef\u80fd\u5b58\u5728 waiter\u3002</p> <pre><code>void lll_lock(uint32_t* futex) {\n    // try to make futex transit from 0 (UNLOCKED) to 1 (LOCKED).\n    if (atomic_compare_and_exchange_bool_acq(futex, 1, 0)) {\n        // if cmpxhg fails: \n\n        // try to exchange 2 into `*futex`, return the original value.\n        while (atomic_exchange_acquire (futex, 2) != 0) {\n\n            // if old value is not `UNLOCKED`\n            syscall_futex(futex, FUTEX_WAIT, 2); /* Wait if *futex == 2.  */\n\n            // if syscall returns, *futex is not 2 or someone wakes me up.\n        }\n\n        // when we get there, old *futex is 0, now 2 (LOCKED).\n    }\n    // succeed, LOCKED (*futex is 1 or 2)\n}\n\nvoid lll_unlock(uint32_t* futex) {\n    // exchange 0 UNLOCKED into futex\n    int __oldval = atomic_exchange_release (futex, 0);\n\n    if (__oldval &gt; 1) {\n        // wake up one waiter\n        syscall_futex(futex, FUTEX_WAKE, 1);\n    }\n}\n</code></pre> <p>\u4e0a\u9501\u6b65\u9aa4\uff1a</p> <ol> <li>\u9996\u5148\u5c1d\u8bd5\u5c06 futex: <code>0-&gt;1</code>\uff0c\u5982\u679c\u5931\u8d25\u4e86\uff0c\u5219\u8bf4\u660e\u6709\u5176\u4ed6\u7ebf\u7a0b\u5360\u7528\u7740\u9501\u3002</li> <li>\u968f\u540e\uff0c\u6b7b\u5faa\u73af\u5730\u5c1d\u8bd5\u5c06 futex: <code>0-&gt;2</code>\uff0c\u5982\u679c\u6210\u529f\uff0c\u5219\u8868\u660e\u4e0a\u9501\u6210\u529f\u3002</li> <li>\u5426\u5219\uff0c\u5728 <code>futex</code> \u4e0a\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528 <code>futex_wait</code> \u7b49\u5f85\u3002\u5f53\u4ece syscall \u4e2d\u9000\u51fa\u65f6\uff0c\u91cd\u8bd5\u7b2c 2 \u6b65\u3002</li> </ol> <p>\u89e3\u9501\u6b65\u9aa4\uff1a</p> <ol> <li>\u5c06 0 \u5199\u5165 futex\uff0c\u5982\u679c\u65e7\u503c\u5927\u4e8e1\uff0c\u5219\u4f7f\u7528 <code>futex</code> syscall \u5524\u9192\u4e00\u4e2a waiter\u3002</li> </ol> <p>\u4f60\u53ef\u4ee5\u8bd5\u7740\u8bc1\u660e\u8fd9\u4e2a\u9501\u6ee1\u8db3\u4e09\u4e2a\u9501\u7684\u8981\u6c42\uff1aMutual Exclusion, Bounded Waiting, Progress\u3002\u6ce8\u610f\uff0c\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\uff0c\u6bcf\u4e00\u6b65\u6267\u884c\u90fd\u662f\u88ab\u4e2d\u65ad\u3001\u4e0e\u5176\u4ed6\u51fd\u6570\u6267\u884c\u6b65\u9aa4\u4ea4\u9519\u7684\u3002</p> <p>\u4f8b\u5982\u4ee5\u4e0b\u4f8b\u5b50\u63cf\u8ff0\u4e86 T1 T2 \u7ade\u4e89\u9501\u7684\u6d41\u7a0b\u56fe\uff1a</p> <pre><code>        T1                  T2\n        |                   |\n  lock (0-&gt;1, ok)           |\n    (acquired)              |\n        |              lock (0-&gt;1, fail)\nunlock(store 0, see 1)      |\n        |              lock (0-&gt;2, ok)\n        |                   |\n    (released)          (acquired)\n\n\n        T1                  T2\n        |                   |\n  lock (0-&gt;1, ok)           |\n    (acquired)         lock (0-&gt;1, fail)\n        |              lock (0-&gt;2, fail)\n        |                futex_wait()\nunlock(store 0, see 2)      |\n    futex_wake()        (woken-up)\n        |              lock (0-&gt;2, ok)\n    (released)              |\n                         (acquired)\n\n\n        T1                  T2\n        |                   |\n  lock (0-&gt;1, ok)           |\n    (acquired)              |\n        |              lock (0-&gt;1, fail)\n        |              lock (0-&gt;2, fail)\nunlock(store 0, see 2)      |\n        |               futex_wait()\n    futex_wake()     (EAGAIN, kernel sees 0)\n        |                   |\n    (released)         lock (0-&gt;2, ok)\n                            |\n                         (acquired)\n</code></pre> <p>\u4f60\u53ef\u4ee5\u8bd5\u7740\u8865\u5168\u5982\u4e0b\u7684\u56fe\uff1a</p> <pre><code>        T1                  T2                      T3\n        |                   |                       |\n  lock (0-&gt;1, ok)           |                 lock (0-&gt;1, fail)\n    (acquired)              |                 lock (0-&gt;2, fail)\n        |                   |                    futex_wait()\n        |              lock (0-&gt;1, fail)            |\n        |              lock (0-&gt;2, fail)            |\n        |                   |                       |\nunlock(store 0, see 2)      |                       |\n        |               futex_wait()                |\n    futex_wake()   (EAGAIN, kernel sees 0)          |\n        |                   |                   (woken-up)\n    (released)         \n</code></pre>"},{"location":"lab/xv6lab-sync3/#sync-1-2-lab","title":"Sync 1 &amp; 2 Lab \u7ec3\u4e60\u89e3\u6790","text":"<p>TODO</p>"},{"location":"lab/xv6lab-sync3/#io","title":"IO","text":"<p>TODO</p>"},{"location":"lab/xv6lab-sync3/#virtual-file-system","title":"Virtual File System","text":"<p>\u5728\u8fdb\u5165\u6587\u4ef6\u7cfb\u7edf\u4e00\u7ae0\u524d\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u8bd5\u7740\u4e86\u89e3\uff1a\u4ec0\u4e48\u662f\u6587\u4ef6\uff1f</p> <ol> <li> <p>\u5f53\u8ba8\u8bba\u6587\u4ef6\u7cfb\u7edf\u4e0a\u5b58\u50a8\u7684\u6587\u4ef6\u65f6\uff0c\u6587\u4ef6\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\u3002</p> <p>\u4e0d\u7ba1\u662f\u4e8c\u8fdb\u5236\u6587\u4ef6\uff08\u5982 ELF \u683c\u5f0f\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff09\u8fd8\u662f Markdown \u683c\u5f0f\u7684\u6587\u672c\u6587\u4ef6\uff0c\u5b83\u4eec\u672c\u8d28\u4e0a\u90fd\u662f\u4e00\u4e32\u5b57\u8282\u5e8f\u5217\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u89e3\u8bfb (interpret) \u5b83\u4eec\u7684\u65b9\u5f0f\u4e0d\u540c\u3002</p> <p>\u5185\u5b58\u7a7a\u95f4\u4e5f\u662f\u4e00\u4e2a\u5b57\u8282\u5e8f\u5217\uff0c\u6240\u4ee5\uff0c\u80fd\u4e0d\u80fd\u5c06\u6587\u4ef6\u7684\u4e00\u90e8\u5206\u6620\u5c04\u5230\u5185\u5b58\u7a7a\u95f4\u5462\uff1f\u8fd9\u5c31\u662f <code>mmap(2)</code> \u7cfb\u7edf\u8c03\u7528\u3002</p> </li> <li> <p>\u5f53\u8ba8\u8bba\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5185\u6838\u4e0e\u7528\u6237\u6a21\u5f0f\u4ea4\u4e92\u65f6\uff0c\u6587\u4ef6\u662f\u5185\u6838\u4e2d\u4e00\u4e2a\u53ef\u4ee5\u548c\u7528\u6237\u7a0b\u5e8f\u4ea4\u4e92\u7684\u5bf9\u8c61\u3002</p> <p>\u5f53\u6211\u4eec\u4f7f\u7528 <code>open(2)</code> \u7cfb\u7edf\u8c03\u7528\u6253\u5f00\u4e00\u4e2a\u6587\u4ef6\u8def\u5f84\u65f6\uff0c\u5185\u6838\u8fd4\u56de\u4e86\u4e00\u4e2a <code>int</code> \u7c7b\u578b\u7684\u503c\uff0c\u5b83\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26 file descriptor\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>read(2)</code>\u3001<code>write(2)</code>\u3001<code>fcntl(2)</code> \u7b49\u7cfb\u7edf\u8c03\u7528\u5bf9\u8fd9\u4e2a\u6587\u4ef6\u8fdb\u884c\u8bfb\u5199\u7b49\u64cd\u4f5c\uff0c\u5b83\u4eec\u7684\u539f\u578b\u4e2d\u5747\u5e26\u6709\u4e00\u4e2a <code>fd</code> \u53c2\u6570\u3002</p> <pre><code>ssize_t read(int fd, void buf[.count], size_t count);\nssize_t write(int fd, const void buf[.count], size_t count);\nint fcntl(int fd, int op, ... /* arg */ );\noff_t lseek(int fd, off_t offset, int whence);\n</code></pre> <p>Unix \u54f2\u5b66\u4e2d Everything is a file. \u5f53\u7136\u5185\u6838\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u4e0d\u662f\u4ee3\u8868\u7740\u201c\u6587\u4ef6\u7cfb\u7edf\u4e0a\u7684\u6587\u4ef6\u201d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002</p> <p>\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a fd \u6765\u63a5\u6536 signal\uff01\uff08\u5c31\u662f\u6211\u4eecproject\u7684\u90a3\u4e2asignal\uff09</p> <pre><code>int signalfd(int fd, const sigset_t *mask, int flags);\n// signalfd() creates a file descriptor that can be used to accept signals targeted at the caller.  \n// This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the\n//   file descriptor may be monitored by select(2), poll(2), and epoll(7).\n</code></pre> <p>\u4ee5\u53ca\u4e00\u79cd\u7279\u6b8a\u7684\u5bf9\u8c61 epoll\uff0c\u5b83\u53ef\u4ee5\u4ee5\u975e\u5e38\u4f4e\u7684\u6027\u80fd\u4ee3\u4ef7\u76d1\u63a7\u8d85\u591a file descriptor \u7684\u72b6\u6001\u53d8\u5316\u3002</p> <pre><code>// epoll_create, epoll_create1 - open an epoll file descriptor. \n//  epoll_create() returns a file descriptor referring to the new epoll instance.\nint epoll_create(int size);\n\n// This  system call is used to add, modify, or remove entries in the interest list of the epoll(7) instance\n//    referred to by the file descriptor epfd.  It requests that the operation op be performed for  the  target\n//    file descriptor, fd.\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *_Nullable event);\n\n// epoll_wait - wait for an I/O event on an epoll file descriptor\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n</code></pre> <p>\u6211\u4eec\u7684\u63a7\u5236\u53f0\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 0 (stdin), 1 (stdout), 2 (stderr) \u4e5f\u4e0d\u662f\u5b58\u50a8\u5728\u78c1\u76d8\u4e0a\u7684\u6587\u4ef6\u7cfb\u7edf\u4e2d\u7684\u4e00\u4e2a\u6587\u4ef6\u3002</p> <p>\u5728xv6\u542f\u52a8\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\u65f6\uff0c\u5b83\u4f1a\u521b\u5efa\u4e24\u4e2a\u6587\u4ef6 stdin \u548c stdout\uff0c\u5206\u522b\u7ed1\u5b9a(install) \u5230\u7b2c\u4e00\u4e2a\u8fdb\u7a0b\u7684 0 \u53f7 fd \u548c 1 \u53f7 fd\u3002</p> <p>\u5728\u7b2c\u4e00\u4e2a\u8fdb\u7a0b(init)\u901a\u8fc7 fork exec \u521b\u5efa\u7b2c\u4e8c\u4e2a\u8fdb\u7a0b <code>sh</code> \u65f6\uff0c<code>sh</code> \u4ece <code>init</code> \u624b\u91cc\u7ee7\u627f\u4e86\u8fd9\u4e24\u4e2a\u6587\u4ef6\uff0c\u5e76\u4e14\u4ecd\u7136\u901a\u8fc7 0 \u548c 1 \u8fd9\u4e24\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7d22\u5f15\u5b83\u4eec\u3002</p> </li> </ol> <p>\u603b\u800c\u8a00\u4e4b\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u7528\u6237\u7a0b\u5e8f\u64cd\u4f5c\u5185\u6838\u5bf9\u8c61\u7684\u4e00\u4e2a\u6807\u8bc6\u7b26\u3002\u5f53\u5185\u6838\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u540e\uff08\u5b83\u53ef\u80fd\u4e0d\u662f\u4e00\u4e2a\u201c\u5b58\u50a8\u5728\u78c1\u76d8\u4e0a\u7684\u6587\u4ef6\u201d\uff09\uff0c\u5185\u6838\u5c06\u5b83\u7ed1\u5b9a\u5230\u6587\u4ef6\u63cf\u8ff0\u7b26\u8868 (File Descriptor Table, fdt) \u4e2d\u7684\u67d0\u4e2a\u6574\u6570\u4e0a\uff0c\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e9b\u7cfb\u7edf\u8c03\u7528\u5bf9\u8fd9\u4e2a\u6587\u4ef6\u8fdb\u884c\u64cd\u4f5c\uff0c\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u6765\u6307\u5b9a\u64cd\u4f5c\u54ea\u4e2a\u6587\u4ef6\u3002</p>"},{"location":"lab/xv6lab-userprocess/","title":"\u7528\u6237\u8fdb\u7a0b","text":""},{"location":"lab/xv6lab-userprocess/#_2","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u4e86\u89e3\u7528\u6237\u5730\u5740\u7a7a\u95f4</li> <li>\u638c\u63e1fork\\exec\\exit\\wait\u7684\u5b9e\u73b0\u539f\u7406</li> </ol> <p>xv6-lab6 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab6</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab6 xv6lab6</code> \u4e0b\u8f7d xv6-lab6 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u5b83\u4f1a\u542f\u52a8\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b <code>init</code>\uff0c<code>init</code> \u4f1a\u542f\u52a8 Shell \u8fdb\u7a0b <code>sh</code>\u3002</p> <p>\u4f60\u4f1a\u770b\u5230 <code>sh</code> \u8fdb\u7a0b\u7684\u7528\u6237\u7a7a\u95f4\u7ed3\u6784\u3002</p> <pre><code>init: starting sh\n[INFO  0,2] exec: exec-ed sh, mm structure:\nmm 0xfffffffd000fff48:\npgt: 0xffffffc080d25000\nref: 1\nvma: 0xfffffffd010bfd38\n    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n=== PageTable at 0xffffffc080d25000 ===\n...\n</code></pre> <p>\u6ce8\uff1a \u672c\u6b21 Lab \u7684 <code>struct mm</code> \u521d\u59cb\u5316\u4ee3\u7801\u548c\u4e0a\u6b21 Lab \u4ee3\u7801\u4e2d\u6709\u6240\u53d8\u52a8\u3002</p>"},{"location":"lab/xv6lab-userprocess/#address-space","title":"Address Space","text":"<p>\u6211\u4eec\u9996\u5148\u56de\u987e\u4e00\u4e0b\uff0c\u5728\u5185\u6838\u548c CPU \u7684\u89c6\u89d2\u4e0b U-mode \u4e0b\u7684\u5730\u5740\u7a7a\u95f4\u662f\u5982\u4f55\u8fdb\u884c\u63cf\u8ff0\u7684\u3002</p> <p>\u5bf9\u4e8e CPU \u800c\u8a00\uff0cU-mode \u4e0b\u7684\u6240\u6709\u8bbf\u5b58\uff0c\u5305\u62ec\u53d6\u6307 (IF)\u3001\u5185\u5b58\u8bfb (LD)\u3001\u5185\u5b58\u5199 (ST) \u90fd\u662f\u8981\u901a\u8fc7\u9875\u8868\u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\u7684\u3002\u800c CPU \u662f\u901a\u8fc7 CSR <code>satp</code> \u4f5c\u4e3a\u9875\u8868\u57fa\u5730\u5740\u6765\u8fdb\u884c\u5730\u5740\u7ffb\u8bd1\u7684\u3002</p> <p>\u6240\u4ee5\uff0c\u5185\u6838\u9700\u8981\u4e3a\u7528\u6237\u8fdb\u7a0b\u8bbe\u7f6e\u9875\u8868\u7ed3\u6784\u3002\u5728\u5185\u6838\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528 <code>struct mm</code> \u7ba1\u7406\u7528\u6237\u5185\u5b58\uff0c\u6bcf\u4e2a PCB <code>struct proc</code> \u4e2d\u5747\u6709\u4e00\u4e2a\u6307\u5411 <code>struct mm</code> \u7684\u6307\u9488 <code>*mm</code>\u3002</p> <pre><code>// os/vm.h\nstruct mm {\n    spinlock_t lock;\n\n    pagetable_t __kva pgt;\n    struct vma* vma;\n};\n</code></pre> <p>\u6bcf\u4e2a <code>struct mm</code> \u4e2d\u6709\u4e00\u5f20\u9875\u8868 <code>pgt</code>\uff0c\u5b83\u5c31\u662f\u7528\u6237\u8fdb\u7a0b\u4f7f\u7528\u7684 <code>satp</code>\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 <code>usertrapret</code> \u548c trampoline \u4e2d\u89c2\u5bdf\u5230\u8fd9\u4e00\u70b9\uff1a</p> <pre><code>// os/trap.c\nvoid usertrapret() {\n    // ...\n\n    // tell trampoline.S the user page table to switch to.\n    uint64 satp  = MAKE_SATP(KVA_TO_PA(curr_proc()-&gt;mm-&gt;pgt));      // &lt;--\n    uint64 stvec = (TRAMPOLINE + (uservec - trampoline)) &amp; ~0x3;\n\n    // jump to userret in trampoline.S at the top of memory, which\n    // switches to the user page table, restores user registers,\n    // and switches to user mode with sret.\n    uint64 fn = TRAMPOLINE + (userret - trampoline);\n    ((void (*)(uint64, uint64, uint64))fn)(TRAPFRAME, satp, stvec);\n}\n\n// os/trampoline.S\n.globl userret\nuserret:\n        # userret(TRAPFRAME, pagetable, stvec)\n        # switch from kernel to user.\n        # usertrapret() calls here.\n        # a0: TRAPFRAME, in user page table.\n        # a1: user page table, for satp.\n        # a2: uservec\n\n        # switch to the user page table.\n        csrw satp, a1\n        sfence.vma zero, zero\n</code></pre> <p>\u5728\u5185\u6838\u7684\u89c6\u89d2\u4e0b\uff0c \u7528\u6237\u7684\u5185\u5b58\u7a7a\u95f4\u662f\u51e0\u4e2a\u8fde\u7eed\u7684\u865a\u62df\u5730\u5740\u533a\u57df\u3002\u6211\u4eec\u5c06\u6bcf\u4e2a\u8fde\u7eed\u7684\u533a\u57df\u7528 <code>struct vma</code> (Virtual Memory Area) \u7ed3\u6784\u4f53\u8868\u793a\uff0c\u5e76\u4f7f\u7528\u94fe\u8868\u5c06\u5b83\u4eec\u4e32\u8d77\u6765\u3002\u6bcf\u4e2a <code>vma</code> \u4e2d\u6709\u8fd9\u4e00\u4e2a\u533a\u57df\u7684\u8d77\u59cb\u5730\u5740\u548c\u7ed3\u675f\u5730\u5740\uff08\u8981\u6c42\u5bf9\u9f50\u5230\u9875\u8fb9\u754c\uff09\uff0c\u4ee5\u53ca\u8be5\u533a\u57df\u7684\u6743\u9650\u3002</p> <pre><code>// os/vm.h\nstruct vma {\n    struct mm* owner;\n    struct vma* next;   // linked list   \n    uint64 vm_start;    // start address (user virtual address)\n    uint64 vm_end;      // end address   (user virtual address)\n    uint64 pte_flags;   // flags\n};\n</code></pre> <p>\u6ce8\u610f\u5230 <code>struct vma</code> \u4e2d\u6709\u4e00\u4e2a <code>struct mm*</code> \u6307\u9488\uff0c\u8fd9\u8868\u793a\u6bcf\u4e2a VMA \u90fd\u4e0b\u5c5e\u4e8e\u67d0\u4e2a <code>struct mm</code>\u3002</p>"},{"location":"lab/xv6lab-userprocess/#loading","title":"Loading","text":"<p>\u7528\u6237 \u7a0b\u5e8f \u4f1a\u6307\u5b9a\u5b83\u5728\u52a0\u8f7d\u65f6\uff0c\u9700\u8981\u52a0\u8f7d\u54ea\u51e0\u4e2a\u8fde\u7eed\u7684\u533a\u57df\uff08\u4e5f\u6210\u4e3a\u6bb5 Segment\uff09\u3002 \u4ee5\u4e0b\u662f <code>llvm-readelf-19 -a user/build/sh</code> \u7684\u8f93\u51fa\uff0c\u8868\u793a <code>sh</code> \u7a0b\u5e8f\u52a0\u8f7d\uff08LOAD\uff09\u65f6\u4f1a\u9700\u8981\u4e09\u4e2a\u8fde\u7eed\u7684\u533a\u57df\uff1a</p> <pre><code>Elf file type is EXEC (Executable file)\nEntry point 0x402000\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x00c3dc 0x0000000000000000 0x0000000000000000 0x000061 0x000000 R   0x1\n  LOAD           0x001000 0x0000000000402000 0x0000000000402000 0x0011f4 0x0011f4 R E 0x1000\n  LOAD           0x003000 0x0000000000404000 0x0000000000404000 0x0000cd 0x0000cd R   0x1000\n  LOAD           0x004000 0x0000000000405000 0x0000000000405000 0x000020 0x0007d0 RW  0x1000\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u5728 <code>os/proc.c</code> \u4e2d\u7684 <code>exec</code> \u51fd\u6570\u4e2d\uff0c\u4f7f\u7528 <code>mm_print</code> \u6253\u5370 <code>sh</code> \u52a0\u8f7d\u5b8c\u6210\u540e \u8fdb\u7a0b \u7684 <code>struct mm</code> \u7ed3\u6784\u4ee5\u53ca <code>pgt</code> \u9875\u8868\u3002</p> <pre><code>mm 0xfffffffd000fff88:\n  pgt: 0xffffffc080b14000\n  ref: 1\n  vma: 0xfffffffd010bfe28\n    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n=== PageTable at 0xffffffc080b14000 ===\n[0], pte[0xffffffc080b14000]: 0x0000000000000000 -&gt; 0x0000000080b22000 -------V\n  [2], pte[0xffffffc080b22010]: 0x0000000000400000 -&gt; 0x0000000080b23000 -------V\n    [2], pte[0xffffffc080b23010]: 0x0000000000402000 -&gt; 0x0000000080b21000 ---UX-RV\n    [3], pte[0xffffffc080b23018]: 0x0000000000403000 -&gt; 0x0000000080b20000 ---UX-RV\n    [4], pte[0xffffffc080b23020]: 0x0000000000404000 -&gt; 0x0000000080b1f000 ---U--RV\n    [5], pte[0xffffffc080b23028]: 0x0000000000405000 -&gt; 0x0000000080b1e000 ---U-WRV\n[3], pte[0xffffffc080b14018]: 0x00000000c0000000 -&gt; 0x0000000080b18000 -------V\n  [1ff], pte[0xffffffc080b18ff8]: 0x00000000ffe00000 -&gt; 0x0000000080b19000 -------V\n    [1e8], pte[0xffffffc080b19f40]: 0x00000000fffe8000 -&gt; 0x0000000080b1d000 ---U-WRV\n    [1e9], pte[0xffffffc080b19f48]: 0x00000000fffe9000 -&gt; 0x0000000080b1c000 ---U-WRV\n    [1ea], pte[0xffffffc080b19f50]: 0x00000000fffea000 -&gt; 0x0000000080b1b000 ---U-WRV\n    [1eb], pte[0xffffffc080b19f58]: 0x00000000fffeb000 -&gt; 0x0000000080b1a000 ---U-WRV\n    [1ec], pte[0xffffffc080b19f60]: 0x00000000fffec000 -&gt; 0x0000000080b24000 ---U-WRV\n    [1ed], pte[0xffffffc080b19f68]: 0x00000000fffed000 -&gt; 0x0000000080b25000 ---U-WRV\n    [1ee], pte[0xffffffc080b19f70]: 0x00000000fffee000 -&gt; 0x0000000080b26000 ---U-WRV\n    [1ef], pte[0xffffffc080b19f78]: 0x00000000fffef000 -&gt; 0x0000000080b27000 ---U-WRV\n[ff], pte[0xffffffc080b147f8]: 0x0000003fc0000000 -&gt; 0x0000000080b15000 -------V\n  [1ff], pte[0xffffffc080b15ff8]: 0x0000003fffe00000 -&gt; 0x0000000080b16000 -------V\n    [1fe], pte[0xffffffc080b16ff0]: 0x0000003fffffe000 -&gt; 0x0000000080b17000 DA---WRV\n    [1ff], pte[0xffffffc080b16ff8]: 0x0000003ffffff000 -&gt; 0x000000008020b000 -A--X-RV\n=== END === \n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5728 vma \u94fe\u8868\u4e2d\uff0c\u6709\u4e09\u4e2a\u533a\u57df\u662f\u548c ELF \u4e2d\u7684 LOAD \u6bb5\u76f8\u540c\u7684\uff0c\u5b83\u4eec\u5206\u522b\u662f <code>.text</code>, <code>.rodata</code>, <code>.data/.bss</code> \u6bb5\u3002 <pre><code>    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n</code></pre></p> <p>\u53e6\u4e00\u4e2a\u4ee5 <code>0xfffe</code> \u5f00\u59cb\u7684\u5730\u5740\u5219\u662f\u8fdb\u7a0b\u7684\u6808\u533a\u3002 <pre><code>    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n</code></pre></p> <p>\u6b64\u5916\uff0c\u8fd8\u6709\u4e00\u4e2a\u5927\u5c0f\u4e3a0\u7684\u533a\u57df\uff0c\u5b83\u8ddf\u968f\u5728\u6240\u6709 LOAD \u6bb5\u540e\u9762\uff0c\u8fd9\u662f\u8fdb\u7a0b\u7684\u5806\u533a (Heap\uff0c\u5728\u8fdc\u53e4\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0a\u6211\u4eec\u79f0\u4e4b\u4e3a <code>Program Break</code>)\u3002\u8fdb\u7a0b\u9700\u8981\u4f7f\u7528 <code>sbrk</code> \u7cfb\u7edf\u8c03\u7528\u6765\u6269\u5c55\u6216\u6536\u7f29\u5806\u533a\u3002</p> <pre><code>    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n</code></pre>"},{"location":"lab/xv6lab-userprocess/#_3","title":"\u6982\u89c8\u56fe","text":"<p>\u8be5\u56fe\u5c55\u793a\u4e86\u5185\u6838\u4e2d\u7528\u4e8e\u7ba1\u7406 <code>sh</code> \u8fdb\u7a0b\u7684\u7528\u6237\u5730\u5740\u7a7a\u95f4\u7684\u6570\u636e\u7ed3\u6784\u3002</p> <p></p>"},{"location":"lab/xv6lab-userprocess/#fork","title":"fork","text":"<p>fork \u7cfb\u7edf\u8c03\u7528\u662f\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a\u65b0\u8fdb\u7a0b\u7684\u51fd\u6570\u3002\u5f53\u4e00\u4e2a\u8fdb\u7a0b\u8c03\u7528 fork \u65f6\uff0c\u5b83\u4f1a\u521b\u5efa\u4e00\u4e2a\u4e0e\u7236\u8fdb\u7a0b\u51e0\u4e4e\u5b8c\u5168\u76f8\u540c\u7684\u65b0\u8fdb\u7a0b\uff08\u79f0\u4e3a\u5b50\u8fdb\u7a0b\uff09\u3002\u5b50\u8fdb\u7a0b\u4f1a\u590d\u5236\u7236\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u3001\u6240\u6709\u5bc4\u5b58\u5668\u503c\u3002\u552f\u4e00\u4e0d\u540c\u7684\u662f\uff0cfork \u8c03\u7528\u8fd4\u56de\u7684\u503c\uff1a</p> <ul> <li> <p>\u7236\u8fdb\u7a0b\uff1afork \u8fd4\u56de\u5b50\u8fdb\u7a0b\u7684 PID\uff08\u8fdb\u7a0bID\uff09\u3002</p> </li> <li> <p>\u5b50\u8fdb\u7a0b\uff1afork \u8fd4\u56de 0\u3002</p> </li> </ul> <p>xv6 \u4e2d\u7684 <code>fork</code> \u5b9e\u73b0\u4f4d\u4e8e <code>os/proc.c</code> \u4e2d\u7684 <code>fork</code> \u51fd\u6570\u3002\u4ee5\u4e0b\u4e3a\u7b80\u5316\u7248\u672c\uff1a</p> <pre><code>int fork() {\n    int ret;\n    struct proc *np = allocproc();  // child process\n    struct proc *p = curr_proc();   // parent process\n\n    // create a new struct mm for child process\n    np-&gt;mm = mm_create(np-&gt;trapframe);\n\n    // Copy user memory from parent to child.\n    mm_copy(p-&gt;mm, np-&gt;mm);\n\n    // copy saved user registers.\n    *(np-&gt;trapframe) = *(p-&gt;trapframe);\n\n    // Cause fork to return 0 in the child.\n    np-&gt;trapframe-&gt;a0 = 0;\n    np-&gt;parent        = p;\n\n    // add the child process to scheduler\n    np-&gt;state         = RUNNABLE;\n    add_task(np);\n\n    return np-&gt;pid; // return value for the parent process\n}\n</code></pre> <p><code>fork</code> \u7684\u8c03\u7528\u8005\u5373\u4e3a\u7236\u8fdb\u7a0b\uff0c\u5176\u4e2d\u7528 <code>allocproc</code> \u7533\u8bf7\u7684\u65b0 PCB \u5373\u4e3a\u5b50\u8fdb\u7a0b\u3002\u6211\u4eec\u901a\u8fc7\u4fee\u6539 <code>np</code> \u7684 trapframe \u6765\u5b9e\u73b0\u4e24\u8005\u62e5\u6709\u4e0d\u540c\u7684\u8fd4\u56de\u503c\u3002\u6ce8\u610f\u5230\u6211\u4eec\u5e76\u6ca1\u6709\u6539 <code>p</code> \u7684 trapframe\uff0c\u8fd9\u662f\u56e0\u4e3a <code>syscall</code> \u51fd\u6570\u5728\u5206\u53d1\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u4f1a\u4e3a\u6211\u4eec\u5c06 <code>fork</code> \u51fd\u6570\u7684\u8fd4\u56de\u503c\u5199\u5165 trapframe \u4e2d\u7684 <code>a0</code>\uff0c\u6211\u4eec\u53ea\u9700\u8ba9 <code>fork</code> \u8fd4\u56de\u5b50\u8fdb\u7a0b\u7684 PID \u5373\u53ef\u3002</p> <p><code>mm_copy</code> (\u4f4d\u4e8e <code>os/vm.c</code>) \u51fd\u6570\u6700\u7ec8\u5b9e\u73b0\u4e86\u5bf9\u6240\u6709 <code>vma</code> \u7684\u590d\u5236\uff1a\u5b9e\u9645\u4e0a\u5c31\u662f\u5728\u65b0\u7684 <code>mm</code> \u4e0b\u9762\u521b\u5efa\u65b0\u7684 <code>struct vma</code>\uff0c\u8d4b\u503c <code>vma</code> \u4e2d\u7684\u5c5e\u6027\uff0c\u8c03\u7528 <code>mm_mappages</code> \u6620\u5c04\u8be5 <code>vma</code>\uff0c\u6700\u540e\u590d\u5236\u5b9e\u9645\u7684\u5185\u5b58\u6570\u636e\u3002</p> <p>Trapframe \u548c Trampoline</p> <p>\u5728\u6982\u89c8\u56fe\u4e2d\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u7528\u6237\u9875\u8868\u4e2d\u5305\u542b Trapframe \u548c Trampoline\uff0c\u800c <code>vma</code> \u94fe\u8868\u4e2d\u5e76\u4e0d\u5305\u542b\u8fd9\u4e24\u4e2a\u9875\u9762\u3002\u8fd9\u6837\u7684\u8bbe\u8ba1\u662f\u523b\u610f\u7684\u800c\u975ebug\u3002</p> <p>\u8003\u8651 <code>vma</code> \uff08\u7528\u6237\u7684 Virtual Memory Area\uff09 \u7684 \u751f\u547d\u5468\u671f (Lifecycle)\uff0c<code>exec</code> \u7cfb\u7edf\u8c03\u7528\u4f1a\u5220\u9664\u6240\u6709\u73b0\u6709\u7684\u7528\u6237\u5185\u5b58\u6620\u5c04\u5e76\u66ff\u6362\u4e3a\u65b0\u7684\uff0c\u4f46\u662f PCB (\u5373 <code>struct proc</code>) \u5bf9\u8c61\u662f\u4e0d\u9700\u8981\u9500\u6bc1\u91cd\u5efa\u7684\uff0cTrapframe \u4f3c\u4e4e\u4e5f\u4e0d\u9700\u8981\u91cd\u65b0\u5206\u914d\u7269\u7406\u9875\u9762\u3002</p> <p>\u6240\u4ee5\uff0cTrapframe \u548c Trampoline \u7684\u751f\u547d\u5468\u671f\u5b9e\u9645\u4e0a\u4e0e\u8be5\u8fdb\u7a0b\u4e00\u81f4\uff0c\u800c\u4e0d\u662f\u4e0e\u4efb\u4f55\u4e00\u4e2a <code>vma</code> \u6761\u76ee\u4e00\u81f4\u3002</p> <p>\u5728\u5b9e\u73b0\u4e0a\uff0c\u6211\u4eec\u5728\u7cfb\u7edf\u521d\u59cb\u5316\u65f6\uff0c\u5373 <code>proc_init</code> \u4e2d\u7533\u8bf7 Trapframe \u9875\u9762\uff0c\u5728 <code>create_mm</code> \u4e2d\u6620\u5c04 Trampoline \u548c Trapframe.</p>"},{"location":"lab/xv6lab-userprocess/#exec","title":"exec","text":"<p>exec \u7cfb\u7edf\u8c03\u7528\u7528\u4e8e\u6267\u884c\u4e00\u4e2a\u65b0\u7684\u7a0b\u5e8f\uff0c\u5e76\u7528\u65b0\u7684\u7a0b\u5e8f\u66ff\u6362\u5f53\u524d\u8fdb\u7a0b\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u4e0e fork \u4e0d\u540c\uff0cexec \u4e0d\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fdb\u7a0b\uff0c\u800c\u662f\u7528\u4e00\u4e2a\u65b0\u7a0b\u5e8f\u66ff\u6362\u5f53\u524d\u8fdb\u7a0b\u7684\u4ee3\u7801\u3001\u6570\u636e\u548c\u5806\u6808\u3002</p> <p>\u8c03\u7528 exec \u65f6\uff0c\u5f53\u524d\u8fdb\u7a0b\u7684\u5730\u5740\u7a7a\u95f4\u4f1a\u88ab\u65b0\u7684\u7a0b\u5e8f\u7684\u4ee3\u7801\u548c\u6570\u636e\u66ff\u6362\u6389\u3002\u539f\u5148\u8fdb\u7a0b\u7684\u4ee3\u7801\u3001\u6570\u636e\u3001\u5806\u6808\u90fd\u4f1a\u88ab\u6e05\u7a7a\uff0c\u5e76\u4e14\u52a0\u8f7d\u65b0\u7684\u7a0b\u5e8f\u3002\u968f\u540e\uff0c\u5f53\u524d\u8fdb\u7a0b\u7684\u6267\u884c\u6d41\u5c06\u8df3\u8f6c\u5230\u65b0\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\uff0c\u7ee7\u7eed\u6267\u884c\u65b0\u7684\u7a0b\u5e8f\u4ee3\u7801\u3002</p> <pre><code>int exec(char *name, char *args[]) {\n    struct user_app *app = get_elf(name);\n\n    struct proc *p = curr_proc();\n\n    // execve does NOT preserve memory mappings:\n    //  free VMAs including program_brk, and ustack\n    // load_user_elf() will create a new mm for the new process and free the old one\n    //  , if page allocations all succeed.\n    // Otherwise, we will return to the old process.\n    // However, keep the phys page of trapframe, because it belongs to struct proc.\n    load_user_elf(app, p, args);\n\n    // syscall() will overwrite trapframe-&gt;a0 to the return value.\n    return p-&gt;trapframe-&gt;a0;\n}\n</code></pre> <p><code>load_user_elf</code> \u51fd\u6570\u76f8\u8f83\u4e8e\u4e0a\u6b21 Lab \u6709\u6240\u53d8\u52a8\u3002\u6211\u4eec\u9700\u8981\u6ce8\u610f\u5230\uff0c \u7533\u8bf7\u7269\u7406\u9875\u9762\u662f\u6709\u53ef\u80fd\u5931\u8d25\u7684\u3002\u5728\u7cfb\u7edf\u6ca1\u6709\u8db3\u591f\u7684\u5185\u5b58\u65f6\uff0c<code>exec</code> \u51fd\u6570\u6267\u884c\u5931\u8d25\uff0c\u6211\u4eec\u9700\u8981\u56de\u5230\u539f\u6765\u7684\u8fdb\u7a0b\u4e2d\u7ee7\u7eed\u6267\u884c\uff0c\u5e76\u4e14\u8981\u91ca\u653e\u6389\u5206\u914d\u5230\u4e00\u534a\u7684\u5185\u5b58\uff08\u5373\u4e0d\u8981\u6f0f\u5185\u5b58\uff09\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 <code>struct mm</code>\uff0c\u5e76\u5411\u5176\u4e2d\u52a0\u8f7d ELF \u4e2d\u7684\u6bb5\u548c\u8fdb\u7a0b\u6808\u7b49\u3002\u53ea\u6709\u4e0d\u518d\u9700\u8981\u8fdb\u884c\u5185\u5b58\u5206\u914d\u540e (<code>mm_mappages</code>)\uff0c\u6211\u4eec\u624d\u5c06 <code>p-&gt;mm</code> \u7ed9\u6e05\u7a7a\u5e76\u8986\u76d6\u6389\u3002</p> <pre><code>// os/loader.c, Simpilfied version.\nint load_user_elf(struct user_app *app, struct proc *p, char *args[]) {\n\n    // create a new mm for the process, including trapframe and trampoline mappings\n    struct mm *new_mm = mm_create(p-&gt;trapframe);\n\n    Elf64_Ehdr *ehdr      = (Elf64_Ehdr *)app-&gt;elf_address;\n    for (int i = 0; i &lt; ehdr-&gt;e_phnum; i++) {\n        struct vma *vma = mm_create_vma(new_mm);\n        // Load Segment from phdr.\n        if (mm_mappages(vma) &lt; 0)   // if page allocation fails, jump to bad.\n            goto bad;\n    }\n    // setup brk: zero\n    mm_mappages(vma_brk);\n    // setup stack\n    mm_mappages(vma_ustack);\n\n    // from here, we are done with all page allocation \n    // (including pagetable allocation during mapping the trampoline and trapframe).\n\n    // free the old mm.\n    if (p-&gt;mm)\n        mm_free(p-&gt;mm);    \n\n    // we can modify p's fields because we will return to the new exec-ed process.\n    p-&gt;mm      = new_mm;\n    // setup trapframe\n    p-&gt;trapframe-&gt;epc = ehdr-&gt;e_entry;\n\n    return 0;\n\n    // otherwise, page allocations fails. we will return to the old process.\nbad:\n    warnf(\"load (%s) failed: %d\", app-&gt;name, ret);\n    mm_free(new_mm);\n    return ret;\n}\n</code></pre>"},{"location":"lab/xv6lab-userprocess/#_4","title":"\u751f\u547d\u5468\u671f","text":""},{"location":"lab/xv6lab-userprocess/#exit","title":"exit","text":"<p><code>exit</code> \u7cfb\u7edf\u8c03\u7528\u7528\u4e8e\u7ec8\u6b62\u5f53\u524d\u8fdb\u7a0b\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u9000\u51fa\u72b6\u6001\u7ed9\u64cd\u4f5c\u7cfb\u7edf\u3002<code>exit</code> \u7cfb\u7edf\u8c03\u7528\u6c38\u8fdc\u4e0d\u4f1a\u8fd4\u56de\u3002\u8c03\u7528 <code>exit</code> \u540e\uff0c\u8fdb\u7a0b\u7684\u4e00\u4e9b\u8d44\u6e90 \u4e0d\u4f1a\u88ab\u64cd\u4f5c\u7cfb\u7edf\u7acb\u523b\u56de\u6536\u3002\u5e76\u4e14\uff0c<code>exit</code> \u4e0d\u4f1a\u4f7f\u5176\u7acb\u523b\u4ece\u7236\u8fdb\u7a0b\u7684\u89c6\u91ce\u4e2d\u6d88\u5931\u3002\u5b83\u4ecd\u7136\u5b58\u5728\u4e8e\u201c\u50f5\u5c38\u8fdb\u7a0b\u201d\u72b6\u6001\uff0c\u76f4\u5230\u7236\u8fdb\u7a0b\u901a\u8fc7 <code>wait</code> \u7cfb\u7edf\u8c03\u7528\u83b7\u53d6\u5230\u5b50\u8fdb\u7a0b\u7684\u9000\u51fa\u72b6\u6001\u5e76\u56de\u6536\u8be5\u8fdb\u7a0b\u3002</p> <p>\u4ee5\u4e0b\u662f\u7b80\u5316\u7248\u672c\u7684 <code>exit</code>\u3002\u6ce8\u610f\u5230\u5728\u8fd9\u91cc\u9762\u6211\u4eec\u5e76\u6ca1\u6709\u56de\u6536\u7528\u6237\u8d44\u6e90\uff1a\u5230\u76ee\u524d\u7684 Lab \u4e3a\u6b62\uff0c\u6211\u4eec\u53ea\u4ecb\u7ecd\u8fc7\u4e00\u79cd\u7528\u6237\u8d44\u6e90\uff0c\u5373\u7528\u6237\u5185\u5b58\u3002</p> <p>\u5728 <code>exit</code> \u4e2d\uff0c\u6211\u4eec\u53ea\u5c06\u81ea\u5df1\u7684\u72b6\u6001\u8bbe\u4e3a <code>ZOMBIE</code>\uff0c\u5e76\u628a\u9000\u51fa\u4ee3\u7801\u4fdd\u5b58\u5230 <code>p-&gt;exit_code</code> \u4e2d\u3002\u7136\u540e\uff0c\u6211\u4eec\u4f7f\u7528 <code>wakeup</code> \u5524\u9192 \u81ea\u5df1\u7684\u7236\u8fdb\u7a0b\u3002</p> <pre><code>// Exit the current process.\nvoid exit(int code) {\n    int wakeinit = 0;\n    struct proc *p = curr_proc();\n\n    acquire(&amp;wait_lock);\n    // reparent\n\n    // wakeup wait-ing parent.\n    wakeup(p-&gt;parent);\n\n    acquire(&amp;p-&gt;lock);\n    p-&gt;exit_code = code;\n    p-&gt;state     = ZOMBIE;\n    release(&amp;wait_lock);\n\n    sched();\n    panic_never_reach();\n}\n</code></pre> <p>wakeup</p> <p>\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u7684\u540c\u6b65 Lab \u5177\u4f53\u8bb2\u89e3\u9501\u548c\u540c\u6b65\uff0c\u4ee5\u53ca\u4e0a\u8ff0\u4ee3\u7801\u4e2d\u7684 <code>wait_lock</code> \u662f\u4ec0\u4e48\u3002</p> <p>\u5728\u8fd9\u8282 Lab\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u7236\u8fdb\u7a0b\u5728 <code>wait</code> \u627e\u4e0d\u5230\u5904\u4e8e <code>ZOMBIE</code> \u7684\u5b50\u8fdb\u7a0b\u65f6\u4f1a\u9677\u5165 \u7761\u7720\u3002\u800c\u5b50\u8fdb\u7a0b <code>exit</code> \u4f1a\u628a\u81ea\u5df1\u8bbe\u4e3a <code>ZOMBIE</code>\uff0c\u8fd9\u6253\u7834\u4e86 \u7236\u8fdb\u7a0b\u9677\u5165 Sleeping \u7684\u6761\u4ef6\uff0c\u6240\u4ee5\u6211\u4eec\u5524\u9192\u7236\u8fdb\u7a0b\u4f7f\u5176\u4e0d\u518d\u7761\u7720\u3002</p>"},{"location":"lab/xv6lab-userprocess/#reparent","title":"reparent","text":"<p>\"reparent\"\u662f\u6307\u5f53\u4e00\u4e2a\u8fdb\u7a0b\u7684\u7236\u8fdb\u7a0b\u7ec8\u6b62\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5c06\u8be5\u8fdb\u7a0b\u7684\u7236\u8fdb\u7a0b\u66f4\u6539\u4e3a init \u8fdb\u7a0b\uff08PID \u4e3a 1 \u7684\u8fdb\u7a0b\uff09\u3002\u8fd9\u662f\u4e00\u4e2a\u7cfb\u7edf\u7ea7\u7684\u7ba1\u7406\u673a\u5236\uff0c\u7528\u4e8e\u786e\u4fdd\u5728\u7236\u8fdb\u7a0b\u7ec8\u6b62\u65f6\uff0c\u5b50\u8fdb\u7a0b\u4ecd\u7136\u6709\u4e00\u4e2a\u7236\u8fdb\u7a0b\u6765\u8fdb\u884c\u8d44\u6e90\u56de\u6536\u3001\u8fdb\u7a0b\u7ba1\u7406\u7b49\u5fc5\u8981\u64cd\u4f5c\u3002</p> <p>reparent \u673a\u5236\u4e3b\u8981\u662f\u4e3a\u4e86\u907f\u514d\u201c\u5b64\u513f\u8fdb\u7a0b\u201d\u95ee\u9898\uff0c\u5e76\u786e\u4fdd\u7cfb\u7edf\u8d44\u6e90\u5f97\u5230\u9002\u5f53\u56de\u6536\u3002\u5728 xv6 \u4e2d\uff0c<code>init</code> \u5c31\u50cf\u662f\u4e00\u4e2a\"\u5b64\u513f\u9662\"\uff0c\u8d1f\u8d23\u56de\u6536\u5b50\u8fdb\u7a0b\u4eec\u521b\u5efa\u7684\u5b59\u5b50\u8fdb\u7a0b\u3002</p> <p></p> <pre><code>// user/src/init.c\n\nfor (;;) {\n    // this call to wait() returns if the shell exits,\n    // or if a parentless process exits.\n    wpid = wait(-1, NULL);\n    if (wpid == pid) {\n        // the shell exited; restart it.\n        printf(\"init: sh exited, restarting...\\n\");\n        break;\n    } else {\n        // it was a parentless process; do nothing.\n        printf(\"init: wait a parentless process %d\\n\", wpid);\n    }\n}\n</code></pre>"},{"location":"lab/xv6lab-userprocess/#wait","title":"wait","text":"<p>wait \u7cfb\u7edf\u8c03\u7528\u662f\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7528\u4e8e\u8fdb\u7a0b\u63a7\u5236\u7684\u4e00\u4e2a\u91cd\u8981\u51fd\u6570\u3002\u5b83\u7684\u4e3b\u8981\u4f5c\u7528\u662f\u5141\u8bb8\u4e00\u4e2a\u7236\u8fdb\u7a0b\u7b49\u5f85\u5176\u5b50\u8fdb\u7a0b\u7684\u72b6\u6001\u53d8\u5316\uff08\u5728 xv6 \u4e2d\u53ea\u6709\u7ed3\u675f\u8fd9\u4e00\u79cd\u60c5\u51b5\uff09\uff0c\u5e76\u4e14\u5c06\u5b50\u8fdb\u7a0b\u7684\u9000\u51fa\u4ee3\u7801\u8fd4\u56de\u7ed9\u7236\u8fdb\u7a0b\u3002</p> <p>\u5728 xv6 \u4e2d\uff0c<code>wait</code> \u7684\u539f\u578b\u66f4\u50cf\u662f Linux \u4e2d\u7684 <code>waitpid(2)</code>\u3002\u4f20\u5165\u7684 <code>pid</code> \u53ef\u4ee5\u4e3a\u4e00\u4e2a\u8d1f\u503c\uff0c\u8868\u793a wait \u4efb\u4f55\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5426\u5219\u8868\u793a wait \u7279\u5b9a\u7684\u5b50\u8fdb\u7a0b\u3002</p> <p>\u5728 xv6 \u4e2d\uff0c\u4e3a\u4e86\u5b9e\u73b0\u7b80\u5355\uff0c\u8868\u793a\u7236\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u4e4b\u95f4\u7684\u5173\u7cfb\u4f7f\u7528\u7684\u662f\u5b50\u8fdb\u7a0b PCB \u4e2d\u7684 <code>parent</code> \u6307\u9488\uff0c\u800c\u5e76\u6ca1\u6709\u4e00\u4e2a\u53cd\u5411\u7684 <code>children</code> \u5217\u8868\u7528\u4e8e\u904d\u5386\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u904d\u5386\u6240\u6709\u7684\u8fdb\u7a0b\uff0c\u8bd5\u56fe\u627e\u5230\u4e00\u4e2a child \u7684 <code>parent</code> \u6307\u9488\u4e3a\u5f53\u524d\u8fdb\u7a0b (<code>curr_proc()</code>)\u3002</p> <p>\u5f53\u6211\u4eec\u80fd\u627e\u5230\u8fd9\u6837\u7684\u8fdb\u7a0b\uff0c\u5e76\u4e14\u5b83\u662f <code>ZOMBIE</code> \u72b6\u6001\u65f6\uff0c\u6211\u4eec\u5373\u53ef\u5bf9\u5b83\u8fdb\u884c\u8d44\u6e90\u56de\u6536\uff0c\u4ee5\u53ca\u4ece wait \u7cfb\u7edf\u8c03\u7528\u4e2d\u8fd4\u56de\u3002</p> <pre><code>int wait(int pid, int *code) {\n    struct proc *child;\n    int havekids;\n    struct proc *p = curr_proc();\n\n    acquire(&amp;wait_lock);\n\n    for (;;) {\n        // Scan through table looking for exited children.\n        havekids = 0;\n        for (int i = 0; i &lt; NPROC; i++) {\n            child = pool[i];\n            if (child == p)\n                continue;\n\n            acquire(&amp;child-&gt;lock);\n            if (child-&gt;parent == p) {\n                havekids = 1;\n                if (child-&gt;state == ZOMBIE &amp;&amp; (pid &lt;= 0 || child-&gt;pid == pid)) {    // condition for matching a child process\n                    int cpid = child-&gt;pid;\n                    // Found one.\n                    if (code)\n                        *code = child-&gt;exit_code;\n                    freeproc(child);\n                    release(&amp;child-&gt;lock);\n                    release(&amp;wait_lock);\n                    return cpid;\n                }\n            }\n            release(&amp;child-&gt;lock);\n        }\n\n        // No waiting if we don't have any children.\n        if (!havekids || p-&gt;killed) {\n            release(&amp;wait_lock);\n            return -ECHILD;\n        }\n\n        debugf(\"pid %d sleeps for wait\", p-&gt;pid);\n        // Wait for a child to exit.\n        sleep(p, &amp;wait_lock);  // DOC: wait-sleep\n    }\n}\n</code></pre> <p><code>freeproc</code> \u51fd\u6570\u4f1a\u91ca\u653e child \u7684 PCB\uff08\u5c06\u5176\u6807\u8bb0\u4e3a UNUSED\uff09\uff0c\u5e76\u56de\u6536\u7528\u6237\u5185\u5b58\uff08<code>mm_free</code>\uff09\u3002</p>"},{"location":"lab/xv6lab-userprocess/#sleep","title":"Sleep \u673a\u5236","text":"<p>\u60f3\u8c61\u4e00\u4e0b\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u6b63\u5728\u4f7f\u7528 <code>read</code> \u7cfb\u7edf\u8c03\u7528\u4ece stdin (\u5373\u63a7\u5236\u53f0) \u4e0a\u8bfb\u53d6\u6570\u636e\uff0c\u4f46\u662f\u6b64\u65f6\u7528\u6237\u8fd8\u6ca1\u6709\u8f93\u5165\u4efb\u4f55\u5185\u5bb9\u3002\u64cd\u4f5c\u7cfb\u7edf\u6709\u4e24\u79cd\u9014\u5f84\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\uff1a</p> <ol> <li>\u6682\u65f6\u8ba9\u8be5\u8fdb\u7a0b\u505c\u6b62\uff0c\u7b49\u5230\u63a7\u5236\u53f0\u4e0a\u6709\u6570\u636e\u4e86\u518d\u8fd4\u56de\u3002</li> <li>\u4e00\u76f4\u8f6e\u8be2\u63a7\u5236\u53f0\u8f93\u5165\uff0c\u6709\u8f93\u5165\u4e86\u5c31\u7acb\u523b\u4ece <code>read</code> \u4e2d\u8fd4\u56de\u3002</li> </ol> <p>\u663e\u7136\u7684\uff0c\u7b2c\u4e8c\u79cd\u60c5\u51b5\u5bf9 CPU \u8fd9\u79cd\u5b9d\u8d35\u7684\u8d44\u6e90\u800c\u8a00\u662f\u4e0d\u9ad8\u6548\u7684\u3002\u63a7\u5236\u53f0\u7b49 Input/Output \u64cd\u4f5c\u662f\u6ca1\u6709\u54cd\u5e94\u65f6\u95f4\u4e0a\u7684\u4e0a\u9650\u3002\u4e0e\u5176\u8ba9 CPU \u7a7a\u8f6c\uff0c\u4e0d\u5982\u5148\u5c06 CPU \u51fa\u8ba9\u7ed9\u5176\u4ed6\u8fdb\u7a0b\u6765\u6267\u884c\uff0c\u7b49\u5230\u63a7\u5236\u53f0\u6709\u6570\u636e\u4e86\u518d\u5524\u9192\u539f\u6765\u7684\u8fdb\u7a0b\u3002\u8fd9\u5373\u662f\u6211\u4eec\u4e3a\u4ec0\u4e48\u9700\u8981\u8ba9\u8fdb\u7a0b\u9677\u5165\u7761\u7720\uff1a\u56e0\u4e3a\u6211\u4eec\u7f3a\u4e4f\u67d0\u4e9b\u6761\u4ef6\u7ee7\u7eed\u6267\u884c\u4e0b\u53bb\uff1b\u4e0e\u5176\u6d6a\u8d39 CPU\uff0c\u4e0d\u5982\u7b49\u6ee1\u8db3\u6761\u4ef6\u65f6\u518d\u88ab\u5524\u9192\u3002</p> <p>\u5bf9\u4e8e Console \u8fd9\u6837\u7684\u4f8b\u5b50\u800c\u8a00\uff0c\u7f3a\u4e4f\u7684\u6761\u4ef6\u5c31\u662f\u7528\u6237\u6ca1\u6709\u8f93\u5165\u5185\u5bb9\uff1b\u90a3\u4e48\u5982\u4f55\u5728 Console \u4e0a\u6709\u8f93\u5165\u65f6\u88ab\u5524\u9192\u5462\uff1a\u56de\u60f3\u6211\u4eec\u4e4b\u524d\u7684\u8bfe\u7a0b\uff0c\u6211\u4eec\u5e94\u8be5\u8ba9 Console \u5728\u6709\u6570\u636e\u65f6\u5411 CPU \u53d1\u51fa\u4e2d\u65ad\u3002</p>"},{"location":"lab/xv6lab-userprocess/#sleep-wakeup","title":"sleep &amp; wakeup","text":"<p><code>sleep</code> \u548c <code>wakeup</code> \u51fd\u6570\u7684\u5b9e\u73b0\u5982\u4e0b\uff0c\u6211\u4eec\u4f7f\u7528\u4e00\u4e2a <code>void*</code> \u6307\u9488\u8868\u793a\u4e00\u4e2a\u4efb\u610f\u6570\u636e\uff0c\u5b83\u8868\u793a\u5f53\u524d\u8fdb\u7a0b\u56e0\u4e3a\u4ec0\u4e48\u539f\u56e0\u9677\u5165 <code>SLEEPING</code>\u3002</p> <p><code>sleep</code> \u4f1a\u5c06 <code>curr_proc()-&gt;state</code> \u8bbe\u4e3a <code>SLEEPING</code>\uff0c\u5e76\u8c03\u7528 <code>sched()</code> \u51fd\u6570\u5207\u6362\u5230 scheduler\u3002\u6ce8\u610f\u5230 scheduler \u53ea\u4f1a\u6311\u9009 <code>RUNNABLE</code> \u7684\u8fdb\u7a0b\u6765\u6267\u884c\uff0c\u6240\u4ee5\u5f53\u524d\u8fdb\u7a0b\u518d\u4e5f\u4e0d\u4f1a\u88ab scheduler \u8c03\u5ea6\u5230\u4e86\uff0c\u5373\u5b83\u518d\u4e5f\u4e0d\u4f1a\u7ee7\u7eed\u6267\u884c\u4e86\u3002</p> <p><code>wakeup</code> \u5219\u904d\u5386\u6240\u6709\u8fdb\u7a0b\uff0c\u5982\u679c\u5b83\u7684\u7761\u7720\u539f\u56e0 <code>sleep_chan</code> \u548c\u4f20\u5165\u7684 <code>chan</code> \u76f8\u540c\uff0c\u5219\u5c06\u5176\u91cd\u65b0\u8bbe\u4e3a <code>RUNNABLE</code>\uff0c\u5e76\u4f7f\u5b83\u80fd\u88ab scheduler \u7ee7\u7eed\u6267\u884c\u5230\u3002</p> <pre><code>void sleep(void *chan, spinlock_t *lk) {\n    struct proc *p = curr_proc();\n\n    acquire(&amp;p-&gt;lock);  // DOC: sleeplock1\n    // Go to sleep.\n    p-&gt;sleep_chan = chan;\n    p-&gt;state      = SLEEPING;\n\n    sched();\n    // p get waking up, Tidy up.\n    p-&gt;sleep_chan = 0;\n\n    release(&amp;p-&gt;lock);\n}\nvoid wakeup(void *chan) {\n    for (int i = 0; i &lt; NPROC; i++) {\n        struct proc *p = pool[i];\n        acquire(&amp;p-&gt;lock);\n        if (p-&gt;state == SLEEPING &amp;&amp; p-&gt;sleep_chan == chan) {\n            p-&gt;state = RUNNABLE;\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n</code></pre> <p>lock</p> <p>\u6ce8\u610f\u5230 <code>sleep</code> \u51fd\u6570\u4f1a\u4f20\u5165\u4e00\u628a\u81ea\u65cb\u9501 <code>spinlock_t *lk</code>\uff0c\u5728\u8fd9\u8282\u8bfe\u4e0a\u6211\u4eec\u6682\u4e14\u4e0d\u9700\u8981\u7406\u89e3\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u8bbe\u8ba1\u3002</p>"},{"location":"lab/xv6lab-userprocess/#console","title":"Console","text":"<p>\u4ee5\u63a7\u5236\u53f0\u4e3a\u4f8b\uff0c<code>read</code> \u7cfb\u7edf\u8c03\u7528\u4f1a\u6700\u7ec8\u6765\u5230 <code>os/console.c: user_console_read</code> \u51fd\u6570\u3002\u5982\u679c\u5185\u6838\u4e2d\u7684\u7f13\u51b2\u533a <code>cons.buffer</code> \u4e3a\u7a7a (<code>cons.r == cons.w</code>)\uff0c\u5219\u4ee4\u5f53\u524d\u8fdb\u7a0b\u5728 <code>&amp;cons</code> \u4e0a\u9677\u5165\u7761\u7720\u3002</p> <p>\u5f53\u63a7\u5236\u53f0\u8bbe\u5907\u4e0a\u6709\u53ef\u4ee5\u8bfb\u53d6\u7684\u6570\u636e\u65f6\uff0cConsole \u4f1a\u901a\u8fc7 PLIC \u5411 CPU \u53d1\u8d77\u4e2d\u65ad\uff0c\u5728 <code>trap.c: plic_handle()</code> \u4e2d\uff0c\u6211\u4eec\u901a\u8fc7 <code>irq</code> \u5224\u65ad\u4e2d\u65ad\u662f\u5426\u6765\u81ea\u4e8e Console (UART)\u3002\u5982\u679c\u662f\uff0c\u5219\u5206\u53d1\u5230 <code>uart_intr</code> \u4e2d\u5904\u7406\u3002<code>uart_intr</code> \u4f1a\u4ece UART \u8bbe\u5907\u4e2d\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282 <code>uartgetc</code>\uff0c\u5e76\u8c03\u7528 <code>consintr</code>\uff0c\u5728\u6211\u4eec\u6536\u5230\u4e00\u4e2a <code>\\n</code> \u65f6\uff0c\u6211\u4eec\u5524\u9192\u5728 <code>&amp;cons</code> \u4e0a\u7b49\u5f85\u7684\u8fdb\u7a0b\u3002</p> <pre><code>static void consintr(int c) {\n    if (c == '\\n' || c == C('D') || cons.e - cons.r == INPUT_BUF_SIZE) {\n        // wake up consoleread() if a whole line (or end-of-file)\n        // has arrived.\n        cons.w = cons.e;\n        wakeup(&amp;cons);\n    }\n}\n</code></pre>"},{"location":"lab/xv6lab-userprocess/#_5","title":"\u8bfe\u5802\u62a5\u544a","text":"<ol> <li> <p>\u53c2\u7167 xv6 \u5185\u6838\uff0c\u4ece\u7528\u6237\u7a0b\u5e8f\u8c03\u7528 <code>fork</code> \u7cfb\u7edf\u8c03\u7528\u5f00\u59cb\uff0c\u4f9d\u6b21\u5217\u51fa\u4e4b\u540e\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6267\u884c\u54ea\u4e9b\u91cd\u8981\u51fd\u6570\uff0c\u76f4\u5230\u5b50\u8fdb\u7a0b\u4ece <code>fork</code> \u4e2d\u8fd4\u56de 0 \u4e3a\u6b62\u3002\u8fd9\u4e9b\"\u91cd\u8981\u51fd\u6570\"\u4e3a\u7ba1\u7406\u4ee5\u4e0b\u5b50\u7cfb\u7edf\uff08\u6216\u529f\u80fd\uff09\u7684\u51fd\u6570\uff1aPCB (Process Control Block)\uff0cUser Address Space (only vm.c)\uff0cTrap\uff0cCPU Scheduler\uff0cContext Switch\u3002\u4f60\u53ef\u4ee5\u5047\u8bbe\u51fd\u6570\u8c03\u7528\u6c38\u8fdc\u8fd4\u56de\u6210\u529f\uff0c\u4e0d\u9700\u8981\u8003\u8651\u9519\u8bef\u5904\u7406\u7684\u8def\u5f84\u3002</p> </li> <li> <p>\u586b\u5199\u4e0b\u8868\uff0c\u5c06\u7406\u8bba\u8bfe\u4e0a\u8bb2\u89e3\u7684\u8fdb\u7a0b\u72b6\u6001\u6620\u5c04\u5230 xv6 \u4e2d <code>enum procstate</code> \u7684\u53d6\u503c (<code>struct proc, state</code>)\uff0c\u5e76\u5199\u51fa\u5728\u54ea\u4e9b \u4e8b\u4ef6\u53d1\u751f \u65f6\u72b6\u6001\u4f1a\u53d1\u751f\u8f6c\u53d8\u3002</p> <p>\u6ce8\uff1a\u5de6\u4e0a\u89d2 new \u72b6\u6001\u5bf9\u5e94 <code>procstate</code> \u4e2d\u7684 <code>USED</code>\u3002</p> <p></p> </li> <li> <p>\u5728\u4e0d\u540c\u7684\u8fdb\u7a0b\u4e2d\uff0c\u5b83\u4eec\u7684 Trampoline \u662f\u540c\u4e00\u5f20\u7269\u7406\u9875\u9762\u5417\uff1f\u5b83\u4eec\u7684 Trapframe \u662f\u540c\u4e00\u5f20\u7269\u7406\u9875\u9762\u5417\uff1f</p> <p>\u5728 <code>sh &gt;&gt;</code> \u4e0b\u6267\u884c\u547d\u4ee4 <code>test_arg 123 asd</code>\uff0c<code>sh</code> \u4f1a fork&amp;exec \u542f\u52a8 <code>test_arg</code> \u7a0b\u5e8f\u3002\u5185\u6838\u4e5f\u4f1a\u6253\u5370 <code>test_arg</code> \u7684\u9875\u8868\u3002\u89c2\u5bdf\u5b83\u7684\u9875\u8868\u548c <code>sh</code> \u7684\u9875\u8868\u4e2d\u7684 Trapframe \u548c Trampoline\u3002</p> </li> <li> <p>\u5728\u4f7f\u7528 <code>exec</code> \u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u6211\u4eec\u4f1a\u4f20\u5165\u8fdb\u7a0b\u7684\u53c2\u6570\uff0c\u5373 <code>int exec(char *path, char *argv[])</code>\u3002\u6211\u4eec\u4f1a\u5728 <code>main</code> \u51fd\u6570\u4e2d\u6536\u5230 <code>argv</code> \u6570\u7ec4\uff1a<code>int main(int argc, char *argv[])</code>\uff0c\u5176\u4e2d <code>argv</code> \u662f\u4e00\u4e2a <code>char*</code> \uff08\u5b57\u7b26\u4e32\u6307\u9488\uff09\u7684\u6570\u7ec4\uff0c\u5b83\u7684\u6700\u540e\u4e00\u9879\u662f NULL\uff0c<code>argc</code> \u8868\u793a\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u6709\u591a\u5c11\u4e2a\u5b57\u7b26\u4e32\u6307\u9488\u3002</p> <p>\u6211\u4eec\u77e5\u9053 <code>exec</code> \u4f1a\u5220\u9664\u6240\u6709\u5185\u5b58\u6620\u5c04\u3002\u90a3\u4e48\uff0c\u65e7\u8fdb\u7a0b\u8fdb\u884c <code>exec</code> \u7cfb\u7edf\u8c03\u7528\u65f6\u4f20\u5165\u7684 <code>argv</code> \u662f\u600e\u4e48\u4f20\u5165\u5230\u65b0\u8fdb\u7a0b\u7684\uff1f</p> <p>Hint: \u5728 <code>make run</code> \u540e\uff0capplists \u4e2d\u6709 <code>test_arg</code>\u3002\u4f60\u53ef\u4ee5\u5728 <code>sh &gt;&gt;</code> \u4e2d\u6d4b\u8bd5\u5b83\u3002</p> <p>Debugger \u6559\u7a0b\uff1a\u4f7f\u7528 <code>make debug</code> \u8fd0\u884c\u5e26\u8c03\u8bd5\u5668\u7684 QEMU\uff0c\u4f7f\u7528 <code>gdb-multiarch</code> \u8fde\u63a5 QEMU\uff0c\u5148\u4f7f\u7528\u4e24\u6b21 <code>continue</code> \u4f7f\u5185\u6838\u8fd0\u884c\u5230 <code>sh &gt;&gt;</code> \u63d0\u793a\u7b26\u3002</p> <p></p> <p>\u5728 gdb \u4e2d\u6309 Ctrl+C \u4e2d\u65ad\uff0c\u4f7f\u7528 <code>add-symbol-file user/build/test_arg</code> \u6dfb\u52a0\u7528\u6237\u7a0b\u5e8f\u7684\u8c03\u8bd5\u7b26\u53f7\uff0c\u6267\u884c <code>b main</code> \u5728\u7528\u6237\u7a0b\u5e8f\u7684 <code>main</code> \u51fd\u6570\u6253\u65ad\u70b9\u3002</p> <p></p> <p>\u6267\u884c <code>continue</code> \u7ee7\u7eed\u8fd0\u884c\u5185\u6838\u3002\u5728\u5185\u6838\u547d\u4ee4\u884c\u8f93\u5165 <code>test_arg asdf asfkjls asf</code>\uff08\u540e\u9762\u5185\u5bb9\u968f\u4fbf\u6572\uff09\u7136\u540e\u56de\u8f66\u6267\u884c\uff0c\u4f60\u5e94\u8be5\u80fd\u5728 gdb \u4e2d\u6536\u5230\u4f4d\u4e8e\u7528\u6237\u8fdb\u7a0b\u7684\u65ad\u70b9\u3002</p> <p></p> <p>\u4f7f\u7528 <code>stack -l 20</code> \u89c2\u5bdf\u6b64\u65f6\u6808\u4e0a\u7684\u5185\u5bb9\u3002\uff08\u6ce8\u610f <code>0xffff0000</code> \u5f80\u540e\u7684\u5730\u5740\u662f\u672a\u6620\u5c04\u7684\uff09\uff0c\u53f3\u4fa7 <code>a1</code> \u8868\u793a <code>a1</code> \u5bc4\u5b58\u5668\u7684\u503c\u4e3a\u8be5\u5730\u5740 <code>0x00000000fffefff0</code>\u3002</p> <pre><code>(qemu) gef\u27a4  stack -l 20\n0x00000000fffeff70\u2502+0x0000: 0x00000000fffeffd0  \u2192  0x0000000000006466  \u2192  0x0000000000006466     \u2190 $sp\n0x00000000fffeff78\u2502+0x0008: 0x000000000040234c  \u2192  0x02813c8303813b83  \u2192  0x02813c8303813b83\n0x00000000fffeff80\u2502+0x0010: 0x00000000fffefff0  \u2192  0x6772615f74736574  \u2192  0x6772615f74736574     \u2190 $fp, $a1\n0x00000000fffeff88\u2502+0x0018: 0x00000000fffeffe8  \u2192  0x0000343135343131  \u2192  0x0000343135343131\n0x00000000fffeff90\u2502+0x0020: 0x00000000fffeffe0  \u2192  0x0030313839313931  \u2192  0x0030313839313931\n0x00000000fffeff98\u2502+0x0028: 0x00000000fffeffd8  \u2192  0x0066647361667361  \u2192  0x0066647361667361\n0x00000000fffeffa0\u2502+0x0030: 0x00000000fffeffc8  \u2192  0x7361667361667361  \u2192  0x7361667361667361\n0x00000000fffeffa8\u2502+0x0038: 0x00000000fffeffb8  \u2192  0x7769756168667361  \u2192  0x7769756168667361\n0x00000000fffeffb0\u2502+0x0040: 0x0000000000000000  \u2192  0x0000000000000000\n0x00000000fffeffb8\u2502+0x0048: 0x7769756168667361  \u2192  0x7769756168667361\n0x00000000fffeffc0\u2502+0x0050: 0x000000006b666265  \u2192  0x000000006b666265\n0x00000000fffeffc8\u2502+0x0058: 0x7361667361667361  \u2192  0x7361667361667361\n0x00000000fffeffd0\u2502+0x0060: 0x0000000000006466  \u2192  0x0000000000006466\n0x00000000fffeffd8\u2502+0x0068: 0x0066647361667361  \u2192  0x0066647361667361\n0x00000000fffeffe0\u2502+0x0070: 0x0030313839313931  \u2192  0x0030313839313931\n0x00000000fffeffe8\u2502+0x0078: 0x0000343135343131  \u2192  0x0000343135343131\n0x00000000fffefff0\u2502+0x0080: 0x6772615f74736574  \u2192  0x6772615f74736574\n0x00000000fffefff8\u2502+0x0088: 0x0000000000000000  \u2192  0x0000000000000000\n</code></pre> <p>\u6ce8\u610f\u5230 <code>0x7769756168667361</code> \u8fd9\u6837\u7684\u6570\u5b57\u50cf\u662f ASCII \u7801\uff0c\u4f7f\u7528 <code>x/60s $sp</code> \u6253\u5370\u6808\u4e0a\u50cf\u662f\u5b57\u7b26\u4e32\u7684\u4e1c\u897f\u3002</p> <p>\u6ce8\uff1a\u5728\u8ba1\u7b97\u673a\u5e95\u5c42\u4e2d\uff0c\u201c\u5b57\u7b26\u4e32\u201d \u662f\u4ee5 0x00 \u7ed3\u5c3e\u7684\u4e00\u4e32\u5b57\u8282\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-userprocess/#_6","title":"\u63a8\u8350\u9605\u8bfb","text":"<ol> <li> <p>Trampoline \u548c Trapframe \u7684\u7269\u7406\u9875\u9762\u662f\u54ea\u91cc\u6765\u7684\uff1f</p> <p>\u53c2\u7167\u4e0a\u8ff0\u6211\u4eec\u6253\u5370\u7684 <code>sh</code> \u8fdb\u7a0b\u7684\u7528\u6237\u9875\u8868\uff0c\u6ce8\u610f\u5176\u4e2d\u6700\u540e\u4e24\u6761\u6620\u5c04\u7684\u7269\u7406\u5730\u5740\uff1a</p> <pre><code>[ff], pte[0xffffffc080b147f8]: 0x0000003fc0000000 -&gt; 0x0000000080b15000 -------V\n[1ff], pte[0xffffffc080b15ff8]: 0x0000003fffe00000 -&gt; 0x0000000080b16000 -------V\n    [1fe], pte[0xffffffc080b16ff0]: 0x0000003fffffe000 -&gt; 0x0000000080b17000 DA---WRV\n    [1ff], pte[0xffffffc080b16ff8]: 0x0000003ffffff000 -&gt; 0x000000008020b000 -A--X-RV\n</code></pre> <p>\u53c2\u7167 \"Week 6 - \u5185\u6838\u9875\u8868 Kernel Paging\" \u4e2d\u7684 \"xv6 \u5185\u6838\u5185\u5b58\u5e03\u5c40\" \u4e00\u7ae0\uff0c\u627e\u51fa\u8fd9\u4e24\u4e2a\u7269\u7406\u5730\u5740\u5206\u522b\u4f4d\u4e8e\u54ea\u4e2a\u7269\u7406\u5730\u5740\u533a\u57df\u3002\u5bf9\u7167\u6e90\u4ee3\u7801 <code>trampoline.S</code> \u548c linker script <code>os/kernel.ld</code> \u9a8c\u8bc1\u4f60\u7684\u7b54\u6848\u3002</p> </li> <li> <p>\u56de\u987e\u4e0a\u5468\u7684\u8bfe\u5802\u62a5\u544a\u95ee\u9898\uff1aTrapframe \u548c Trampoline \u662f\u4e24\u4e2a\u9875\u9762\uff0c\u8fd9\u4e24\u4e2a\u9875\u9762\u5e94\u8be5\u5141\u8bb8 U-mode \u8bbf\u95ee\u5417\uff1f</p> <p>\u8bf7\u4f60\u4eb2\u81ea\u505a\u5b9e\u9a8c\u9a8c\u8bc1\u3002</p> <p>\u5bf9\u4e8e Trampoline\uff0c\u4fee\u6539 <code>kvm.c</code> \u4e2d <code>kvmmake</code> \u51fd\u6570\uff0c\u8c03\u7528 <code>kvmmap</code> \u6620\u5c04 trampoline \u5904\uff0c\u5728\u6743\u9650\u4e2d OR \u4e0a PTE_U\u3002</p> <p>\u5bf9\u4e8e Trapframe\uff0c\u4fee\u6539 <code>proc.c</code> \u4e2d <code>allocproc</code> \u4e2d\uff0c\u8c03\u7528 <code>mm_mappage_at</code> \u51fd\u6570\u5904\uff0c\u5728\u6743\u9650\u4e2d OR \u4e0a PTE_U\u3002\uff1a</p> <p>\u4f7f\u7528 <code>make debug</code> \u4ee5\u53ca <code>gdb-multiarch</code> \u6302\u8f7d\u8c03\u8bd5\u5668\u3002\u4f7f\u7528 <code>b kernel_trap_entry</code> \u548c <code>b *0x3ffffff000</code> \u5728\u5185\u6838 Trap \u5165\u53e3\u5904\u548c <code>uservec</code> \u5904\u6253\u65ad\u70b9\uff0c\u4f7f\u7528 <code>print $scause</code> \u624b\u52a8\u67e5\u770b Trap \u76f8\u5173\u7684 CSR\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-userspace/","title":"\u7528\u6237\u7a7a\u95f4","text":"<p>\u7528\u6237\u7a7a\u95f4 (Userspace) \u662f\u64cd\u4f5c\u7cfb\u7edf\u4e3a\u7528\u6237\u7a0b\u5e8f\u63d0\u4f9b\u7684\u4e00\u4e2a\u53d7\u9650\u5236\u7684\u8fd0\u884c\u73af\u5883\u3002\u64cd\u4f5c\u7cfb\u7edf\u901a\u8fc7 CPU \u7684\u786c\u4ef6\u529f\u80fd\u8f85\u52a9\u6765\u5b9e\u73b0\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7684\u9694\u79bb\uff0c\u8fd9\u901a\u5e38\u5305\u62ec\uff1a</p> <ul> <li>\u7279\u6743\u7ea7\u7684\u9694\u79bb\u3002\u7528\u6237\u7a7a\u95f4\u4e00\u822c\u4f7f\u7528\u4f4e\u7279\u6743\u7ea7\u8fd0\u884c\uff0c\u4f7f\u7528\u9ad8\u7279\u6743\u7ea7\u6307\u4ee4\u4f1a\u89e6\u53d1\u5f02\u5e38\u3002</li> <li>\u5185\u5b58\u7a7a\u95f4\u7684\u9694\u79bb\u3002\u5185\u6838\u901a\u8fc7\u9875\u8868\u4e3a\u7528\u6237\u7a7a\u95f4\u8bbe\u7f6e\u5730\u5740\u7a7a\u95f4\uff0c\u800c\u7528\u6237\u7a7a\u95f4\u4e0d\u80fd\u76f4\u63a5\u8bbf\u95ee\u5185\u6838\u5730\u5740\u3002</li> </ul>"},{"location":"lab/xv6lab-userspace/#_2","title":"\u5b9e\u9a8c\u76ee\u7684","text":"<ol> <li>\u638c\u63e1\u5982\u4f55\u5efa\u7acb\u7528\u6237\u7a7a\u95f4</li> <li>\u638c\u63e1trampoline\u539f\u7406</li> <li>\u7406\u89e3\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\u7684\u6267\u884c\u8fc7\u7a0b</li> <li>\u7406\u89e3uaccess\u7684\u4f5c\u7528</li> </ol>"},{"location":"lab/xv6lab-userspace/#_3","title":"\u6982\u89c8","text":"<p>\u672c\u6b21 Lab \u4e2d\uff0c\u6211\u4eec\u5c06\u7b2c\u4e00\u6b21\u628a CPU \u8fd0\u884c\u5728 U-mode\uff0c\u5e76\u8fd0\u884c\u7b2c\u4e00\u4e2a\u7528\u6237\u7a0b\u5e8f\u3002</p> <p>\u5728\u7b2c\u4e00\u6b21\u4f5c\u4e1a\u4e2d\uff0c\u6211\u4eec\u4eb2\u81ea\u5b9e\u9a8c\u53d1\u73b0\uff0c\u5982\u679c CPU \u5728\u6267\u884c <code>sret</code> \u65f6 <code>sstatus.SPP == 0</code>\uff0c\u90a3\u4e48 CPU \u5c06\u964d\u7ea7\u5230 U-mode\u3002 \u5f53 CPU \u964d\u7ea7\u5230 U-mode \u540e\uff0cCPU \u53ea\u80fd\u901a\u8fc7 Trap \u56de\u5230 S-mode\u3002\u800c Trap \u5206\u4e3a\u4e24\u79cd\uff1a\u5f02\u5e38\uff08Exception\uff09\u548c\u4e2d\u65ad\uff08Interrupt\uff09\u3002</p> <ul> <li>\u7528\u6237\u7a0b\u5e8f\u53ef\u4ee5\u4e3b\u52a8\u5730\u4f7f\u7528 <code>ecall</code> \u53d1\u8d77\u4e00\u79cd\u5f02\u5e38 Exception: Code 8 (Environment call from U-mode)\uff0c\u8fd9\u5c31\u662f RISC-V \u5e73\u53f0\u4e0a\u5b9e\u73b0\u7cfb\u7edf\u8c03\u7528\uff08syscall\uff09\u7684\u65b9\u5f0f\u3002</li> <li>U-mode \u4e0b\uff0c\u4e2d\u65ad\u6c38\u8fdc\u662f\u5f00\u542f\u7684\u3002\u56de\u987e <code>Trap, Exception and Interrupt</code> \u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5bf9 <code>\u4e2d\u65ad\u5230\u6765\u65f6\uff0c\u80fd\u5426\u8fdb\u5165 Trap</code> \u8fd9\u4ef6\u4e8b\u60c5\u7684\u63cf\u8ff0\uff1a\uff08\u5f53\u524d\u8fd0\u884c\u5728 S \u6a21\u5f0f\uff0c\u4e14 <code>sstatus.SIE</code> == 1\uff09 \u6216\u8005 \u5f53\u524d\u8fd0\u884c\u5728 U \u6a21\u5f0f\u3002</li> </ul> <p>\u5f53\u4f60\u5b8c\u6210\u8fd9\u8282 Lab \u4e2d\u6240\u63cf\u8ff0\u7684\u7ec6\u8282\u540e\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u4e0b\u56fe\u7406\u89e3 xv6 \u4e2d\u7684 userspace \u7ed3\u6784\u3002</p> <p>\u4e0b\u56fe\u4e2d\uff0c\u84dd\u8272\u65b9\u5757\u8868\u793a\u7531 <code>kallocpage</code> \u5206\u914d\u7684\u9875\u9762\uff0c\u9ec4\u8272\u65b9\u5757\u8868\u793a\u5185\u6838\u4e2d\u7684\u4ee3\u7801\uff0c\u7eff\u8272\u65b9\u5757\u8868\u793a Trampoline \u4e2d\u7684\u4ee3\u7801\u3002\u8be5\u56fe\u5c55\u793a\u4e86\u5185\u6838\u4e2d\u7684\u4f17\u591a\u6570\u636e\u7ed3\u6784\u4e4b\u95f4\u7684\u6307\u9488\u5173\u7cfb\uff08\u9ed1\u8272\u7bad\u5934\uff09\uff0c\u4ee5\u53ca\u5185\u6838\u6001\u7528\u6237\u6001\u4e4b\u95f4\u8fdb\u884c\u5207\u6362\u65f6\u7684\u4ee3\u7801\u8c03\u7528\u8fc7\u7a0b\uff08\u7ea2\u8272\u865a\u7ebf\u7bad\u5934\uff09\u3002</p> <p></p> <p>xv6-lab5 \u4ee3\u7801\u5206\u652f</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab5</p> <p>\u4f7f\u7528\u547d\u4ee4 <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab5 xv6lab5</code> \u4e0b\u8f7d xv6-lab5 \u4ee3\u7801\u3002</p> <p>\u4f7f\u7528 <code>make run</code> \u8fd0\u884c\u672c\u6b21 Lab \u7684\u5185\u6838\uff0c\u5b83\u4f1a\u542f\u52a8\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b <code>init</code>\uff0c\u5176\u6e90\u4ee3\u7801\u4e3a <code>user/src/init.c</code>\u3002</p>"},{"location":"lab/xv6lab-userspace/#_4","title":"\u7528\u6237\u6001\u548c\u5185\u6838\u6001\u7684\u5207\u6362","text":"<p>RISC-V CPU \u8fd0\u884c\u65f6\u4f1a\u5904\u4e8e\u67d0\u4e2a\u7279\u6743\u7ea7\u72b6\u6001\u3002\u64cd\u4f5c\u7cfb\u7edf\u8fd0\u884c\u5728 S mode\uff0c\u800c\u7528\u6237\u6a21\u5f0f\u5904\u4e8e U mode\u3002</p> <p>\u6211\u4eec\u5c06\u5206\u522b\u8bb2\u89e3\u5982\u4f55\u4ece S mode \u964d\u7ea7\u5230 U mode\uff0c\u4ee5\u53ca\u5982\u4f55\u4ece U mode \u56de\u5230 S mode\u3002</p>"},{"location":"lab/xv6lab-userspace/#kernel-user","title":"Kernel -&gt; User","text":"<p>\u5728 Interrupts \u4e00\u7ae0\u4e2d\uff0c\u6211\u4eec\u5b66\u4e60\u4e86 sret \u6307\u4ee4\u5b8c\u6210\u7684\u4e09\u4ef6\u4e8b\u60c5\uff1a</p> <ol> <li>sstauts.SIE &lt;= sstatus.SPIE</li> <li>Current_Privilege_Level &lt;= sstauts.SPP</li> <li>pc &lt;= epc</li> </ol> <p>\u7528\u4e2d\u6587\uff1a\u8fd8\u539f <code>sstatus.SIE</code> \u4e3a <code>sstatus.SPIE</code>\uff0c\u5c06\u7279\u6743\u7ea7(U/S)\u8bbe\u7f6e\u4e3a <code>sstauts.SPP</code>\uff0c\u5c06 PC \u8bbe\u7f6e\u4e3a <code>sepc</code>\u3002</p> <p>\u5728 CSR <code>sstatus</code> \u4e2d\uff0c<code>SPP</code> \u7684\u63cf\u8ff0\u5982\u4e0b\uff1a</p> <p>The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction (see Section 3.3.2) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.</p> <p>\u6240\u4ee5\u8bf4\uff0c\u53ea\u8981\u5728 <code>sret</code> \u6267\u884c\u65f6\uff0c<code>sstatus.SPP</code> \u4e3a 0\uff0c\u6211\u4eec\u5373\u53ef\u964d\u7ea7\u5230 U mode \u4e0b\u3002\uff08\u8fd9\u5176\u5b9e\u5e76\u4e0d\u8981\u6c42\u6211\u4eec\u4e00\u5b9a\u5904\u4e8e Trap Handler \u4e2d\uff09</p>"},{"location":"lab/xv6lab-userspace/#user-kernel","title":"User -&gt; Kernel","text":"<p>\u82e5 CPU \u8fd0\u884c\u5728 U mode \u4e0b\uff0cCPU \u901a\u8fc7\u89e6\u53d1 Trap \u6765\u56de\u5230 S mode\uff0c\u8fd9\u901a\u5e38\u5305\u62ec\uff1a</p> <ul> <li>\u4e2d\u65ad\u3002\u5305\u542b\u65f6\u949f\u4e2d\u65ad\u3001\u5916\u90e8\u4e2d\u65ad\u7b49\u3002</li> <li> <p>\u5f02\u5e38\u901a\u5e38\u5305\u62ec\uff1a</p> <ul> <li>Illegal Instruction</li> <li>(Load, Store, Fetch) Page Fault</li> <li>Environment call (\u8fd9\u662f RISC-V \u7684 syscall \u65b9\u5f0f\uff0c \u5373 ecall )</li> </ul> </li> </ul> <p>\u5f53\u9700\u8981\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u7528\u6237\u7a0b\u5e8f\u53ef\u4ee5\u4f7f\u7528 <code>ecall</code> \u6307\u4ee4\u4e3b\u52a8\u89e6\u53d1\u4e00\u6b21 Trap\uff0c\u800c\u8fd9\u5c06\u4f7f CPU \u901a\u8fc7 Trap \u56de\u5230 S mode.</p> <p>ecall</p> <p>\u8fd8\u8bb0\u5f97\u5417\uff0c\u4e4b\u524d\u6211\u4eec\u66fe\u5728 S mode \u4f7f\u7528 <code>ecall</code> \u6307\u4ee4\u8c03\u7528 M mode \u63d0\u4f9b\u7684\u63a5\u53e3\u3002</p> <p>\u73af\u5883\u8c03\u7528\u5373\u901a\u8fc7\u5f15\u53d1\u73af\u5883\u8c03\u7528\u5f02\u5e38\u6765\u8bf7\u6c42\u6267\u884c\u73af\u5883\u3002</p>"},{"location":"lab/xv6lab-userspace/#_5","title":"\u7528\u6237\u9875\u8868 / \u5185\u6838\u9875\u8868","text":"<p>\u5728\u4e0a\u4e00\u8282 Lab \u4e2d\uff0c\u6211\u4eec\u4ecb\u7ecd\u4e86 RISC-V \u7684\u9875\u8868\u6a21\u578b\uff0c\u5e76\u4e14\u4e3a\u5185\u6838\u8bbe\u7f6e\u4e86\u9875\u8868\u3002\u5728 PTE \u4e2d\u7684\u7b2c 4 \u4e2a bit U \u8868\u793a\u8be5\u6620\u5c04\u5173\u7cfb\u662f\u5426\u5141\u8bb8\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u8bbf\u95ee\u3002</p> <p>\u672c\u6b21lab\u4e2d\uff0c\u6211\u4eec\u5f15\u5165\u7528\u6237\u7a7a\u95f4\uff0c\u7528\u6237\u8fdb\u7a0b\u9700\u8981\u8fd0\u884c\u5728\u7528\u6237\u7a7a\u95f4\u4e0a\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u5c06 512 GiB \u7684\u5730\u5740\u5207\u5206\u4e3a\u7528\u6237\u5730\u5740\uff08\u4f4e\u5730\u5740\uff09\u548c\u5185\u6838\u5730\u5740\uff08\u9ad8\u5730\u5740\uff09\uff0c\u7528\u6237\u5730\u5740\u4e3a <code>0x0000_00</code> \u5f00\u5934\uff0c\u800c\u5185\u6838\u5730\u5740\u4ee5 <code>0xffff_ff</code> \u5f00\u5934\u3002</p> <p>\u6bcf\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\u90fd\u9700\u8981\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u6240\u4ee5\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u7528\u6237\u7a0b\u5e8f\uff0c\u6211\u4eec\u90fd\u4e3a\u5b83\u521b\u5efa\u4e00\u4e2a\u5355\u72ec\u7684\u9875\u8868\u3002\u6211\u4eec\u5c06\u5176\u79f0\u4e3a \u7528\u6237\u9875\u8868 \u3002</p> <p>\u5728 xv6 \u4e2d\uff0c\u7528\u6237\u9875\u8868\u5e76\u4e0d\u5305\u542b\u5185\u6838\u9875\u8868\u9879\u76ee\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e0d\u5305\u542b\u5185\u6838\u955c\u50cf\u7684\u4ee3\u7801\u3001\u6570\u636e\u548c Direct Mapping \u7b49\u3002\u90a3\u4e48\u5728\u9700\u8981\u5728 S mode \u548c U mode \u4e4b\u524d\u5207\u6362\u65f6\uff0c\u5c31\u4ea7\u751f\u4e86\u4e00\u4e2a\u95ee\u9898\uff1a</p> <p>\u60f3\u8c61\u4e00\u4e0b\uff0c\u76ee\u524d\u7528\u6237\u8fdb\u7a0b\u4f7f\u7528\u7684\u662f\u7528\u6237\u9875\u8868\uff0c\u6b64\u65f6\u5728\u7528\u6237\u8fdb\u7a0b\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f\u4e86\u4e00\u4e2a Trap \uff0c\u5c06\u8981\u8fdb\u5165 S mode \u3002\u800c\u5728\u8fdb\u5165 Trap Handler \u524d\uff0cCPU \u9700\u8981\u5c06 pc \u8df3\u8f6c\u4e3a <code>stvec</code>\uff0c\u4f46\u662f\u6b64\u65f6 CPU \u4ecd\u7136\u8fd8\u4f7f\u7528\u7740\u539f\u6765\u7684 <code>satp</code>\uff0c\u5373 U mode \u65f6\u6240\u7528\u7684\u7528\u6237\u9875\u8868\uff0c\u8be5\u9875\u8868\u5e76\u4e0d\u5305\u542b\u5185\u6838\u7a7a\u95f4\u7684\u5730\u5740\u6620\u5c04\uff0c\u5373\u5185\u6838\u7684\u4e2d\u65ad\u5904\u7406\u5165\u53e3\u51fd\u6570\u7684\u5730\u5740 <code>stvec</code> \u5728\u7528\u6237\u7a7a\u95f4\u4e0b\u662f\u4e0d\u53ef\u7528\u7684\u3002\u8fd9\u5c31\u51fa\u73b0\u4e86\u95ee\u9898\u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u5728 U mode \u4e0b\u4f7f\u7528\u5185\u6838\u6240\u7528\u7684 <code>stvec</code> (<code>0xffff_ffff_8020_xxxx</code>)\u3002\u8fd9\u4e2a\u95ee\u9898\u4e0e\u6211\u4eec\u5728\u5b9e\u73b0 Relocation \u65f6\u6240\u9047\u5230\u7684\u95ee\u9898\u7c7b\u4f3c\u3002</p> <p>\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u4e3a U mode \u8bbe\u7f6e\u4e00\u4e2a\u4e13\u95e8\u7684 Trap Handler\uff0c\u5e76\u4e14\uff0c\u6211\u4eec\u4f7f\u5176\u5728\u5185\u6838\u9875\u8868\u548c\u7528\u6237\u9875\u8868\u4e2d\u90fd\u5177\u6709 \u76f8\u540c\u7684\u865a\u62df\u5730\u5740 \u3002\u8fd9\u6837\uff0c\u6211\u4eec\u5728\u4ece U mode \u901a\u8fc7 Trap \u56de\u5230 S mode \u65f6\uff0c\u80fd\u5728\u5185\u6838\u6001 + \u7528\u6237\u9875\u8868\u7684\u73af\u5883\u4e0b\u6267\u884c\u4ee3\u7801\u3002</p> <p>\u6211\u4eec\u5c06\u5305\u542b\u8fd9\u6bb5\u4ee3\u7801\u7684\u7279\u6b8a\u9875\u9762\u79f0\u4e3a Trampoline\uff0c\u5e76\u5c06\u5176\u6620\u5c04\u5230 <code>0x0000_003f_ffff_f000</code>\u3002</p>"},{"location":"lab/xv6lab-userspace/#trampoline-trampolines","title":"Trampoline \uff08trampoline.S\uff09","text":"<p>Trampoline n. \u8e66\u5e8a</p> <p>\u5728 xv6 \u4e2d\uff0cTrampoline \u662f\u4e24\u6bb5\u7279\u6b8a\u7684\u4ee3\u7801 <code>uservec</code> \u548c <code>userret</code>\uff0c\u5206\u522b\u7528\u4e8e\u4ece\u7528\u6237\u6001\u5207\u6362\u56de\u5185\u6838\u6001\uff08\u5373\u7528\u6237\u6001\u4e0b\u7684 <code>stvec</code>\uff09\uff0c\u548c\u4ece\u5185\u6838\u5207\u6362\u5230\u7528\u6237\u6001\u3002</p> <p>Trampoline \u7684\u865a\u62df\u5730\u5740 <code>0x0000_003f_ffff_f000</code> \u5728 \u5185\u6838\u9875\u8868\u548c\u6bcf\u4e2a\u7528\u6237\u9875\u8868 \u4e2d\u90fd\u662f\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u653e\u5fc3\u7684\u5207\u6362\u7528\u6237\u548c\u5185\u6838\u7684 <code>satp</code> \u800c\u4e0d\u7528\u62c5\u5fc3\u5f53\u524d pc \u4f1a\u53d8\u5f97\u975e\u6cd5\u4e86\uff08\u56de\u5fc6\u6211\u4eec\u5728\u4e0a\u4e00\u7ae0 Relocation \u4e2d\u9047\u5230\u7684\u95ee\u9898\uff09\u3002</p>"},{"location":"lab/xv6lab-userspace/#trampoline-","title":"Trampoline - \u7528\u6237\u6001\u5230\u5185\u6838\u6001","text":"<p>\u5f53\u6211\u4eec\u9700\u8981\u4ece U mode \u8fdb\u5165 S mode\uff08\u901a\u8fc7 Trap \uff09\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 <code>uservec</code> \u5207\u6362\u5185\u6838\u9875\u8868\uff0c\u5e76\u8fd0\u884c\u7528\u6237\u7684 Trap Handler -- usertrap \u3002</p>"},{"location":"lab/xv6lab-userspace/#uservectrampolines","title":"uservec\uff08trampoline.S\uff09","text":"<pre><code>    .section trampsec\n.globl trampoline\ntrampoline:\n\n.globl uservec\nuservec:\n        # trap.c sets stvec to point here, so\n        # traps from user space start here,\n        # in supervisor mode, but with a user page table.\n        #\n        # sscratch points to where the process's p-&gt;trapframe is\n        # mapped into user space, at TRAPFRAME.\n\n    # swap a0 and sscratch, so that a0 is TRAPFRAME\n        csrrw a0, sscratch, a0\n\n        # save the user registers (x1 - x31) in TRAPFRAME\n        sd ra, 40(a0)\n        sd sp, 48(a0)\n        # ...\n        sd t5, 272(a0)\n        sd t6, 280(a0)\n\n        # we have saved t0, so we can smash it\n        # resotre a0 from sscratch, and save it\n        csrr t0, sscratch\n        sd t0, 112(a0)\n\n        # save epc\n        csrr t1, sepc\n        sd t1, 24(a0)\n\n        # load kernel's satp, sp, usertrap handler, tp(cpuid)\n        ld t1, 0(a0)\n        ld sp, 8(a0)\n        ld t0, 16(a0)\n        ld tp, 32(a0)\n\n        csrw satp, t1\n        sfence.vma zero, zero\n\n        jr t0\n</code></pre> <p>\u5728 Trampoline \u7684 <code>uservec</code> \u4e2d\uff0c\u6240\u6709 GPR (x1-x31) \u5747\u4e3a\u7528\u6237\u7a0b\u5e8f\u6b63\u5728\u4f7f\u7528\u7684\uff0c\u6211\u4eec\u9700\u8981\u5728\u6267\u884c <code>userret</code> \u4e2d\u7684 <code>sret</code> \u65f6\u4fdd\u6301\u6240\u6709 GPR \u4e0e\u6211\u4eec\u8fdb\u5165 <code>uservec</code> \u65f6\u4e00\u81f4\uff0c\u8fd9\u4e2a\u8981\u6c42\u4e0e\u6211\u4eec\u5904\u7406\u5185\u6838 Trap \u65f6\u662f\u4e00\u81f4\u7684\u3002</p> <p>\u5728\u5904\u7406\u5185\u6838\u7684 Trap \u65f6\uff0c\u6211\u4eec\u76f4\u63a5\u5728\u5185\u6838\u6808\u4e0a\u6784\u5efa\u4e86 <code>struct ktrapframe</code> \u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u4fdd\u5b58\u6240\u6709 GPR\u3002\u7c7b\u4f3c\u7684\uff0c\u6211\u4eec\u5c06\u4fdd\u5b58\u7528\u6237\u5bc4\u5b58\u5668\u7684\u5730\u65b9\u79f0\u4e3a <code>Trapframe</code> \uff0c\u5927\u5c0f\u5c0f\u4e8e\u4e00\u4e2a\u9875\u9762\u3002\u5e76\u4e14\uff0c\u6211\u4eec\u5c06\u5176\u6620\u5c04\u5230\u7528\u6237\u9875\u8868\u4e2d\u7684\u4e00\u4e2a\u56fa\u5b9a\u5730\u5740 <code>0x0000_003f_ffff_e000</code> \uff0c\u5373 trampoline \u4e0b\u4e00\u4e2a\u9875\u9762\u3002</p> <p><code>struct trapframe</code> \u5b9a\u4e49\u5728 <code>proc.h</code> \u4e2d\uff1a</p> <pre><code>struct trapframe {\n    /*   0 */ uint64 kernel_satp;    // kernel page table\n    /*   8 */ uint64 kernel_sp;      // top of process's kernel stack\n    /*  16 */ uint64 kernel_trap;    // usertrap()\n    /*  24 */ uint64 epc;            // saved user program counter\n    /*  32 */ uint64 kernel_hartid;  // saved kernel tp\n    /*  40 */ uint64 ra;\n    /*  48 */ uint64 sp;\n    /*  ... */\n    /* 272 */ uint64 t5;\n    /* 280 */ uint64 t6;\n};\n</code></pre> <p>\u7531\u4e8e RISC-V \u7684\u6307\u4ee4\u7684 destination \u5747\u4e3a\u5bc4\u5b58\u5668\uff0c\u4e0d\u80fd\u662f\u7acb\u5373\u6570\uff0c\u800c\u6211\u4eec\u5728\u4fdd\u5b58\u7528\u6237\u5bc4\u5b58\u5668\u524d\u4e0d\u80fd\u4fee\u6539\u5bc4\u5b58\u5668\u7684\u5185\u5bb9\uff0c\u6240\u4ee5\u6211\u4eec\u8d77\u7801\u9700\u8981\u4e00\u4e2a\u80fd\u4fee\u6539\u7684\u5bc4\u5b58\u5668\u6765\u8868\u793a <code>0x0000_003f_ffff_e000</code> \u8fd9\u4e2a trapframe \u7684\u5730\u5740\u3002RISC-V \u63d0\u4f9b\u4e86\u4e00\u4e2a <code>sscratch</code> \u5bc4\u5b58\u5668\u6765\u7ed9 Trap Handler \u4e00\u4e2a\u6682\u5b58\u5bc4\u5b58\u5668\u7684\u5730\u65b9\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>csrrw a0, sscratch, a0</code> \u4ea4\u6362 <code>sscratch</code> \u548c <code>a0</code> \u5bc4\u5b58\u5668\u3002\u8fd9\u6837\uff0c\u7528\u6237\u7684 a0 \u5bc4\u5b58\u5668\u5c31\u88ab\u4fdd\u5b58\u5230\u4e86 <code>sscratch</code> \u4e2d\uff0c\u800c <code>sscratch</code> \u4e2d\u7684\u5185\u5bb9\u5c31\u6765\u5230 <code>a0</code> \u4e2d\u3002</p> <p>\u6211\u4eec\u89c4\u5b9a\uff0c\u5728\u64cd\u4f5c\u7cfb\u7edf\u521d\u59cb\u5316\u5b8c\u6210\u540e\uff0c <code>sscratch</code> \u5bc4\u5b58\u5668\u4fdd\u5b58\u7740\u7528\u6237\u9875\u8868\u4e2d Trapframe \u6240\u6620\u5c04\u7684\u865a\u62df\u5730\u5740\uff0c\u5373 <code>0x0000_003f_ffff_e000</code>\u3002 \u5728\u8fdb\u5165 <code>uservec</code> \u540e\uff0c\u6211\u4eec\u4ea4\u6362 a0 \u548c sscratch\uff0c\u6b64\u65f6 a0 \u4e3a <code>0x0000_003f_ffff_e000</code>\u3002 \u968f\u540e\uff0c\u6211\u4eec\u7528 <code>sd ra, 40(a0)</code> \u7b49\u6c47\u7f16\u6307\u4ee4\u6765\u4fdd\u5b58\u9664\u4e86 a0 \u4ee5\u5916\u7684\u6240\u6709\u7528\u6237\u5bc4\u5b58\u5668\u3002\u5728\u4fdd\u5b58\u7528\u6237\u5bc4\u5b58\u5668\u540e\uff0c\u6211\u4eec\u80fd\u591f\u4fee\u6539\u6240\u6709\u5bc4\u5b58\u5668\u4e86\uff0c\u6211\u4eec\u5c06\u4fdd\u5b58\u5728 <code>sscratch</code> \u4e2d\u7684\u7528\u6237 <code>a0</code> \u8bfb\u53d6\u5230 <code>t0</code>\uff0c\u5e76\u5199\u5165 trapframe \u4e2d\uff0c\u81f3\u6b64\u6211\u4eec\u6210\u529f\u4fdd\u5b58\u4e86\u6240\u6709\u7528\u6237\u5bc4\u5b58\u5668\u3002\u7136\u540e\uff0c\u6211\u4eec\u4fdd\u5b58 <code>sepc</code> \u5230 trapframe \u7ed3\u6784\u4f53\u4e2d\u3002</p> <p>\u6700\u540e\uff0c\u6211\u4eec\u4ece <code>trapframe</code> \u4e2d\u8bfb\u53d6\u5185\u6838\u76f8\u5173\u7684\u6570\u636e\uff0c\u5982\u5185\u6838\u9875\u8868 <code>t1</code> (<code>kernel_satp</code>)\uff0c\u5185\u6838\u6808 <code>sp</code> (<code>kernel_sp</code>)\uff0c\u5185\u6838\u7684 cpuid <code>tp</code> (<code>kernel_hartid</code>)\uff0c\u4ee5\u53ca\u4e0b\u4e00\u9636\u6bb5\u7684\u7528\u6237 Trap \u5904\u7406\u51fd\u6570 t0 (<code>kenrel_trap</code>)\u3002 \u5728\u5207\u6362\u56de\u5185\u6838\u7684\u9875\u8868\u540e\uff0c\u6211\u4eec\u5373\u53ef\u8df3\u8f6c <code>tf-&gt;kernel_trap</code> \u8fdb\u5165C\u8bed\u8a00\u73af\u5883\u5904\u7406 <code>usertrap</code>\u3002</p> <p>Info</p> <p>\u5185\u6838\u6808\u6709\u5982\u4e0b\u51e0\u79cd\uff1a</p> <ul> <li><code>boot_stack</code>\uff1a\u5185\u6838\u542f\u52a8\u65f6\u6240\u7528\u7684\u6808\u3002</li> <li><code>sched_kstack</code>\uff1a\u6bcf\u4e2a CPU \u7684 scheduler \u6240\u7528\u7684\u6808\u3002</li> <li><code>p-&gt;kstack</code>: \u6bcf\u4e2a\u8fdb\u7a0b\u7684 \u5185\u6838\u7ebf\u7a0b \u7684\u5185\u6838\u6808\u3002\u5f53\u4ece U-mode \u6765\u5230 S-mode \u65f6\uff0c\u7528\u6237\u6a21\u5f0f\u4e0b\u7684 sp \u662f\u4e0d\u53ef\u7528\u7684\uff0c\u6211\u4eec\u9700\u8981\u5207\u6362\u5230\u8be5\u8fdb\u7a0b\u7684\u5185\u6838\u6808\u3002</li> </ul>"},{"location":"lab/xv6lab-userspace/#trampoline-_1","title":"Trampoline - \u5185\u6838\u6001\u5230\u7528\u6237\u6001","text":"<p>\u5f53\u6211\u4eec\u9700\u8981\u4ece S mode \u8fdb\u5165 U mode\uff08\u5982\u7528\u6237\u8fdb\u7a0b\u7b2c\u4e00\u6b21\u8fd0\u884c\u6216\u7528\u6237\u8fdb\u7a0b\u4ece Trap \u4e2d\u8fd4\u56de\uff09\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528 <code>usertrapret</code> \u65b9\u6cd5\u8fdb\u884c\u5185\u6838\u6001\u4fe1\u606f\u7684\u4fdd\u5b58\u5e76\u52a0\u8f7d\u7528\u6237\u6001\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u518d\u901a\u8fc7 <code>userret</code> \u5207\u6362\u5230\u7528\u6237\u9875\u8868\uff0c\u5e76\u56de\u5230sepc\u8bb0\u5f55\u7684\u5730\u65b9\u7ee7\u7eed\u6267\u884c\u3002</p>"},{"location":"lab/xv6lab-userspace/#usertraprettrapc","title":"usertrapret\uff08trap.c\uff09","text":"<p><code>usertrapret</code> \u5148\u5c06\u5185\u6838\u7684\u4fe1\u606f\u4fdd\u5b58\u5230 <code>trapframe</code>\uff0c\u4fee\u6539 <code>sepc</code> \u4e3a\u4e2d\u65ad\u5e27\u4e2d\u7684sepc \uff0c\u8bbe\u7f6e <code>sstatus</code> \u7684SPP\u4f4d \uff0c\u8ba1\u7b97\u51fa\u7528\u6237\u9875\u8868\u7684 <code>satp</code> \u548c <code>stvec</code> \u503c\uff0c\u5e76\u8df3\u8f6c\u5230 Trampoline \u4e2d\u7684 <code>userret</code> \u51fd\u6570\u3002</p> <p>\u5728\u8c03\u7528 <code>userret</code> \u65f6\uff0c\u6211\u4eec\u4f20\u5165\u4e863\u4e2a\u53c2\u6570\uff0c\u5206\u522b\u662f\u7528\u6237\u7684 <code>trapframe</code> \u5730\u5740\uff0c\u7528\u6237\u9875\u8868 <code>satp</code> \u503c\uff0c\u548c <code>stvec</code> \u503c\u3002\u5728\u6c47\u7f16\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 a0, a1, a2 \u5f15\u7528\u5b83\u4eec\u3002</p> <pre><code>//\n// return to user space\n//\nvoid usertrapret() {\n    if (intr_get())\n        panic(\"usertrapret entered with intr on\");\n\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    trapframe-&gt;kernel_satp      = r_satp();                                 // kernel page table\n    trapframe-&gt;kernel_sp        = curr_proc()-&gt;kstack + KERNEL_STACK_SIZE;  // process's kernel stack\n    trapframe-&gt;kernel_trap      = (uint64)usertrap;\n    trapframe-&gt;kernel_hartid    = r_tp();\n\n    w_sepc(trapframe-&gt;epc);\n    // set up the registers that trampoline.S's sret will use to get to user space.\n\n    // set S Previous Privilege mode to User.\n    uint64 x = r_sstatus();\n    x &amp;= ~SSTATUS_SPP;  // clear SPP to 0 for user mode\n    x |= SSTATUS_SPIE;  // enable interrupts in user mode\n    w_sstatus(x);\n\n    // tell trampoline.S the user page table to switch to.\n    uint64 satp  = MAKE_SATP(KVA_TO_PA(curr_proc()-&gt;mm-&gt;pgt));\n    uint64 stvec = (TRAMPOLINE + (uservec - trampoline)) &amp; ~0x3;\n\n    uint64 fn = TRAMPOLINE + (userret - trampoline);\n    tracef(\"return to user @%p, fn %p\", trapframe-&gt;epc);\n    ((void (*)(uint64, uint64, uint64))fn)(TRAPFRAME, satp, stvec);\n}\n</code></pre>"},{"location":"lab/xv6lab-userspace/#userrettrampolines","title":"userret\uff08trampoline.S\uff09","text":"<p>\u5728 userret \u4e2d\uff0c\u6211\u4eec\u9996\u5148\u901a\u8fc7 usertrapret \u4e2d\u4f20\u9012\u7684 a1 \u5bc4\u5b58\u5668\u5185\u5bb9\u5207\u6362\u56de\u7528\u6237\u9875\u8868\uff0c\u6b64\u65f6\u6211\u4eec\u5373\u53ef\u4f7f\u7528 <code>0x0000_003f_ffff_e000</code> \u8bbf\u95ee\u5230 trapframe\uff0c\u7136\u540e\u5c06 <code>stvec</code> \u4ece\u5185\u6838\u7684\u4e2d\u65ad\u5904\u7406\u5165\u53e3 <code>kernel_trap_entry</code> \u8bbe\u7f6e\u4e3a\u7528\u6237\u7684\u4e2d\u65ad\u5904\u7406\u5165\u53e3 <code>uservec</code> \u3002</p> <p>\u4e4b\u540e\uff0c\u6211\u4eec\u5c06\u7528\u6237\u7684 a0 \u5b58\u5165 <code>sscratch</code>\uff0c\u7136\u540e\u4ece trapframe \u4e2d\u6062\u590d\u4e86\u5176\u4ed6\u7528\u6237\u5bc4\u5b58\u5668\u3002\u6700\u540e\uff0c\u6211\u4eec\u4f7f\u7528 <code>csrrw a0, sscratch, a0</code> \u4ea4\u6362 a0 \u548c <code>sscratch</code>\uff0c\u6b64\u65f6 a0 \u4e3a\u7528\u6237\u7684 a0\uff0c<code>sscratch</code> \u662f trapframe \u7684\u865a\u62df\u5730\u5740 <code>0x0000_003f_ffff_e000</code>\u3002</p> <p>\u5728 userret \u7684\u6700\u540e\uff0c\u6211\u4eec\u6267\u884c sret \uff0c\u5207\u6362\u81f3 U mode\uff0c\u8df3\u8f6c\u81f3 sepc \u5b58\u50a8\u7684\u4f4d\u7f6e\u7ee7\u7eed\u6267\u884c\u3002</p> <pre><code>.globl userret\nuserret:\n        # userret(TRAPFRAME, pagetable, stvec)\n        # switch from kernel to user.\n        # usertrapret() calls here.\n        # a0: TRAPFRAME, in user page table.\n        # a1: user page table, for satp.\n\n        # switch to the user page table.\n        csrw satp, a1\n        sfence.vma zero, zero\n\n        # switch to the user stvec.\n        csrw stvec, a2\n\n        # put the saved user a0 in sscratch, so we\n        # can swap it with our a0 (TRAPFRAME) in the last step.\n        ld t0, 112(a0)\n        csrw sscratch, t0\n\n        # restore all but a0 from TRAPFRAME\n        ld ra, 40(a0)\n        ld sp, 48(a0)\n        # ...\n        ld t5, 272(a0)\n        ld t6, 280(a0)\n\n        # restore user a0, and save TRAPFRAME in sscratch\n        csrrw a0, sscratch, a0\n\n        # return to user mode and user pc.\n        # usertrapret() set up sstatus and sepc.\n        sret\n</code></pre>"},{"location":"lab/xv6lab-userspace/#_6","title":"\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b","text":"<p>\u5728\u8fd9\u4e2a\u90e8\u5206\uff0c\u6211\u4eec\u9700\u8981\u7406\u89e3\u64cd\u4f5c\u7cfb\u7edf\u5728\u542f\u52a8\u540e\uff0c\u5982\u4f55\u7531 S mode \u5207\u6362\u5230 U mode \u8fd0\u884c\u8d77\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\uff0c\u5e76\u7406\u89e3\u5982\u4f55\u5728\u7528\u6237\u8fdb\u7a0b\u4e2d\u5bf9 Trap \u8fdb\u884c\u76f8\u5e94\u3002</p>"},{"location":"lab/xv6lab-userspace/#_7","title":"\u521b\u5efa\u7528\u6237\u8fdb\u7a0b","text":"<p>\u64cd\u4f5c\u7cfb\u7edf\u542f\u52a8\u540e\uff0c\u901a\u8fc7\u5728 <code>bootcpu_init</code> \u4e2d\u8c03\u7528 <code>load_init_app</code> \u51fd\u6570\u4f1a\u52a0\u8f7d\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\uff0c\u6211\u4eec\u79f0\u4e4b\u4e3a <code>init</code> \u8fdb\u7a0b\u3002<code>allocproc</code> \u4f1a\u521b\u5efa\u5e76\u521d\u59cb\u5316 init \u8fdb\u7a0b\u7684 PCB\uff0c<code>load_user_elf</code> \u4f1a\u5c06\u52a0\u8f7d init \u8fdb\u7a0b\u7684 ELF \u6587\u4ef6\u5230 PCB <code>p</code> \u4e2d\uff0c<code>add_task</code> \u5c06\u5b83\u4e22\u8fdb <code>scheduler</code> \u7684\u961f\u5217\u4e2d\uff0c\u7b49\u5f85\u7b2c\u4e00\u6b21\u8c03\u5ea6\u3002</p> <pre><code>int load_init_app() {\n    struct user_app *app = get_elf(INIT_PROC);\n    struct proc *p = allocproc();\n    load_user_elf(app, p, argv);\n    add_task(p);\n    init_proc = p;\n    release(&amp;p-&gt;lock);\n    return 0;\n}\n</code></pre> <p>\u5728 Context Switch \u4e00\u7ae0\uff0c<code>allocproc</code> \u4f1a\u521d\u59cb\u5316 <code>struct proc</code> \u4e2d\u7684 pid, state \u7b49\u5b57\u6bb5\uff0c\u4ee5\u53ca\u521d\u59cb\u5316 context \u4e3a <code>sched_first_ret</code>\u3002\u800c\u5728\u672c\u7ae0\u4e2d\uff0c\u6211\u4eec\u591a\u4e86\u7528\u6237\u6a21\u5f0f\uff0c<code>allocproc</code> \u989d\u5916\u5b8c\u6210\u4e86\uff1a\u5728\u7528\u6237\u5185\u5b58\u5730\u5740\u6620\u5c04 trampoline \u5230\u5185\u6838\u6e90\u4ee3\u7801\u4e2d\u7684\u7279\u6b8a\u9875\u9762\uff0c\u521b\u5efa trapframe \u7684\u7a7a\u95f4\uff0c\u5c06\u5176\u6620\u5c04\u5230\u7528\u6237\u5185\u5b58\u5730\u5740\uff0c\u5e76\u4fdd\u5b58\u5176 KVA\uff08\u5185\u6838\u865a\u62df\u5730\u5740\uff09\u5230 <code>p-&gt;trapframe</code>\u3002</p> <p><pre><code>struct proc *allocproc() {\n    // ...\nfound:\n    // ==== Resources Allocation ====\n\n    p-&gt;pid   = allocpid();\n    p-&gt;state = USED;\n    // create struct mm for user memory management.\n    p-&gt;mm    = mm_create();\n\n    // map trampoline to user address `TRAMPOLINE`\n    mm_mappageat(p-&gt;mm, TRAMPOLINE, KIVA_TO_PA(trampoline), PTE_A | PTE_R | PTE_X);\n\n    // allocate a physical page for trapframe.\n    uint64 __pa tf = (uint64)kallocpage();\n    mm_mappageat(p-&gt;mm, TRAPFRAME, tf, PTE_A | PTE_D | PTE_R | PTE_W);\n\n    // ==== Resources Allocation Ends ====\n\n    // prepare trapframe and the first return context.\n    p-&gt;trapframe = (struct trapframe *)PA_TO_KVA(tf);\n    memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));\n    memset((void *)p-&gt;kstack, 0, KERNEL_STACK_SIZE);\n    memset((void *)p-&gt;trapframe, 0, PGSIZE);\n    p-&gt;context.ra = (uint64)first_sched_ret;\n    p-&gt;context.sp = p-&gt;kstack + KERNEL_STACK_SIZE;\n\n    return p;\n}\n</code></pre> <code>load_user_elf</code> \u4e2d\uff0c\u4f1a\u5c06\u7528\u6237\u7a0b\u5e8f\u7684 <code>epc</code> \u7b49\u4fe1\u606f\u5199\u5165\u8fdb\u7a0b\u7684\u4e2d\u65ad\u5e27\u4e2d\u3002 <pre><code>    // setup trapframe\n    p-&gt;trapframe-&gt;sp  = sp;\n    p-&gt;trapframe-&gt;epc = ehdr-&gt;e_entry;\n    p-&gt;trapframe-&gt;a0  = argc;\n    p-&gt;trapframe-&gt;a1  = uargv_ptr;\n    p-&gt;state          = RUNNABLE;\n</code></pre></p> <p>\u81f3\u6b64\uff0c\u7b2c\u4e00\u4e2a\u7528\u6237\u8fdb\u7a0b\u52a0\u8f7d\u5e76\u521b\u5efa\u5b8c\u6210\u3002</p>"},{"location":"lab/xv6lab-userspace/#_8","title":"\u7b2c\u4e00\u6b21\u5230\u7528\u6237\u7a7a\u95f4","text":"<p>\u4e0e Context Switch \u7ae0\u8282\u4e2d\u7c7b\u4f3c\uff0c\u5728 <code>scheduler</code> \u901a\u8fc7 <code>swtch</code> \u5207\u6362\u5230\u7528\u6237\u8fdb\u7a0b\u540e\uff0c <code>first_sched_ret</code> \u662f\u4e00\u4e2a\u8fdb\u7a0b\u7b2c\u4e00\u6b21\u88ab scheduler \u8c03\u5ea6\u5230\u65f6\u6267\u884c\u7684\u51fd\u6570\uff0c\u5b83\u4f1a\u6309\u7167 scheduler \u89c4\u8303\u91ca\u653e <code>p-&gt;lock</code>\uff0c\u5e76\u4e14\u8df3\u8f6c\u5230 <code>usertrapret</code> \u7ee7\u7eed\u6267\u884c\uff08\u89c1Trampoline\u90e8\u5206\uff09\u3002\u7531\u4e8e\u6211\u4eec\u5728\u7528\u6237\u8fdb\u7a0b\u7684\u4e2d\u65ad\u5e27\u4e2d\u5df2\u7ecf\u5b58\u50a8\u4e86\u7528\u6237\u7a0b\u5e8f\u7684\u5165\u53e3\u7b49\u76f8\u5173\u4fe1\u606f\uff0c\u5728 <code>userret</code> \u2018\u6062\u590d\u2019\u7528\u6237\u8fdb\u7a0b\u7684\u72b6\u6001\u540e\uff0c sret \u5c06\u8ba9\u7528\u6237\u8fdb\u7a0b\u6b63\u5f0f\u5f00\u59cb\u5728\u7528\u6237\u7a7a\u95f4\u8fd0\u884c\u3002</p>"},{"location":"lab/xv6lab-userspace/#_9","title":"\u7528\u6237\u7a7a\u95f4\u7684\u7b2c\u4e00\u6761\u4ee3\u7801","text":"<p>\u7528\u6237\u7a7a\u95f4\u7684\u4ee3\u7801\u5e76\u4e0d\u662f <code>init.c</code> \u7684\u5165\u53e3\u4ee3\u7801\uff0c\u6211\u4eec\u5728 <code>user/lib/user.ld</code> \u5b9a\u4e49\u4e86\u7528\u6237\u7a0b\u5e8f\u7684 Linker Script\uff0c\u91cc\u9762\u6307\u5b9a\u4e86 ELF \u5165\u53e3 entry \u662f <code>__start_main</code> \u51fd\u6570\uff0c\u8be5\u51fd\u6570\u5728 <code>user/lib/start_main.c</code> \u4e2d\u88ab\u5b9a\u4e49\u3002</p> <p>\u8be5\u51fd\u6570\u4f1a\u8c03\u7528 main \u51fd\u6570\uff0c\u5e76\u5c06\u5176\u8fd4\u56de\u503c\u4f5c\u4e3a exit \u7684\u9000\u51fa\u72b6\u6001\u7801\uff0c\u8fd9\u5141\u8bb8\u6211\u4eec\u5728 main \u51fd\u6570\u4e2d\u4f7f\u7528 <code>return</code> \u6765\u9000\u51fa\u7a0b\u5e8f\u800c\u4e0d\u8981\u6c42\u7528\u6237\u4f7f\u7528 exit \u7cfb\u7edf\u8c03\u7528\u6765\u4fdd\u8bc1\u8fdb\u7a0b\u7684\u6b63\u5e38\u7ed3\u675f\u3002</p> <pre><code>#include \"syscall.h\"\n\nextern int main(int, char **);\n\n__attribute__((section(\".text.entry\"))) int __start_main(int argc, char *argv[])\n{\n    exit(main(argc, argv));\n    return 0;\n}\n</code></pre>"},{"location":"lab/xv6lab-userspace/#_10","title":"\u7528\u6237\u7a7a\u95f4\u7684\u9000\u51fa","text":"<p>\u7528\u6237\u8fdb\u7a0b\u8fd0\u884c\u7ed3\u675f\u540e\u5c06\u5728\u7528\u6237\u7a7a\u95f4\u8c03\u7528 <code>exit</code> \u7cfb\u7edf\u8c03\u7528\u4f7f\u5f97\u8fdb\u7a0b\u6b63\u5e38\u9000\u51fa\uff0c\u5e76\u5524\u9192\u7236\u8fdb\u7a0b\u8fdb\u884c\u8d44\u6e90\u7684\u56de\u6536\u3002</p> <p><code>exit</code> \u5c06\u6267\u884c <code>user\\lib\\usys.pl</code> \u751f\u6210\u7684\u4ee3\u7801\uff0c\u901a\u8fc7\u5c06 exit \u7cfb\u7edf\u8c03\u7528\u5bf9\u5e94\u7684system call number \u653e\u5165 a7 \u5bc4\u5b58\u5668\u540e\uff0c\u6267\u884c ecall \u6307\u4ee4\uff0c\u89e6\u53d1\u73af\u5883\u8c03\u7528 Trap \u5207\u6362\u5165 S mode \u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\u7684\u76f8\u5173\u5185\u6838\u4ee3\u7801\u6267\u884c\u6d41\u7a0b\u3002\uff08\u5982\u7528\u6237\u8fdb\u7a0b\u6267\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f Trap \uff0c\u4e5f\u662f\u540c\u6837\u7684\u6d41\u7a0b\uff09</p> <p>ecall \u6307\u4ee4\u6267\u884c\u540e\uff0c\u7531\u4e8e\u7528\u6237 <code>stvec</code> \u5bc4\u5b58\u5668\u4e2d\u5b58\u50a8\u7684\u662f <code>uservec</code> \uff0c\u56e0\u800c\u8df3\u8f6c\u81f3 Trampoline \u7684 uservec \u90e8\u5206\u4ee3\u7801\u8fdb\u5165 S mode (\u8be6\u7ec6\u4ecb\u7ecd\u89c1Trampoline\u90e8\u5206)\uff0cuservec \u7684\u6700\u540e\u5c06\u8df3\u8f6c\u81f3\u7528\u6237\u4e2d\u65ad\u5904\u7406\u7a0b\u5e8f usertrap \u8fdb\u884c\u76f8\u5e94\u7684\u4e2d\u65ad\u5904\u7406\u3002</p>"},{"location":"lab/xv6lab-userspace/#usertraptrapc","title":"usertrap\uff08trap.c\uff09","text":"<p>\u5728 <code>usertrap</code> \u4e2d\uff0c\u6211\u4eec\u5148\u5c06 stvec \u8bbe\u7f6e\u4e3a <code>kerneltrap</code>\uff0c\u4ee5\u6b64\u6355\u6349\u4e4b\u540e\u5728\u5185\u6838\u6001\u53ef\u80fd\u51fa\u73b0\u7684\u4e2d\u65ad\u548c\u5f02\u5e38\u3002\u968f\u540e\u8bfb\u53d6 scause \u5904\u7406\u5f02\u5e38\u3002\u6700\u540e\uff0c\u4f7f\u7528 <code>usertrapret</code> \u8fd4\u56de\u7528\u6237\u7a7a\u95f4\u3002</p> <pre><code>void usertrap() {\n    set_kerneltrap();\n\n    assert(!intr_get());\n    if ((r_sstatus() &amp; SSTATUS_SPP) != 0)\n        panic(\"usertrap: not from user mode\");\n\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    uint64 cause = r_scause();\n\n    // handle usertrap according to scause\n\n    assert(!intr_get());\n    usertrapret();\n}\n</code></pre> <p>exit \u4f5c\u4e3a\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u4f1a\u901a\u8fc7\u4e2d\u65ad\u5904\u7406\u7684 ecall \u5206\u652f\u8c03\u7528 syscall() \u65b9\u6cd5\u6267\u884c\u76f8\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\u3002\u7531\u4e8e\u5b83\u662f\u4e00\u4e2a\u4e0d\u4f1a\u8fd4\u56de\u7684\u65b9\u6cd5\uff0c\u81ea\u6b64\u64cd\u4f5c\u7cfb\u7edf\u56de\u5230 S mode \u8fdb\u884c\u76f8\u5e94\u7684\u56de\u6536\u5904\u7406\uff0c\u5e76\u51c6\u5907\u4e0b\u4e00\u6b21\u8c03\u5ea6\u3002\u7528\u6237\u8fdb\u7a0b\u6b63\u5f0f\u7ed3\u675f\u3002 </p>"},{"location":"lab/xv6lab-userspace/#syscall","title":"\u7cfb\u7edf\u8c03\u7528 Syscall","text":"<p>\u7cfb\u7edf\u8c03\u7528\uff08System Call\uff09\u662f\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7ed9\u5e94\u7528\u7a0b\u5e8f\u7684\u63a5\u53e3\uff0c\u5141\u8bb8\u7528\u6237\u7a0b\u5e8f\u8bf7\u6c42\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u7684\u670d\u52a1\u3002\u7cfb\u7edf\u8c03\u7528\u4e5f\u6709\u81ea\u5df1\u7684\u8c03\u7528\u89c4\u5b9a\uff08calling convention\uff09\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 <code>man 2 syscall</code> \u67e5\u770b\u4e0d\u540c\u5e73\u53f0\u4e0a Linux \u7684 syscall \u8c03\u7528\u89c4\u7ea6\u3002</p> <p>RISC-V \u4e0a\uff0c\u7cfb\u7edf\u8c03\u7528\u7531 <code>ecall</code> \u6307\u4ee4\u53d1\u8d77\uff0csyscall number \u5373\u8c03\u7528\u54ea\u4e2a syscall \u5728 a7 \u5bc4\u5b58\u5668\u4e2d\u6307\u5b9a\uff0c6\u4e2a\u53c2\u6570\u5728 a0-a5 \u4e2d\u6307\u5b9a\uff0c\u7cfb\u7edf\u8c03\u7528\u7684\u8fd4\u56de\u503c\u5219\u5728 a0 \u4e0e a1 \u4e2d\u3002</p> <p><code>ecall</code> \u6307\u4ee4\u4f1a\u53d1\u8d77\u4e00\u4e2a\u5f02\u5e38\uff0c\u5bfc\u81f4 CPU \u8fdb\u5165 Trap\uff0c\u5176 trap cause (scause) \u4e3a 8 (ecall from U-mode)\u3002\u6211\u4eec\u5728 <code>usertrap</code> \u4e2d\u5904\u7406\u8fd9\u79cd\u5f02\u5e38\uff0c\u5e76\u8f6c\u4ea4 <code>syscall.c</code> \u4e2d\u7684 <code>syscall</code> \u51fd\u6570\u5904\u7406\u3002</p> <pre><code>void usertrap() {\n    // ...\n    struct proc *p              = curr_proc();\n    struct trapframe *trapframe = p-&gt;trapframe;\n\n    uint64 cause = r_scause();\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        // handle interrupt\n    } else if (cause == UserEnvCall) {\n        // sepc points to the ecall instruction,\n        // but we want to return to the next instruction.\n        trapframe-&gt;epc += 4;\n\n        // an interrupt will change sepc, scause, and sstatus,\n        // so enable only now that we're done with those registers.\n        intr_on();\n        syscall();\n        intr_off();\n    }\n    // ...\n    assert(!intr_get());\n    usertrapret();\n}\n</code></pre> <p><code>syscall</code> \u51fd\u6570\u4ece\u5f53\u524d\u8fdb\u7a0b\u7684 Trapframe \u4e2d\u8bfb\u53d6\u7528\u6237\u6267\u884c <code>ecall</code> \u65f6\u7684\u5bc4\u5b58\u5668\u503c\uff0c\u5e76\u8c03\u7528\u5bf9\u5e94\u7684 syscall \u5904\u7406\u51fd\u6570\u3002</p> <pre><code>void syscall() {\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    int id                      = trapframe-&gt;a7;\n    uint64 ret;\n    uint64 args[6] = {trapframe-&gt;a0, trapframe-&gt;a1, trapframe-&gt;a2, trapframe-&gt;a3, trapframe-&gt;a4, trapframe-&gt;a5};\n    switch (id) {\n        case SYS_read:\n            ret = sys_read(args[0], args[1], args[2]);\n            break;\n        case SYS_write:\n            ret = sys_write(args[0], args[1], args[2]);\n            break;\n        default:\n            ret = -1;\n            errorf(\"unknown syscall %d\", id);\n    }\n    trapframe-&gt;a0 = ret;\n    tracef(\"syscall ret %d\", ret);\n}\n</code></pre>"},{"location":"lab/xv6lab-userspace/#uaccess","title":"uaccess","text":""},{"location":"lab/xv6lab-userspace/#read-write","title":"read &amp; write","text":"<p><code>read</code> \u548c <code>write</code> \u662f Linux \u4e0b\u91cd\u8981\u7684\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u5b83\u4eec\u7684\u539f\u578b\u5982\u4e0b\uff1a</p> <pre><code>ssize_t read(int fd, void buf[.count], size_t count);\nssize_t write(int fd, const void buf[.count], size_t count);\n</code></pre> <p>read \u8868\u793a\u7528\u6237\u7a0b\u5e8f\u5e0c\u671b\u4ece\u5185\u6838\u8bfb\u53d6\u6570\u636e\uff0c\u5b83\u8d1f\u8d23\u4ece fd \uff08\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cFile Descriptor\uff09\u8bfb\u53d6 \u81f3\u591a count \u5b57\u8282\uff0c\u5199\u5165\u5230 buf\u4e2d\uff0c\u5e76\u8fd4\u56de\u8bfb\u53d6\u4e86\u591a\u5c11\u5b57\u8282\u3002 \u800c write \u5219\u8868\u793a\u7528\u6237\u7a0b\u5e8f\u5e0c\u671b\u5f80\u5185\u6838\u5199\u5165\u6570\u636e\uff0c\u5b83\u8d1f\u8d23\u5c06 \u81f3\u591a count \u5b57\u8282\u7684\u6570\u636e\u4ece buf \u5199\u5165\u5230 fd \u4e2d\u3002</p> <p>\u5728\u6211\u4eec\u8fd9\u8282\u8bfe\u6240\u7528\u7684 xv6 \u4e0a\uff0c\u6211\u4eec\u8fd8\u5c1a\u672a\u5f15\u5165\u6587\u4ef6\u7684\u6982\u5ff5\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u5047\u5b9a read &amp; write \u7cfb\u7edf\u8c03\u7528\u5373\u662f\u5bf9\u6807\u51c6\u8f93\u5165\u8f93\u51fa\u7684 read &amp; write\uff0c\u8fd9\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\u6700\u7ec8\u4f1a\u88ab <code>user_console_write</code> \u548c <code>user_console_read</code> \u5904\u7406\u3002</p> <p>\u6240\u4ee5\uff0c\u5728\u76ee\u524d\u7684 xv6 \u4e2d\uff0cread \u548c write \u7684\u8bed\u4e49\u4e5f\u5f88\u7b80\u5355\u4e86\uff1awrite \u5373\u662f\u4ece\u7528\u6237\u7a7a\u95f4\u5c06 <code>buf</code> \u4e2d\u7684\u6570\u636e\u6253\u5370\u5230\u4e32\u53e3\uff0cread \u5373\u662f\u7b49\u5f85\u4e32\u53e3\u7684\u6570\u636e\u5e76\u62f7\u8d1d\u5230 <code>buf</code> \u4e2d\u3002</p> <p>\u8fd9\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\u80cc\u540e\u5747\u6709\u4e00\u4e2a\u95ee\u9898\uff1a\u64cd\u4f5c\u7cfb\u7edf\u5982\u4f55\u5bf9\u7528\u6237\u5185\u5b58\u8fdb\u884c\u8bfb\u5199\uff1f\uff0c\u6bd5\u7adf\u7528\u6237\u5185\u5b58\u4f7f\u7528\u7684\u662f\u7528\u6237\u9875\u8868\u800c\u975e\u5185\u6838\u9875\u8868\u3002</p>"},{"location":"lab/xv6lab-userspace/#uaccess_1","title":"uaccess","text":"<p>\u5728\u5185\u6838\u4e0b\u8bbf\u95ee\u7528\u6237\u8fdb\u7a0b\u662f\u4e00\u79cd\u975e\u5e38\u5e38\u89c1\u7684\u9700\u6c42\uff0c\u4ee5\u81f3\u4e8e\u6211\u4eec\u4e3a\u6b64\u4e13\u95e8\u521b\u5efa\u4e86\u4e00\u7cfb\u5217\u51fd\u6570\uff0c\u6211\u4eec\u5c06\u8fd9\u7cfb\u5217\u51fd\u6570\u79f0\u4e3a \u7528\u6237\u8bbf\u95ee\u539f\u8bed (uaccess primitive)\u3002</p> <p>\u5728\u8003\u8651 \u201cuaccess \u5982\u4f55\u5b9e\u73b0 \u5728\u5185\u6838\u8bfb\u5199\u7528\u6237\u5185\u5b58 \u201d\u524d\uff0c\u6211\u4eec\u4f3c\u4e4e\u5df2\u7ecf\u5e72\u8fc7\u8fd9\u4ef6\u4e8b\u4e86\uff1a\u5728 <code>loader.c</code> \u4e2d\u7684 <code>load_user_elf</code> \u901a\u8fc7 ELF \u52a0\u8f7d\u7528\u6237\u7a0b\u5e8f\u65f6\uff0c\u6211\u4eec\u5c31\u662f\u5728\u4fee\u6539\u7528\u6237\u5185\u5b58\u3002</p> <p>\u6211\u4eec\u91cd\u65b0\u56de\u987e\u4e00\u4e0b\uff0c\u5728 <code>load_user_elf</code> \u4e2d\u662f\u5982\u4f55\u5206\u914d\u5e76\u5199\u5165\u7528\u6237\u5185\u5b58\u7684\uff1a</p> <ol> <li>\u5bf9\u4e8e\u6bcf\u4e2a <code>PT_LOAD</code> \u6bb5\uff0c\u6211\u4eec\u5f97\u5230\u5b83\u8981\u52a0\u8f7d\u7684\u8d77\u59cb\u5730\u5740\u548c\u8303\u56f4\uff0c\u5e76\u4f7f\u7528\u4e00\u4e2a <code>struct vma</code> \u6765\u8868\u793a\u8fd9\u4e2a\u8303\u56f4\u3002</li> </ol> <pre><code>    Elf64_Phdr *phdr = &amp;phdr_base[i];\n\n    struct vma *vma = mm_create_vma(p-&gt;mm);\n    vma-&gt;vm_start   = PGROUNDDOWN(phdr-&gt;p_vaddr);  // The ELF requests this phdr loaded to p_vaddr;\n    vma-&gt;vm_end     = PGROUNDUP(vma-&gt;vm_start + phdr-&gt;p_memsz);\n    vma-&gt;pte_flags  = pte_perm;\n</code></pre> <ol> <li>\u6211\u4eec\u4f7f\u7528 <code>mm_mappages</code> \u6620\u5c04\u8be5 vma \u533a\u57df\u3002<code>mm_mappages</code> \u4f1a\u5bf9 vma \u4e2d\u7684\u6bcf\u4e2a\u9875\u9762\u4f7f\u7528 <code>kallocpage()</code> \u5206\u914d\u7269\u7406\u9875\u9762\u3002</li> </ol> <pre><code>mm_mappages(vma);\n</code></pre> <ol> <li>\u4f7f\u7528 <code>walkaddr</code> \u5728\u9875\u8868\u7ed3\u6784\u4e0a\u627e\u5230 va \u6240\u5bf9\u5e94\u7684 pa\u3002\u6ce8\u610f\u5230 <code>kallocpage</code> \u8fd4\u56de\u7684\u9875\u9762\u662f Kernel Direct Mapping \u533a\u57df\u4e2d\u7684\u9875\u9762\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>PA_TO_KVA</code> \u8f6c\u6362\u5730\u5740\u4e3a KVA \u5e76\u76f4\u63a5\u5bf9\u7528\u6237\u5185\u5b58\u80cc\u540e\u7684\u7269\u7406\u9875\u9762\u8fdb\u884c\u8bbf\u95ee\u3002</li> </ol> <pre><code>void *__kva pa = (void *)PA_TO_KVA(walkaddr(p-&gt;mm, va));\nvoid *src      = (void *)(app-&gt;elf_address + phdr-&gt;p_offset + file_off);\nuint64 copy_size = MIN(file_remains, PGSIZE);\n\nmemmove(pa, src, copy_size);\n</code></pre> <p>\u6240\u4ee5\uff0cuaccess \u4e5f\u662f\u5b8c\u5168\u5728\u505a\u540c\u6837\u7684\u4e8b\u60c5\uff0c\u5b83\u901a\u8fc7 <code>walk</code> \u7cfb\u5217\u51fd\u6570 <code>walkaddr</code> \uff0c\u901a\u8fc7 <code>p-&gt;mm-&gt;pgt</code> \u5c06\u7528\u6237\u5730\u5740\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\uff0c\u7136\u540e\u901a\u8fc7\u7269\u7406\u5730\u5740\u6765\u8fdb\u884c\u5185\u5b58\u8bbf\u95ee\u3002</p> <p>\u6211\u4eec\u5b9a\u4e49\u4e86\u5982\u4e0b\u4e09\u79cd\u539f\u8bed\uff1a</p> <pre><code>int copy_to_user(struct mm *mm, uint64 __user dstva, char *src, uint64 len);\nint copy_from_user(struct mm *mm, char *dst, uint64 __user srcva, uint64 len);\nint copystr_from_user(struct mm *mm, char *dst, uint64 __user srcva, uint64 max);\n</code></pre> <p>\u6211\u4eec\u5c06\u901a\u8fc7\u4f5c\u4e1a2\u5bf9 uaccess \u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u7406\u89e3\u3002</p>"},{"location":"lab/xv6lab-userspace/#lab","title":"Lab \u7ec3\u4e60","text":"<ol> <li> <p>\u8bf7\u4f60\u5199\u51fa\uff1a\u5f53 <code>init</code> \u8fdb\u7a0b\u7b2c\u4e00\u6b21\u56de\u9000\u5230\u7528\u6237\u6a21\u5f0f\u65f6\uff0c\u5b83\u7684\u6240\u6709\u5bc4\u5b58\u5668\u72b6\u6001\uff08\u5305\u542b pc\uff0c\u53ea\u5217\u51fa\u503c\u4e0d\u4e3a0\u7684\uff09</p> <p>Hint: \u5728 <code>first_sched_ret</code> \u4e2d\uff0c<code>usertrapret</code> \u524d\uff0c\u4f7f\u7528 <code>print_trapframe</code> \u6253\u5370 <code>curr_proc()</code> \u7684 trapframe\u3002</p> </li> <li> <p>\u5728 <code>user/src/init.c</code> \u4e2d\uff0c\u53d6\u6d88\u6ce8\u91ca\uff1a<code>asm volatile(\" csrw stvec, %0\" : : \"r\"(0x80000000));</code>\u3002</p> <p><code>make run</code> \u8fd0\u884c\u5185\u6838\uff0c<code>init</code> \u5e94\u8be5\u89e6\u53d1\u5f02\u5e38\u5e76\u9000\u51fa\u3002</p> <p>\u8bf7\u4f60\u5199\u51fa <code>init</code> \u89e6\u53d1\u4e86\u4ec0\u4e48\u5f02\u5e38\uff0c\u4ee5\u53ca\u4e3a\u4ec0\u4e48\u4f1a\u89e6\u53d1\u5f02\u5e38\u3002</p> </li> <li> <p>Trapframe \u548c Trampoline \u662f\u4e24\u4e2a\u9875\u9762\uff0c\u8fd9\u4e24\u4e2a\u9875\u9762\u5e94\u8be5\u5141\u8bb8 U-mode \u8bbf\u95ee\u5417\uff1f\u5373\u7528\u6237\u9875\u8868\u4e2d\uff0c\u8fd9\u4e24\u4e2a\u9875\u9762\u7684 PTE \u7684 Flags \u4e2d\u662f\u5426\u5e94\u8be5\u62e5\u6709 <code>PTE_U</code>\u3002\u8bf7\u89e3\u91ca\u4f60\u7684\u7b54\u6848\uff0c\u4e0d\u8d85\u8fc7 50 \u5b57\u3002</p> <p>Hint: \u6211\u4eec\u5728 <code>proc.c</code> \u4e2d\u7684 <code>allocproc</code> \u5bf9\u8fd9\u4e24\u4e2a\u9875\u9762\u8fdb\u884c\u6620\u5c04\uff0c\u4f7f\u7528\u51fd\u6570 <code>mm_mappageat</code>\u3002</p> </li> </ol>"},{"location":"lab/xv6lab-userspace/#_11","title":"\u76f8\u5173\u9605\u8bfb","text":""},{"location":"lab/xv6lab-userspace/#struct-mm","title":"<code>struct mm</code>","text":"<p><code>struct mm</code> \u7ed3\u6784\u4f53\u7528\u4e8e\u7ba1\u7406\u7528\u6237\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u5176\u6e90\u4ee3\u7801\u4f4d\u4e8e <code>vm.c</code>\u3002\uff08\u5185\u6838\u7684\u5185\u5b58\u7a7a\u95f4\u7ba1\u7406\u6e90\u4ee3\u7801\u4e3a <code>kvm.c</code>\uff09</p> <p><code>struct vma</code> \u7ed3\u6784\u4f53\u7528\u4e8e\u8868\u793a\u4e00\u7247\u8fde\u7eed\u7684\u865a\u62df\u5730\u5740\uff0c\u6bcf\u4e2a <code>struct mm</code> \u4e0b\u9762\u6709\u591a\u4e2a <code>struct vma</code> \u7ed3\u6784\u4f53\uff0c\u6bcf\u4e2a <code>struct vma</code> \u6240\u6709\u4e8e\u67d0\u4e2a <code>struct mm</code>\uff0c\u5b83\u4eec\u4f7f\u7528\u94fe\u8868 <code>vma-&gt;next</code> \u4e32\u8054\u5728\u4e00\u8d77\u3002</p> <pre><code>struct vma {\n    struct mm* owner;\n    struct vma* next;\n    uint64 vm_start;\n    uint64 vm_end;\n    uint64 pte_flags;\n};\n\nstruct mm {\n    spinlock_t lock;\n\n    pagetable_t __kva pgt;\n    struct vma* vma;\n    int refcnt;\n};\n\n// vm.c\nvoid uvm_init();\n\npte_t* walk(struct mm* mm, uint64 va, int alloc);\nuint64 __pa walkaddr(struct mm* mm, uint64 va);\nuint64 useraddr(struct mm* mm, uint64 va);\n\nstruct mm* mm_create();\nstruct vma* mm_create_vma(struct mm* mm);\nvoid mm_free_pages(struct mm* mm);\nvoid mm_free(struct mm* mm);\nint mm_mappages(struct vma* vma);\nint mm_remap(struct vma *vma, uint64 start, uint64 end, uint64 pte_flags);\nint mm_mappageat(struct mm *mm, uint64 va, uint64 __pa pa, uint64 flags);\nint mm_copy(struct mm* old, struct mm* new);\nstruct vma* mm_find_vma(struct mm* mm, uint64 va);\n</code></pre> <p>\u5f53\u6211\u4eec\u8981\u4e3a\u7528\u6237\u6620\u5c04\u4e00\u6bb5\u7a7a\u95f4\u65f6\uff1a</p> <ol> <li>\u4f7f\u7528 <code>mm_create_vma</code> \u65b0\u5efa\u4e00\u4e2a <code>struct vma</code> \u7ed3\u6784\u4f53\uff0c\u7136\u540e\u586b\u5145\u5b83\u7684 <code>vma_start</code>, <code>vma_end</code> \u548c <code>pte_flags</code> \u5b57\u6bb5\u3002</li> <li>\u4f7f\u7528 <code>mm_mappages</code> \u6620\u5c04\u8be5 vma\u3002</li> <li>\u5982\u679c\u8981\u5bf9\u8be5\u5730\u5740\u8fdb\u884c\u8bbf\u95ee\uff0c\u4f7f\u7528 <code>walkaddr</code> \u5c06\u5176\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u3002\u7531\u4e8e\u7528\u6237\u6240\u7528\u7684\u7269\u7406\u9875\u9762\u5747\u662f\u7531 <code>kallocpage</code> \u52a8\u6001\u5206\u914d\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>PA_TO_KVA</code> \u5b8f\u5c06\u5176\u8f6c\u6362\u4e3a KVA \u5373\u53ef\u6b63\u5e38\u8bbf\u95ee\u8be5\u865a\u62df\u5730\u5740\u3002</li> </ol> <pre><code>// loader.c, load_user_elf\n\n// setup stack\nstruct vma *vma_ustack   = mm_create_vma(p-&gt;mm);\nvma_ustack-&gt;vm_start  = USTACK_START - USTACK_SIZE;\nvma_ustack-&gt;vm_end    = USTACK_START;\nvma_ustack-&gt;pte_flags = PTE_R | PTE_W | PTE_U;\nmm_mappages(vma_ustack);\n\nfor (uint64 va = vma_ustack-&gt;vm_start; va &lt; vma_ustack-&gt;vm_end; va += PGSIZE) {\n    void *__kva pa = (void *)PA_TO_KVA(walkaddr(p-&gt;mm, va));\n    memset(pa, 0, PGSIZE);\n}\n</code></pre>"},{"location":"lab/xv6lab-userspace/#mm_mappages","title":"mm_mappages","text":"<p>\u51fd\u6570\u539f\u578b\uff1a<code>int mm_mappages(struct vma *vma)</code>\u3002</p> <p>\u8be5\u51fd\u6570\u4f1a\u5728\u9875\u8868 <code>vma-&gt;owner-&gt;pgt</code>\u4e2d\uff0c\u6620\u5c04 <code>vma</code> \u4e2d\u7684\u865a\u62df\u5730\u5740\u8303\u56f4\u3002\u6ce8\u610f\u5230\uff0c\u8be5\u9875\u8868\u5c31\u662f\u7528\u6237\u8fdb\u7a0b\u7684\u9875\u8868 <code>p-&gt;mm-&gt;pgt</code>\u3002</p> <p>\u5177\u4f53\u800c\u8a00\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u9875\u9762\uff1a\u4ece <code>kallocpage()</code> \u5206\u914d\u9875\u9762\uff0c\u5e76\u5728 <code>mm-&gt;pgt</code> \u9875\u8868\u4e2d\u6620\u5c04\u5b83\u3002</p> <pre><code>int mm_mappages(struct vma *vma) {  // simplified\n    // sanity checking\n    struct mm *mm = vma-&gt;owner;\n    for (uint64 va = vma-&gt;vm_start; va &lt; vma-&gt;vm_end; va += PGSIZE) {\n        pte_t *pte = walk(mm, va, 1);\n        void* pa = kallocpage();\n        *pte = PA2PTE(pa) | vma-&gt;pte_flags | PTE_V;\n    }\n}\n</code></pre> <p><code>mm_mappages</code> \u4f1a\u4f7f\u7528 <code>walk</code> \u51fd\u6570\uff0c\u5f97\u5230 <code>mm-&gt;pgt</code> \u4e2d\u865a\u62df\u5730\u5740 va \u6240\u5bf9\u5e94\u7684 PTE \u7684\u5730\u5740\uff0c\u5e76\u6784\u9020 PTE\u3002</p>"},{"location":"lab/xv6lab-userspace/#walk","title":"walk","text":"<p><code>walk</code> \u51fd\u6570\u4f1a\u8fd4\u56de\u5728\u9875\u8868\u4e2d\u7684 PTE \u5730\u5740\u3002\u5982\u679c\u6307\u5b9a\u4e86 <code>alloc</code>\uff0c\u5219\u4f1a\u5bf9\u4e2d\u95f4\u7f3a\u5c11\u7684\u9875\u8868\u8fdb\u884c\u5206\u914d\u3002</p> <pre><code>// Return the address of the PTE in page table pagetable\n// that corresponds to virtual address va.  \n// If alloc!=0, create any required page-table pages.\npte_t *walk(struct mm *mm, uint64 va, int alloc) {\n    assert(holding(&amp;mm-&gt;lock));\n\n    pagetable_t pagetable = mm-&gt;pgt;\n\n    if (!IS_USER_VA(va))\n        return NULL;\n\n    for (int level = 2; level &gt; 0; level--) {\n        pte_t *pte = &amp;pagetable[PX(level, va)];\n        if (*pte &amp; PTE_V) {\n            pagetable = (pagetable_t)PA_TO_KVA(PTE2PA(*pte));\n        } else {\n            if (!alloc)\n                return 0;\n            void *pa = kallocpage();\n            if (!pa)\n                return 0;\n            pagetable = (pagetable_t)PA_TO_KVA(pa);\n            memset(pagetable, 0, PGSIZE);\n            *pte = PA2PTE(KVA_TO_PA(pagetable)) | PTE_V;\n        }\n    }\n    return &amp;pagetable[PX(0, va)];\n}\n</code></pre>"},{"location":"lab/xv6lab-userspace/#_12","title":"\u7a0b\u5e8f\u7684\u52a0\u8f7d","text":"<p><code>loader.c</code> \u7684 <code>load_user_elf</code> \u5b9e\u73b0\u4e86\u52a0\u8f7d\u4e00\u4e2aELF\u6587\u4ef6\u5230\u7528\u6237\u7a7a\u95f4\u3002<code>load_user_elf</code> \u4f1a\u6839\u636e ELF \u7684 Program Header \u8fdb\u884c\u52a0\u8f7d\uff0c\u6bcf\u4e2a LOAD \u6bb5\u4f1a\u5305\u542b\uff1a</p> <ul> <li>p_vaddr\uff1a\u8fd9\u4e2a\u6bb5\u5e94\u8be5\u88ab\u52a0\u8f7d\u5230\u54ea\u4e2a\u865a\u62df\u5730\u5740</li> <li>p_paddr\uff1a\u8fd9\u4e2a\u6bb5\u5e94\u8be5\u88ab\u52a0\u8f7d\u5230\u54ea\u4e2a\u7269\u7406\u5730\u5740\uff0c\u8be5\u503c\u5728\u52a0\u8f7d\u7528\u6237\u7a0b\u5e8f\u65f6\u4e0d\u8d77\u4f5c\u7528\uff0c\u56e0\u4e3a\u7528\u6237\u53ea\u80fd\u770b\u5230\u865a\u62df\u5730\u5740\uff0c\u5e76\u4e14\u7528\u6237\u7684\u9875\u9762\u662f\u7531\u5185\u6838\u52a8\u6001\u5206\u914d\u7684\u3002</li> <li>p_memsz\uff1a\u8fd9\u4e2a\u6bb5\u5e94\u8be5\u5360\u7528\u591a\u5c11\u5185\u5b58\u7a7a\u95f4</li> <li>p_filesz\uff1a\u8fd9\u4e2a\u6bb5\u5728 ELF \u6587\u4ef6\u4e2d\u5360\u636e\u591a\u5c11\u7a7a\u95f4</li> <li>p_offset\uff1a\u8fd9\u4e2a\u6bb5\u7684\u5f00\u59cb\u5730\u5740\u5728 ELF \u6587\u4ef6\u4e2d\u54ea\u4e2a\u4f4d\u7f6e</li> <li>p_flags\uff1a\u6bb5\u7684\u6743\u9650</li> </ul> <p>\u4ee5\u4e0b\u662f <code>init</code> \u7684 ELF \u6587\u4ef6\u4e2d\u7684 phdr:</p> <pre><code>Elf file type is EXEC (Executable file)\nEntry point 0x402400\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x0074ed 0x0000000000000000 0x0000000000000000 0x000061 0x000000 R   0x1\n  LOAD           0x001000 0x0000000000402000 0x0000000000402000 0x000f30 0x000f30 R E 0x1000\n  LOAD           0x002000 0x0000000000403000 0x0000000000403000 0x0000b9 0x0000b9 R   0x1000\n  LOAD           0x003000 0x0000000000404000 0x0000000000404000 0x000028 0x000440 RW  0x1000\n</code></pre> <p>\u5185\u6838\u662f\u600e\u4e48\u627e\u5230\u7528\u6237 ELF \u6587\u4ef6\u7684</p> <p>\u7528\u6237\u7a7a\u95f4\u7684\u7a0b\u5e8f\u4f4d\u4e8e <code>user/</code> \u76ee\u5f55\u4e0b\uff0c<code>make user</code> \u4f1a\u7f16\u8bd1\u6240\u6709\u7528\u6237\u7a0b\u5e8f\uff0c\u7f16\u8bd1\u4ea7\u7269\u4f4d\u4e8e <code>user/build/stripped/</code> \u76ee\u5f55\u4e0b\u3002</p> <p>\u5185\u6838\u7684 Makefile \u4f1a\u8c03\u7528 <code>scripts/pack.py</code> \u811a\u672c\u751f\u6210\u4e00\u4e2a <code>link_app.S</code>\uff0c\u800c\u5b83\u8d1f\u8d23\u6700\u7ec8\u5c06\u6240\u6709\u7528\u6237\u7684 ELF \u6253\u5305\u8fdb\u5185\u6838\u955c\u50cf\u7684 rodata \u6bb5\u3002</p>"},{"location":"laben/lab2/","title":"C Language Basics &amp; Makefile","text":"<p>C Language Basics</p> <p>If you haven't learned C, we strongly recommend that you watch Teacher Yu's C/C++ course in advance: https://www.bilibili.com/video/BV1Vf4y1P7pq. Watching up to Chapter 6.5 will help you understand the basic syntax of C.</p> <p>RISC-V Assembly</p> <p>We expect that you have completed the \"Computer Organization\" course and understand the basics of RISC-V assembly.</p> <p>Additionally, always keep \"The RISC-V Instruction Set Manual, Volume I: User-Level ISA, Version 2.1\" (riscv-spec-v2.1.pdf) and \"The RISC-V Instruction Set Manual, Volume II: Privileged Architecture, Document Version 20211203\" (riscv-privileged-20211203.pdf) as reference manuals for RISC-V assembly.</p>"},{"location":"laben/lab2/#types","title":"Types","text":"<p>In C, integer types include long, int, short, char, etc. In most cases, the int type is 32 bits long, while the length of the long type depends on the ABI (Application Binary Interface, specified by the user during compilation). To avoid inconsistencies in the actual length of long, int, etc., due to differences in compilation target architectures, we use fixed-length integer types such as uint64_t, int32_t, etc., in system programming. In different ABI/compiler environments, using these types ensures they are of the specified length.</p> <p>For example, in <code>os/types.h</code>:</p> os/types.h<pre><code>typedef unsigned int uint;\ntypedef unsigned short ushort;\ntypedef unsigned char uchar;\ntypedef unsigned char uint8;\ntypedef unsigned short uint16;\ntypedef unsigned int uint32;\ntypedef unsigned long uint64;\n</code></pre> <p>We define <code>uint64</code>, <code>uint32</code>, etc., as <code>unsigned long</code> and <code>unsigned int</code>, respectively. Since we are programming for the riscv64 architecture, we can ensure that in our XV6, they are 64/32 bits.</p> <p>unsigned</p> <p>Note that in C, the default type for integer literals within the range of the int type is int.</p> <p>When an unsigned int is compared with a signed integer (e.g., int), the signed integer is promoted to unsigned int. If the constant is negative, it may become a very large unsigned value after promotion, leading to unexpected comparison results.</p> <p>Try executing the following code and observe the result:</p> <p></p>"},{"location":"laben/lab2/#pointers","title":"Pointers","text":"<p>A pointer is a variable type in programming languages that stores the memory address of another variable. Through pointers, you can indirectly access and manipulate the values of other variables. Pointers are commonly used in dynamic memory allocation, function parameter passing, and the implementation of data structures (e.g., linked lists, trees, etc.).</p> <ol> <li> <p>Pointer \"content\": It stores a memory address, not the data value directly. For example, pointer p can store the memory address of variable x, not the value of x.</p> </li> <li> <p>Pointer type: A pointer has a type, indicating the type of variable it points to. For example, <code>int* p</code> means p is a pointer to an int.</p> </li> <li> <p>Dereferencing: The process of accessing the variable a pointer points via the pointer to is called dereferencing. In C, you can dereference a pointer using the * operator to get the value it points to.</p> </li> <li> <p>Address-of: All variables stored in memory can have their addresses taken. We use <code>&amp;</code> to denote taking the address of a variable.</p> </li> </ol> <p>For example:</p> <pre><code>int a = 10;     // Define a variable a, initialized to 10.\nint *p = &amp;a;    // Take the memory address of variable a and store it in pointer p.\n*p = 20;        // Modify the memory address pointed to by p to 20.\n\nint b = 30;\nint **pp = &amp;p;  // Take the address of variable p and store it in pointer pp.\n*pp = &amp;b;       // Change the content of pointer p (the address it points to) to the address of variable b.\n**pp = 50;      // Double dereference.\n\nprintf(\"a: %d, b:%d\\n\", a, b);  // Output: a:20, b:50.\n</code></pre> <p>A diagram to understand pointers:</p> <p></p>"},{"location":"laben/lab2/#structs","title":"Structs","text":"<p>We use the <code>struct</code> keyword to indicate that the type is a struct. A struct is a collection of data packed together.</p> <p>For example, we declare a struct <code>struct proc</code> with the following fields:</p> <pre><code>struct proc {\n    int pid;\n    char* name;\n    void* chan;\n    uint64 krkr;\n    uint8 dkdk;\n};\n</code></pre> <p>We use the <code>.</code> operator to access a field of a struct variable and the <code>-&gt;</code> operator to dereference a field of a struct pointer.</p> <pre><code>struct proc p1;\np1.pid = 1234;\n\nstruct proc *pProc = &amp;p1;\npProc-&gt;name = \"proc 1234\";\n</code></pre>"},{"location":"laben/lab2/#compilation-system","title":"Compilation System","text":"<p>In the \"Computer Organization\" course, we briefly introduced the compilation system of C. Typically, compiling a program involves the following steps:</p> <p></p> <ol> <li>The source code .c file is preprocessed by the Pre-processor cpp to generate the .i file.</li> </ol> <p>The .i file is an intermediate file generated during the preprocessing stage of GCC, containing expanded header files, macro definitions, and conditionally compiled code. Use <code>gcc -E</code> to generate the .i file.</p> <ol> <li>The .i file is compiled by the cc1 compiler to generate the assembly file .s.</li> </ol> <p>The compiler performs syntax checking on the .i file. If no errors are found, it converts the .i file into assembly code (human-readable machine code). During this process, the optimizer can optimize the code.</p> <ol> <li>The .s file is assembled by the assembler as to generate the Relocatable objects (relocatable file) .o.</li> </ol> <p>During this process, the assembler converts assembly code into object code (machine code\u2014code that can be directly executed by the machine, not human-readable).</p> <ol> <li>The linker ld links all .o files to generate the final executable.</li> </ol> <p>On Linux systems, object files and executables are typically stored in the ELF (Executable and Linkable Format) file format.    ELF files are divided into different sections, which store specific types of data, such as code (.text), data (.data), and the symbol table (.symtab). Each section has its specific purpose and attributes.</p> <p>Typically, we use \"compiler\" to refer to all the tools used in the compilation and linking process, even though the compiler and linker are two different programs. Specifically, when discussing the compiler and linker, we collectively refer to the tools that perform preprocessing, assembly, and compilation as the compiler; the tool used in the final linking step is called the linker.</p> Experiment Step 1: Observing the C Compilation Process <p>Below is a simple C code example suitable for observing the <code>.i</code>, <code>.s</code>, and <code>.o</code> files during the GCC compilation process:</p> <pre><code>// main.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int b = 20;\n    int sum = a + b;\n    printf(\"Sum: %d\\n\", sum);\n    return 0;\n}\n</code></pre>"},{"location":"laben/lab2/#observing-the-compilation-process","title":"Observing the Compilation Process","text":"<ol> <li> <p>Preprocessing: Generate the <code>.i</code> file    <pre><code>gcc -E main.c -o main.i\n</code></pre>    This generates the <code>main.i</code> file, which contains the preprocessed code (macro expansion, header file inclusion, etc.). You can view its contents using <code>cat main.i</code>.</p> </li> <li> <p>Compilation: Generate the <code>.s</code> file    <pre><code>gcc -S main.i -o main.s\n</code></pre>    This generates the <code>main.s</code> file, which contains the assembly code. You can view its contents using <code>cat main.s</code>.</p> </li> <li> <p>Assembly: Generate the <code>.o</code> file    <pre><code>gcc -c main.s -o main.o\n</code></pre>    This generates the <code>main.o</code> file, which contains the object code (machine code). You can analyze the contents of <code>main.o</code> using the <code>objdump</code> tool. For example, use <code>objdump -d hello.o</code> to view the machine code and its corresponding assembly instructions.</p> </li> <li> <p>Linking: Generate the executable    <pre><code>gcc main.o -o main\n</code></pre>    This generates the executable <code>main</code>. You can check the file type of <code>main</code> using <code>file main</code>, which should be ELF. You can use the <code>readelf</code> tool from the GNU Binutils toolset to view the ELF file's header, section information, symbol table, dynamic section information, etc. For example, use <code>readelf -h main</code> to view the file header of <code>main</code>.</p> </li> </ol>"},{"location":"laben/lab2/#definition-and-declaration","title":"Definition and Declaration","text":"<p>Definition and Declaration are two concepts in C that are easily confused.</p> <p>Declaration declares a symbol (variable, function, etc.) and some basic information about it (e.g., variable type, function parameter types, function return type). This allows the compiler to use this type information for code generation during the compilation phase.</p> <p>Definition, on the other hand, actually allocates a memory address for the symbol. The linker during the linking phase assigns addresses to these symbols (e.g., function addresses, global variable addresses).</p> <p>Symbol</p> <p>In C, a symbol is a name used by the compiler to represent various entities in a program (e.g., variables, functions, macros, type names, etc.). Each symbol is associated with a specific memory address or other resource during compilation. When a program is compiled, the compiler creates a symbol table (Symbol Table) to record the names, types, scopes, and corresponding memory addresses or values of these symbols.</p> <p>In short, a symbol is a name representing an entity in a program, and the compiler manages and resolves these names through the symbol table.</p> <p>When the compiler compiles a <code>.c</code> file, it processes the source code line by line and maintains a symbol table representing all symbols seen so far in the current file. When the compiler encounters a reference to a symbol (variable reference, function call), it looks up this symbol table; when the compiler encounters a declaration or definition of a symbol, it saves information about this symbol in the symbol table.</p> <p>Therefore, we must ensure that when referencing a symbol, it has at least been declared, i.e., seen by the compiler. At the same time, in the same file, a definition is also a declaration.</p> <p>For the compiler, if a <code>.c</code> file needs to reference functions or variables from other <code>.c</code> files, it must declare them in advance. When the compiler encounters a symbol that has been declared but not defined in the current file (e.g., printf), the compiler assumes that the symbol will be defined in other object files, leaves some information, and lets the linker find the symbol during the linking phase.</p> <p>For example, <code>a.c</code> defines the variable <code>int a</code>. If <code>main.c</code> wants to reference it, it needs to declare it using <code>extern int a</code>.</p> <pre><code>// a.c\nint a;\n\n// main.c\nextern int a;\nint main() {\n    printf(\"%d\\n\", a);\n}\n</code></pre> <p>During compilation, we first compile <code>a.c</code> and <code>main.c</code> into <code>a.o</code> and <code>main.o</code>, respectively: <code>gcc -c a.c -o a.o</code>, <code>gcc -c main.c -o a.o</code>, then link the two .o files: <code>gcc main.o a.o</code> to generate the executable a.out.</p> <p>When compiling <code>a.c</code>, the compiler-generated <code>a.o</code> indicates that it has a globally visible symbol named <code>a</code>. When compiling <code>main.c</code>, the compiler does not know anything about other .c files. However, we declared the variable <code>a</code> in the first line, so it knows that there will be a symbol named <code>a</code> during linking. The compiler-generated <code>main.o</code> indicates that it needs a symbol named <code>a</code>.</p> <p>The linker will search the symbol tables of all <code>.o</code> files and match symbols based on names and visibility.</p> <p>To organize large projects, we do not manually import symbols from other <code>.c</code> files in each <code>.c</code> file. Instead, we use header files to declare these shared symbols.</p>"},{"location":"laben/lab2/#header-files","title":"Header Files","text":"<p>The purpose of a header file (Header File) is to declare functions, variables, macro definitions, constants, types, etc., to be shared across multiple source files. We use the <code>#include</code> macro at the beginning of <code>.c</code> files to import header files. Its semantics is to directly copy the file content into the current file, a step performed by the preprocessor.</p> <p>If a <code>.c</code> file has types, functions, or variables that need to be referenced by other <code>.c</code> files, we create a corresponding header file. When naming header files, we generally use the same filename but with a <code>.h</code> suffix; for example, for shared information in <code>a.c</code>, we create its header file <code>a.h</code>.</p> <p>For shared functions and variables, we typically declare them in <code>a.h</code> and define them in <code>a.c</code>:</p> <pre><code>// a.h\nextern int a;\nint add(int x, int y);\n\n// a.c\nint a;\n// or int a = 10;\nint add (int x, int y) {\n    return x + y;\n}\n</code></pre> <p>If <code>main.c</code> needs to reference the <code>a</code> variable or <code>add</code> function provided by <code>a.c</code>, it can include the <code>a.h</code> header file at the beginning:</p> <pre><code>// main.c\n#include \"a.h\"\n\nint main() {\n    a = 666;\n    int b = 123;\n    int c = add(a, b);\n}\n</code></pre> <p>Note</p> <ul> <li> <p>A global variable declared and defined in a <code>.c</code> file cannot be directly used by other <code>.c</code> files. For example, if you have <code>int a;</code> in one <code>.c</code> file, you need <code>extern int a;</code> in another file for the two files to share the same <code>a</code>.</p> </li> <li> <p>When defining global variables in multiple <code>.c</code> files, we must ensure the variable names are unique. Otherwise, it will lead to multiple definitions.</p> </li> <li> <p>If we want to define global variables visible only to the current <code>.c</code> file, we can use the <code>static</code> keyword.</p> </li> <li> <p>Header files can only declare variables. If a header file defines a variable and more than one <code>.c</code> file includes this header file, it will also result in multiple definitions because the preprocessor directly copies the included content into the current file, causing both <code>.c</code> files to define the variable.</p> </li> <li> <p>If you want a variable to be shared across multiple <code>.c</code> files, you can declare the variable in the header file using the <code>extern</code> keyword and define it in any one <code>.c</code> file.</p> </li> </ul>"},{"location":"laben/lab2/#readelf-to-read-the-symbol-table","title":"readelf to Read the Symbol Table","text":"<p>Let's explain the difference between Declaration and Definition again:</p> <ul> <li> <p>Definition tells the linker that this .o file contains a symbol, and the linker needs to allocate a memory address for it. If other .o files need to reference this symbol, it must check whether the symbol allows external access, i.e., whether <code>static</code> was used during declaration.</p> </li> <li> <p>Declaration assures the compiler that the symbol will be found during linking, whether it is defined in the current <code>.c</code> file or other <code>.c</code> files. The compiler only needs to generate code based on the declared variable type or function prototype (e.g., the width of variable access (lb, lw, ld), the number of function parameters), and the linker is responsible for finding these symbols.</p> </li> </ul> <p>We can use <code>llvm-readelf-19 --symbol &lt;file&gt;</code> to view the symbol table of an ELF file. The meaning of the fields can be referenced at https://docs.oracle.com/cd/E19455-01/816-0559/chapter6-79797/index.html.</p> <pre><code>$ llvm-readelf-19 --symbols build/os/proc.o | grep -E \"FUNC|OBJECT|GLOBAL\"\nSymbol table '.symtab' contains 1240 entries:\n   Num:    Value          Size Type    Bind   Vis       Ndx Name\n     5: 0000000000000000    72 FUNC    LOCAL  DEFAULT     1 curr_proc\n    23: 0000000000000048   304 FUNC    LOCAL  DEFAULT     1 freeproc\n    97: 0000000000000178    92 FUNC    LOCAL  DEFAULT     1 first_sched_ret\n   128: 0000000000000000     4 OBJECT  LOCAL  DEFAULT     6 proc_inited.1\n   237: 0000000000000000     4 OBJECT  LOCAL  DEFAULT     7 PID.0\n   663: 0000000000000000    32 OBJECT  LOCAL  DEFAULT     4 pid_lock\n   664: 0000000000000020    32 OBJECT  LOCAL  DEFAULT     4 wait_lock\n   665: 0000000000000040   104 OBJECT  LOCAL  DEFAULT     4 proc_allocator\n  1201: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND push_off\n  1202: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND mycpu\n  1203: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND pop_off\n  1210: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND usertrapret\n  1211: 00000000000001d4   544 FUNC    GLOBAL DEFAULT     1 proc_init\n  1212: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND spinlock_init\n  1213: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND allocator_init\n  1214: 00000000000000a8  4096 OBJECT  GLOBAL DEFAULT     4 pool\n  1215: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kernel_pagetable\n  1216: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kallocpage\n  1217: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kalloc\n  1218: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND memset\n  1219: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT   UND kvmmap\n</code></pre> <p>The Type column indicates whether the symbol is a function (FUNC) or a variable (OBJECT). Bind indicates whether the symbol allows other .o files to find it (LOCAL/GLOBAL). Ndx indicates whether the symbol is defined in this .o file. <code>UND</code> means it is an external <code>.o</code>, i.e., a symbol that needs to be imported from other .o files, so its Type and Size are unknown.</p> <p>Now, do you understand the reasons for the two common linking errors: multiple definition and undefined reference?</p> <ul> <li><code>riscv64-unknown-elf-ld: build/os/proc.o:os/proc.c:14: multiple definition of 'idle'; build/os/main.o:os/main.c:7: first defined here</code><ul> <li>The <code>idle</code> variable was defined multiple times in different .c files.</li> </ul> </li> <li><code>riscv64-unknown-elf-ld: build/os/proc.o: in function 'proc_init': os/proc.c:38:(.text+0xd0): undefined reference to 'idle'</code><ul> <li>The <code>idle</code> variable was declared in the header file but not defined.</li> </ul> </li> </ul>"},{"location":"laben/lab2/#make-and-makefile-introduction","title":"Make and Makefile Introduction","text":"<p>Consider a scenario where our project is slightly larger (e.g., containing multiple C files). Every time we run it, we have to execute many gcc commands. Is there a compilation tool that can simplify this process? Next, we introduce the automated build tool, make.</p> <p><code>Makefile</code> is a configuration file used for automating the build process (compilation, linking, etc.) of programs, typically used to manage projects with multiple source files. It defines how to generate target files (e.g., executables, library files) from source code and ensures that only the parts that need updating are recompiled, improving build efficiency.</p> <p><code>Makefile</code> is the input file for the <code>make</code> tool, a classic build tool widely used in Unix/Linux systems.</p> Experiment Step 2: Using Makefile for Automated Build <p>First, we create three files:</p> <pre><code>//print.h header file\n#include &lt;stdio.h&gt;\nvoid print(void);\n\n//print.c\n#include \"print.h\"\nvoid print(){\n    printf(\"Hello, World!\\n\");\n}\n\n//main.c\n#include \"print.h\"\nint main(){\n    print();\n    return 0;\n}\n</code></pre> <p>Due to the dependencies in the files, if we want to run the above code, we need to generate .o object files for each .c file and then link the two .o files to generate the executable:</p> <pre><code>gcc -c main.c\ngcc -c print.c\ngcc -o main main.o print.o\n\n./main\n</code></pre> <p></p> <p></p> <p>As you can see, if we have many files, running the program becomes very complex. To make the compilation process easier, we can use a Makefile.</p> <p>Next, we create a text file named Makefile.</p> <p>Makefile content:</p> <pre><code>main : main.o print.o\n    gcc -o main main.o print.o\nmain.o : main.c print.h\n    gcc -c main.c\nprint.o : print.c print.h\n    gcc -c print.c\nclean:\n    rm main main.o print.o\n</code></pre> <p>Warning</p> <p>In Makefile, indentation must be done with tabs, not spaces; otherwise, it will not execute properly.</p> <p>Finally, we only need to execute the <code>make</code> command to complete the entire compilation process:</p> <p></p>"},{"location":"laben/lab2/#basic-structure-of-makefile","title":"Basic Structure of Makefile","text":"<pre><code>target: dependencies\n[tab] system command\n</code></pre>"},{"location":"laben/lab2/#how-makefile-works","title":"How Makefile Works","text":"<p>By default, when we only enter the <code>make</code> command:</p> <ol> <li>make looks for a file named \"Makefile\" or \"makefile\" in the current directory.</li> <li>If found, it looks for the first target file (target) in the file. In the example above, it finds the \"main\" file and uses it as the final target file.</li> <li>If the main file does not exist, or if the modification time of the <code>.o</code> files it depends on is newer than the <code>main</code> file, it executes the commands defined later to generate the <code>main</code> file.</li> <li>If the <code>.o</code> files that <code>main</code> depends on do not exist, make looks for the dependencies of the <code>.o</code> files in the current file. If found, it generates the <code>.o</code> files according to that rule. (like a stack process)</li> <li>Obviously, your C and Header files exist, so make generates the <code>.o</code> files and then uses them to generate make's ultimate task, the executable <code>main</code>.</li> </ol>"},{"location":"laben/lab2/#make-clean","title":"make clean","text":"<p>From the above analysis, we know that commands like clean, which are not directly or indirectly associated with the first target file, will not be executed automatically. However, we can explicitly ask make to execute them. For example, the command <code>make clean</code> clears all object files for recompilation.</p> <p>For more information about Makefile, refer to: How to Write Makefile 1.0 Documentation</p>"},{"location":"laben/xv6lab-baremetal/","title":"Bare Metal Programming","text":"<p>When programming in a Linux environment, the <code>libc</code> functions and well-encapsulated system calls provided by the Linux environment allow us to focus primarily on the logic of our program to interact with the operating system. For instance, when we use <code>printf</code> and <code>scanf</code> to operate on standard input/output streams, the user-space runtime environment is provided by <code>libc</code>, while the kernel environment is supplied by the Linux Kernel.</p> <p>However, when writing our own operating system, we lack the runtime environment provided by Linux or any other operating system. Instead, we interact directly with the CPU and hardware. Such programs, which directly interface with the CPU and hardware, are called bare-metal programs.</p> <p>What is a Bare-Metal Program</p> <p>A bare-metal program is a type of software that runs directly on the hardware of a device without relying on an underlying operating system (OS). Essentially, it's code that interacts with the hardware at the most fundamental level, controlling the processor, memory, input/output (I/O) devices, and other components directly.</p> <p>In our xv6 experiments, we will write operating system programs on the RISC-V architecture.</p> Lab Step 1: Running the First Bare-Metal Program <p>xv6-lab1 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab1</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab1 xv6lab1</code> to download the xv6-lab1 code.</p> <p>It is recommended to download the code for each lab in a separate location.</p> <p>After cloning the repository, you can run <code>make</code> locally to compile the xv6 kernel. Once the kernel is successfully compiled with <code>make</code>, you can use <code>make run</code> to invoke QEMU and run our first xv6 operating system.</p> <p>The <code>make run</code> command executes the following: <code>qemu-system-riscv64 -nographic -machine virt -cpu rv64 -m 512 -kernel build/kernel</code>, which means:</p> <ul> <li>Use <code>qemu-system-riscv64</code> to emulate a RISC-V 64-bit CPU.</li> <li><code>-nographic</code>: Disable graphical output.</li> <li><code>-machine virt</code>: Use the <code>virt</code> machine model.</li> <li><code>-cpu rv64</code>: Use a RISC-V 64-bit CPU.</li> <li><code>-m 512</code>: Specify 512 MiB of memory.</li> <li><code>-kernel build/kernel</code>: Load the kernel file from <code>build/kernel</code>.</li> </ul> <p>What is QEMU?</p> <p>QEMU is an open-source virtual machine software that can emulate various hardware platforms, including x86, ARM, MIPS, SPARC, and more. It supports running multiple operating systems such as Linux, Windows, macOS, FreeBSD, etc. QEMU is widely used for virtualization, emulation, debugging, and testing in various scenarios. It supports full-system emulation and user-mode emulation, allowing users to run operating systems and programs designed for one architecture on a different architecture.</p> <p>In our operating system course, we use a virtual machine running a Linux system on an existing OS. Within this Linux system, we use QEMU to emulate a RISC-V 64-bit architecture virtual machine, on which we run the operating system we develop.</p> <p>The output of running the program is as follows:</p> <pre><code>$ make run\nqemu-system-riscv64 -nographic -machine virt -cpu rv64 -m 512 -kernel build/kernel \n\nOpenSBI v1.5\n   ____                    _____ ____ _____\n  / __ \\                  / ____|  _ \\_   _|\n | |  | |_ __   ___ _ __ | (___ | |_) || |\n | |  | | '_ \\ / _ \\ '_ \\ \\___ \\|  _ &lt; | |\n | |__| | |_) |  __/ | | |____) | |_) || |_\n  \\____/| .__/ \\___|_| |_|_____/|____/_____|\n        | |\n        |_|\n\nPlatform Name             : riscv-virtio,qemu\nPlatform Features         : medeleg\nPlatform HART Count       : 1\nPlatform IPI Device       : aclint-mswi\nPlatform Timer Device     : aclint-mtimer @ 10000000Hz\nPlatform Console Device   : uart8250\nPlatform HSM Device       : ---\nPlatform PMU Device       : ---\nPlatform Reboot Device    : syscon-reboot\nPlatform Shutdown Device  : syscon-poweroff\nPlatform Suspend Device   : ---\nPlatform CPPC Device      : ---\nFirmware Base             : 0x80000000\nFirmware Size             : 327 KB\nFirmware RW Offset        : 0x40000\nFirmware RW Size          : 71 KB\nFirmware Heap Offset      : 0x49000\nFirmware Heap Size        : 35 KB (total), 2 KB (reserved), 11 KB (used), 21 KB (free)\nFirmware Scratch Size     : 4096 B (total), 416 B (used), 3680 B (free)\nRuntime SBI Version       : 2.0\n\nDomain0 Name              : root\nDomain0 Boot HART         : 0\nDomain0 HARTs             : 0*\nDomain0 Region00          : 0x0000000000100000-0x0000000000100fff M: (I,R,W) S/U: (R,W)\nDomain0 Region01          : 0x0000000010000000-0x0000000010000fff M: (I,R,W) S/U: (R,W)\nDomain0 Region02          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()\nDomain0 Region03          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()\nDomain0 Region04          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()\nDomain0 Region05          : 0x000000000c400000-0x000000000c5fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region06          : 0x000000000c000000-0x000000000c3fffff M: (I,R,W) S/U: (R,W)\nDomain0 Region07          : 0x0000000000000000-0xffffffffffffffff M: () S/U: (R,W,X)\nDomain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\nDomain0 SysReset          : yes\nDomain0 SysSuspend        : yes\n\nBoot HART ID              : 0\nBoot HART Domain          : root\nBoot HART Priv Version    : v1.12\nBoot HART Base ISA        : rv64imafdch\nBoot HART ISA Extensions  : sstc,zicntr,zihpm,zicboz,zicbom,sdtrig\nBoot HART PMP Count       : 16\nBoot HART PMP Granularity : 2 bits\nBoot HART PMP Address Bits: 54\nBoot HART MHPM Info       : 16 (0x0007fff8)\nBoot HART Debug Triggers  : 2 triggers\nBoot HART MIDELEG         : 0x0000000000001666\nBoot HART MEDELEG         : 0x0000000000f0b509\n\nclean bss: 0x0000000080207000 - 0x0000000080207000\nKernel booted.\nHello World!\nsysregs:\nsstatus : 0x8000000200006000\nscause  : 0x0000000000000000\nsepc    : 0x0000000000000000\nstval   : 0x0000000000000000\nsip     : 0x0000000000000000\nsie     : 0x0000000000000000\nsatp    : 0x0000000000000000\n0x00000000deadbeef\nkernel ends, parking...\n</code></pre> <p>How to Exit QEMU</p> <p>Press <code>Ctrl</code> and <code>A</code> simultaneously, release them, then press <code>X</code>.</p> <p>If this method doesn\u2019t work due to prior key presses, you can directly close the terminal.</p> <p>Lab Step 1 Completed</p> <p>The above lab process demonstrates the boot process of a minimal kernel. Next, we will explain how an operating system starts running from the perspective of privilege levels. First, let\u2019s understand what privilege levels are.</p>"},{"location":"laben/xv6lab-baremetal/#privilege-levels","title":"Privilege Levels","text":"<p>Privilege Levels (riscv-privileged.pdf)</p> <p>Privilege levels is a concept in computer systems used to define the access control and permissions that different processes or users have within the system. The existence of privilege levels aims to protect system resources, ensure security, and isolate processes based on trust and functionality.</p> <p>At any time, a RISC-V hardware thread (hart) is running at some privilege level encoded as a mode in one or more CSRs (control and status registers). </p> <p>Three RISC-V privilege levels are currently defined as shown in Table 1.1. </p> <p>Privilege levels are used to provide protection between different components of the software stack, and attempts to perform operations not permitted by the current privilege mode will cause an exception to be raised. </p> <p>These exceptions will normally cause traps into an underlying execution environment.</p> <p>Privilege levels are a critical state of the CPU during execution, indicating the level of privilege the currently running code possesses. Code with the highest privilege level has unrestricted access to all resources, such as all physical memory and peripherals. Higher privilege levels can restrict the resources accessible to lower privilege levels. For example, a lower privilege level cannot access memory or CSR registers owned by a higher privilege level. However, when the CPU is running at a lower privilege level, the program can actively or passively switch to a higher privilege level and execute predefined code.</p> <p>Why Privilege Levels Are Needed</p> <p>The primary purpose of introducing privilege levels in CPU design is to ensure system security and stability. In modern computer systems, the operating system needs to strictly manage and control hardware resources. Privilege levels help the operating system isolate the kernel from user programs, preventing untrusted code or applications from improperly manipulating critical system components.</p> <p>For example, CPU time is an important \"hardware resource.\" Modern operating systems achieve the illusion that multiple user programs are running simultaneously by scheduling them to execute in turns. The operating system (running at a high privilege level) manages CPU time by forcing an application to pause after executing for a certain period, switching to the next application.  </p> <p>Without privilege levels to enforce this, relying on applications to voluntarily yield CPU time would allow a malicious program to monopolize the CPU, causing all other applications on the system to become unresponsive.</p> <p>Privilege levels are implemented in the CPU hardware circuitry, not simulated through software. In RISC-V, privilege levels are distinguished using 2 bits, defining three modes: M mode, S mode, and U mode.</p> <p></p> <p>The machine level has the highest privileges and is the only mandatory privilege level for a RISC-V hardware platform. Code run in machine-mode (M-mode) is usually inherently trusted, as it has low-level access to the machine implementation. M-mode can be used to manage secure execution environments on RISC-V. User-mode (U-mode) and supervisor-mode (S-mode) are intended for conventional application and operating system usage respectively.</p> <ul> <li>M mode: The highest privilege level in the RISC-V architecture, typically running firmware like OpenSBI, with direct access to physical memory.</li> <li>S mode: Designed for operating systems, capable of setting up virtual memory.</li> <li>U mode: Designed for user programs, with the least privileges, also supporting virtual memory.</li> </ul> <p>In bare-metal programming, we need to initialize the CPU state, including basic functionalities like page tables and interrupts.  These CPU states are controlled via CSRs (Control and Status Registers), which are generally only accessible and modifiable by higher privilege levels.</p>"},{"location":"laben/xv6lab-baremetal/#aarch64-x86","title":"AArch64 &amp; x86","text":"<p>Modern instruction set architectures all define different privilege levels.</p> <p>The AArch64 (ARM64) architecture, commonly used in mobile devices, defines four privilege levels (Exception Levels) from lowest to highest: EL0, EL1, EL2, and EL3.  Similar to RISC-V, the highest privilege level, EL3, runs low-level firmware (Secure Monitor), EL1 runs the operating system (OS), EL0 runs user programs, and EL2 runs virtual machine programs (Hypervisor).</p> <p>The x86 (IA32 &amp; AMD64) architecture defines privilege levels as four Rings: Ring 0 is the highest privilege level, running the operating system, while Ring 3 is the lowest, running user programs. Typically, x86 systems only use Ring 0 and Ring 3.</p> <p></p>"},{"location":"laben/xv6lab-baremetal/#csr-control-and-status-registers","title":"CSR (Control and Status Registers)","text":"<p>Unlike the 32 general-purpose registers, CSRs are special registers.</p> <p>CSR (Control and Status Registers) are critical register sets used to control CPU behavior, store system state, and manage exceptions and interrupts. CSRs require special instructions to access.</p> <p>Each CSR has privilege-level restrictions. For example:The <code>time</code> and <code>cycle</code> registers can be read by U mode but cannot be modified.S-mode CSRs like <code>sstatus</code> can be read and written by S mode and M mode.M-mode CSRs like <code>mstatus</code> can only be read and written by M mode.  Attempting to access a higher-privilege CSR from a lower privilege level will trigger an exception.</p> <p>Each CSR contains defined fields that occupy specific bits, representing particular meanings. We\u2019ll explore CSRs further in subsequent lessons.</p>"},{"location":"laben/xv6lab-baremetal/#runtime-environment","title":"Runtime Environment","text":"<p>Across the three privilege levels in RISC-V, the architecture defines three runtime states: Firmware (Machine mode), Operating System (Supervisor mode), and User Mode (User mode).</p> <p>In RISC-V, the runtime environment provided by the operating system (Supervisor) to applications is called the ABI (Application Binary Interface), while the runtime environment provided by the firmware (Machine mode, SEE) to the operating system (Supervisor, OS) is called the SBI (Supervisor Binary Interface).</p> <p></p> <p>OpenSBI provides access interfaces to basic hardware and offers services to S mode through a syscall-like mechanism known as SBI Calls. These include basic serial I/O functions like <code>sbi_console_putchar</code> and <code>sbi_console_getchar</code>.</p>"},{"location":"laben/xv6lab-baremetal/#boot-process-overview","title":"Boot Process Overview","text":"<p>The boot process of an operating system involves initializing each level of the runtime environment. Typically, we start initializing from the highest privilege level and progressively descend to lower privilege levels.</p> <p>From the moment the CPU powers on and resets, it begins executing the first instruction. At this point, the CPU typically executes code from a small ROM area, either internal or external to the chip, known as the Bootloader. The bootloader can be considered \"Stage 0\" of the boot process, with its primary tasks being to locate the next stage\u2019s image, copy it into memory, and jump to it.</p> <p>On the RISC-V platform, the next stage is the initialization of the SBI (Supervisor Binary Interface), which we implement using OpenSBI. Thus, in Stage 0, the OpenSBI image and our kernel image are loaded into memory. The bootloader then jumps the CPU to the OpenSBI load address, starting its execution and entering the next stage.</p> <p></p> <p>In this stage, OpenSBI initializes critical system devices. Once OpenSBI completes the M mode initialization, it downgrades the CPU privilege to S mode and jumps to the kernel\u2019s entry point, officially starting kernel code execution.</p> <p>Below, we\u2019ll explain the tasks of each stage in detail:</p>"},{"location":"laben/xv6lab-baremetal/#stage-0-from-cpu-power-on","title":"Stage 0: From CPU Power-OnLab Step 2: GDB Debugging to Observe the Boot Process","text":"<p>Upon powering on, the CPU undergoes a hardware-level reset. Recall how, in digital logic courses, we reset a <code>reg</code> variable when <code>rst_n</code> is triggered.</p> <p>The reset sets the Program Counter (PC) to a fixed value called the Reset Vector, the address of the first instruction executed after power-on. This address typically points to a Block ROM on the RISC-V chip, a read-only code region. After executing the Reset Vector code, control flow jumps to the next stage. In QEMU, this next stage is the M mode OpenSBI.</p> <p>What is Implementation-Defined Behavior?</p> <p>The Reset Vector value for each RISC-V hardware is determined by its implementation. The RISC-V manual does not mandate a specific Reset Vector value, making it Implementation-Defined.</p> <p>GDB Debugging</p> <p>GDB (GNU Debugger) is a powerful open-source debugging tool, primarily used for debugging programs written in languages like C and C++. It helps developers identify and fix errors by supporting features such as setting breakpoints, stepping through code, inspecting variable values, and checking memory states.</p> <p>Using GDB, we can set breakpoints and observe the operating system\u2019s execution process while running it in QEMU.</p> <p>First, add the line <code>set auto-load safe-path /</code> to your <code>~/.gdbinit</code> file to allow GDB to automatically load the <code>.gdbinit</code> file in the current directory.</p> <p>In one terminal, run <code>make debug</code>. This launches <code>qemu-system-riscv64</code> with the parameters <code>-S -gdb tcp::3333</code>, indicating that it will wait for a debugger to attach. Then, in another terminal (ensuring the working directory matches the first terminal), run <code>gdb-multiarch</code>. This starts the GDB debugger and automatically loads the <code>.gdbinit</code> file in the current directory.</p> <p>If everything works correctly, GDB will pause at address <code>0x1000</code>, the Reset Vector address for the QEMU platform.</p> <p></p> <p>Use the command <code>x/10i $pc</code> to print the next 10 instructions pointed to by the current PC.</p> <p>Lab Report 1</p> <p>Find the instruction address that QEMU\u2019s bootloader jumps to after completing execution.  </p> <p>Use <code>si</code> to step to the next instruction. When you reach <code>jr t0</code>, use <code>print $t0</code> to print the value of the <code>t0</code> register.  </p> <p>Record the value of the <code>t0</code> register in your lab report.</p> <p>Lab Report 2</p> <p>Determine what content QEMU loads into memory during startup.  </p> <p>Referring to Lab Report 1, open a GDB terminal and run the command <code>monitor info roms</code>. Fill the output information into the table in your lab report.  </p> <p>In each output line, <code>addr</code> indicates the starting address of the loaded content, <code>size</code> indicates the length of the content, and <code>mem=rom/ram</code> indicates whether the segment is read-only ROM or writable RAM.</p> <p>Lab Step 2 Completed</p>"},{"location":"laben/xv6lab-baremetal/#next-stage-opensbi","title":"Next Stage: OpenSBI","text":"<p>In computers, firmware is a specific type of software that provides low-level control for a device\u2019s hardware and can load further software. For complex software (like an operating system), firmware provides a standardized operating environment. For simpler devices, firmware may act as the complete operating system, handling all control, monitoring, and data manipulation functions. In x86-based systems, the firmware is BIOS or UEFI; in RISC-V-based systems, it is OpenSBI. OpenSBI runs in M mode because firmware requires direct hardware access.</p> <p>At this stage, OpenSBI initializes critical system devices, referred to as platform-level devices. These are shared across the system, meaning multiple CPUs (or HARTs) see the same device.</p> <p></p> <pre><code>Platform Name             : riscv-virtio,qemu\nPlatform Features         : medeleg\nPlatform HART Count       : 1\nPlatform IPI Device       : aclint-mswi\nPlatform Timer Device     : aclint-mtimer @ 10000000Hz\nPlatform Console Device   : uart8250\nPlatform HSM Device       : ---\nPlatform PMU Device       : ---\nPlatform Reboot Device    : syscon-reboot\nPlatform Shutdown Device  : syscon-poweroff\nPlatform Suspend Device   : ---\n</code></pre> <p>Next, OpenSBI designates the next stage as our kernel:</p> <pre><code>Domain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\n</code></pre> <p>It also initializes HART-related configurations:</p> <pre><code>Boot HART ID              : 0\nBoot HART Domain          : root\nBoot HART Priv Version    : v1.12\nBoot HART Base ISA        : rv64imafdch\n</code></pre>"},{"location":"laben/xv6lab-baremetal/#following-stage-kernel-boot","title":"Following Stage: Kernel Boot","text":"<p>After OpenSBI completes initialization, it downgrades to S mode and sets the PC to our kernel\u2019s starting address, <code>0x80200000</code>. This address holds the first instruction of the kernel\u2019s entry point, <code>_entry</code>, marking the point where CPU control is handed over to our xv6 kernel.</p> <p>The <code>_entry</code> code is located in the <code>entry.S</code> file. But how does this code end up at the kernel\u2019s starting address, <code>0x80200000</code>?</p>"},{"location":"laben/xv6lab-baremetal/#compilation-process","title":"Compilation Process","text":"<p>Let\u2019s examine the kernel compilation process:</p> <pre><code>$ /d/o/SUSTech-OS-2025 (xv6-lab1)&gt; make\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/console.c -o build/os/console.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/main.c -o build/os/main.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/printf.c -o build/os/printf.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/sbi.c -o build/os/sbi.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/string.c -o build/os/string.o\nriscv64-unknown-elf-gcc -fPIE -fno-pic -fno-plt -Wall -Wno-unused-variable -Werror -O -fno-omit-frame-pointer -ggdb -march=rv64g -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -Ios -std=gnu17 -fno-stack-protector -D LOG_LEVEL_ERROR -c os/entry.S -o build/os/entry.o\nriscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/printf.o build/os/sbi.o build/os/string.o build/os/entry.o\nriscv64-unknown-elf-objdump -S build/kernel &gt; build/kernel.asm\nriscv64-unknown-elf-objdump -t build/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; build/kernel.sym\nBuild kernel done\n</code></pre> <p>Let\u2019s break down the compilation parameters:</p> <p><code>gcc</code> is the familiar C compiler, while <code>riscv64-unknown-elf-gcc</code> specifies a GCC suite for RISC-V 64-bit, targeting an unknown platform and producing ELF-format output.</p> <p>Key compilation flags:</p> <ul> <li><code>-march=rv64g -mcmodel=medany -mno-relax</code>:  </li> </ul> <p>Targets the <code>rv64g</code> architecture, uses the <code>medany</code> addressing model, and disables linker relaxation.  </p> <p>See: https://gcc.gnu.org/onlinedocs/gcc/RISC-V-Options.html</p> <ul> <li><code>-ffreestanding -fno-common -nostdlib</code>:  </li> </ul> <p>Indicates no reliance on standard library functions and avoids assuming standard definitions for common functions (e.g., <code>memset</code>).</p> <ul> <li> <p><code>-fno-pie -no-pie -fno-plt -fno-omit-frame-pointer -fno-stack-protector</code>:  </p> <p>This indicates that the generated ELF file should not use Position-Independent Executable (PIE) code, as it would result in the creation of the Global Offset Table (GOT) and Procedure Linkage Table (PLT) sections. Our kernel is currently unable to handle such complex structures. <code>-fno-omit-frame-pointer -fno-stack-protector</code> means retaining the frame-pointer and disabling stack protection.</p> </li> <li> <p><code>-Wall -Wno-unused-variable -Werror -ggdb</code>: </p> </li> </ul> <p>Enables all warnings except for unused variables, treats warnings as errors, and includes GDB debugging info.</p> <ul> <li><code>-Ios -std=gnu17 -O2 -c os/entry.S -o build/os/entry.o</code>:  </li> </ul> <p>Uses the <code>os</code> directory for includes, adheres to the GNU17 C standard, enables O2 optimization</p> <p>compiles (<code>-c</code>) <code>os/entry.S</code> into <code>build/os/entry.o</code>.</p> <p>The linker (<code>ld</code>) combines all <code>.o</code> files into the final kernel ELF file. </p> <p><code>riscv64-unknown-elf-ld -z max-page-size=4096 -T os/kernel.ld -o build/kernel build/os/console.o build/os/main.o build/os/printf.o build/os/sbi.o build/os/string.o build/os/entry.o</code></p> <p>following series of commands indicates:</p> <ul> <li><code>-T os/kernel.ld</code>: Specifies <code>os/kernel.ld</code> as the linker script.</li> <li><code>-o build/kernel</code>: Outputs to <code>build/kernel</code>.</li> <li>Inputs are all <code>.o</code> files.</li> </ul>"},{"location":"laben/xv6lab-baremetal/#linker-script","title":"Linker Script","text":"<p>The <code>kernel.ld</code> linker script dictates how the linker arranges sections from the <code>.o</code> files (Memory Layout) and how the resulting ELF file is loaded into memory (Program Headers).</p> <p>Memory Layout</p> <p>Memory Layout refers to the organization and structure of a program\u2019s data and code in memory during execution.</p> <p>Here\u2019s the content of <code>kernel.ld</code>:</p> <pre><code>OUTPUT_ARCH(riscv)\nENTRY(_entry)\nBASE_ADDRESS = 0x80200000;\n\nSECTIONS\n{\n    . = BASE_ADDRESS;\n    skernel = .;\n\n    s_text = .;\n    .text : {\n        *(.text.entry)\n        *(.text .text.*)\n        . = ALIGN(4K);\n        e_text = .;\n    }\n\n    . = ALIGN(4K);\n    s_rodata = .;\n    .rodata : {\n        *(.rodata .rodata.*)\n    }\n\n    . = ALIGN(4K);\n    e_rodata = .;\n    s_data = .;\n    .data : {\n        *(.data.apps)\n        *(.data .data.*)\n    }\n\n    . = ALIGN(4K);\n    e_data = .;\n    .bss : {\n        *(.bss.stack)\n        s_bss = .;\n        *(.bss .bss.*)\n    }\n\n    . = ALIGN(4K);\n    e_bss = .;\n    ekernel = .;\n\n    /DISCARD/ : {\n        *(.eh_frame)\n    }\n}\n</code></pre> <p>The <code>OUTPUT_ARCH</code> at the beginning specifies that the generated ELF file is compatible with the RISC-V architecture, and <code>ENTRY</code> indicates that the entry point of the ELF file is the symbol <code>_entry</code>. Then, we define a constant <code>BASE_ADDRESS</code> and set it equal to <code>0x80200000</code>, which is also the starting address of our kernel.</p> <p>In the <code>SECTIONS</code> block, we first define the current address (represented by the <code>.</code> symbol) (imagine the linker is assigning locations to all sections starting from a certain address) as <code>0x80200000</code>, and export the values of the symbols <code>skernel</code> and <code>s_text</code> as the current address.</p> <p>Subsequently, we define the <code>.text</code> section, which typically represents the code segment:</p> <pre><code>.text : {\n    *(.text.entry)\n    *(.text .text.*)\n    . = ALIGN(4K);\n    e_text = .;\n}\n</code></pre> <p>Places <code>.text.entry</code> first (defined in <code>entry.S</code>), followed by other <code>.text</code> sections.</p> <p>The <code>.text.entry</code> section is defined in <code>entry.S</code>:</p> <pre><code>    .section .text.entry\n    .globl _entry\n_entry:\n</code></pre> <p>By placing <code>_entry</code> in <code>.text.entry</code> and prioritizing it in the linker script, we ensure <code>_entry</code> is at the kernel\u2019s starting address, <code>0x80200000</code>, where execution begins.</p> <p>Verify this via disassembly:</p> <pre><code>$ llvm-objdump-19 -d build/kernel | less\nbuild/kernel:   file format elf64-littleriscv\n\nDisassembly of section .text:\n\n0000000080200000 &lt;skernel&gt;:\n80200000: 00007117      auipc   sp, 0x7\n80200004: 00010113      mv      sp, sp\n80200008: 00000097      auipc   ra, 0x0\n8020000c: 174080e7      jalr    0x174(ra) &lt;main&gt;\n</code></pre> <p>Then, we align the current address to a 4K boundary and export the <code>e_text</code> symbol.</p> <p>Remaining sections:</p> <ul> <li><code>.rodata</code>: Read-only data.</li> <li><code>.data</code>: Read-write data.</li> <li><code>.bss</code>: Data initialized to zero at startup.</li> </ul> <p>All data sections are non-executable. </p> <p>Here\u2019s a diagram of the kernel image\u2019s memory layout:</p> <p></p> <p>Finally, inspect the ELF file with <code>readelf</code>:</p> <pre><code>$ /d/o/SUSTech-OS-2025 (xv6-lab1)&gt; llvm-readelf-19 -a build/kernel\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           RISC-V\n  Version:                           0x1\n  Entry point address:               0x80200000\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          29208 (bytes into file)\n  Flags:                             0x4, double-float ABI\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         4\n  Size of section headers:           64 (bytes)\n  Number of section headers:         19\n  Section header string table index: 18\nThere are 19 section headers, starting at offset 0x7218:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        0000000080200000 001000 001000 00  AX  0   0  4\n  [ 2] .rodata           PROGBITS        0000000080201000 002000 0001f0 00   A  0   0  8\n  [ 3] .data             PROGBITS        0000000080202000 003000 000008 00  WA  0   0  8\n  [ 4] .bss              NOBITS          0000000080203000 003008 004000 00  WA  0   0  1\n  [ 5] .debug_info       PROGBITS        0000000000000000 003008 0010c0 00      0   0  1\n  [ 6] .debug_abbrev     PROGBITS        0000000000000000 0040c8 0006e5 00      0   0  1\n  [ 7] .debug_loclists   PROGBITS        0000000000000000 0047ad 0004b5 00      0   0  1\n  [ 8] .debug_aranges    PROGBITS        0000000000000000 004c70 000130 00      0   0 16\n  [ 9] .debug_line       PROGBITS        0000000000000000 004da0 000fe7 00      0   0  1\n  [10] .debug_str        PROGBITS        0000000000000000 005d87 0003bc 01  MS  0   0  1\n  [11] .debug_line_str   PROGBITS        0000000000000000 006143 0000d3 01  MS  0   0  1\n  [12] .comment          PROGBITS        0000000000000000 006216 00001a 01  MS  0   0  1\n  [13] .riscv.attributes RISCV_ATTRIBUTES 0000000000000000 006230 000065 00      0   0  1\n  [14] .debug_frame      PROGBITS        0000000000000000 006298 0004c8 00      0   0  8\n  [15] .debug_rnglists   PROGBITS        0000000000000000 006760 00007f 00      0   0  1\n  [16] .symtab           SYMTAB          0000000000000000 0067e0 0006f0 18     17  31  8\n  [17] .strtab           STRTAB          0000000000000000 006ed0 000279 00      0   0  1\n  [18] .shstrtab         STRTAB          0000000000000000 007149 0000cc 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  R (retain), p (processor specific)\n\nElf file type is EXEC (Executable file)\nEntry point 0x80200000\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x006230 0x0000000000000000 0x0000000000000000 0x000065 0x000000 R   0x1\n  LOAD           0x001000 0x0000000080200000 0x0000000080200000 0x0011f0 0x0011f0 R E 0x1000\n  LOAD           0x003000 0x0000000080202000 0x0000000080202000 0x000008 0x005000 RW  0x1000\n  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10\n\n Section to Segment mapping:\n  Segment Sections...\n   00     .riscv.attributes \n   01     .text .rodata \n   02     .data .bss \n   03     \n   None   .debug_info .debug_abbrev .debug_loclists .debug_aranges .debug_line .debug_str .debug_line_str .comment .debug_frame .debug_rnglists .symtab .strtab .shstrtab\n</code></pre> <ul> <li>The final file type is: <code>Type: EXEC (Executable file)</code> </li> <li>The entry point address is: <code>Entry point address: 0x80200000</code> </li> <li>There are a total of 19 Sections:  <ul> <li>Each Section has its own Flags, where <code>A</code> indicates that this Section should be allocated memory space during loading, <code>W</code> indicates it is writable, and <code>X</code> indicates it is executable.  </li> </ul> </li> <li>There are a total of 4 Program Headers, two of which are LOAD:  <ul> <li>The first LOAD indicates:  <ul> <li>At virtual address (VirtAddr) <code>0x80200000</code>, it maps to physical address (PhysAddr) <code>0x80200000</code>, allocating a memory space of <code>0x0011d0</code> bytes (MemSiz). This memory segment has the permission <code>RE</code> (Read &amp; Executable).  </li> <li>It copies <code>0x0011d0</code> bytes (FileSiz) from the ELF file's offset <code>0x001000</code> to the above memory space.  </li> </ul> </li> <li>The second LOAD indicates:  <ul> <li>At virtual address <code>0x80202000</code>, it maps to physical address <code>0x80202000</code>, allocating a memory space of <code>0x005000</code> bytes. This memory segment has the permission <code>RW</code> (Read &amp; Write).  </li> <li>It copies <code>0x0008</code> bytes from the ELF file's offset <code>0x3000</code> to this memory segment. However, the memory segment allocates <code>0x5000</code> bytes of space, indicating that the remaining unfilled space is entirely zero, which is the bss segment.  </li> </ul> </li> </ul> </li> <li>In the <code>Section to Segment mapping:</code> section, we can see:  <ul> <li>The first Program Header includes the <code>.text</code> and <code>.rodata</code> Sections.  </li> <li>The second Program Header includes the <code>.data</code> and <code>.bss</code> segments.</li> </ul> </li> </ul> <p>Continue Kernel Execution</p> <p>The first few instructions executed:</p> <pre><code>80200000: 00007117      auipc   sp, 0x7\n80200004: 00010113      mv      sp, sp\n80200008: 00000097      auipc   ra, 0x0\n8020000c: 174080e7      jalr    0x174(ra) &lt;main&gt;\n</code></pre> <p>Source code (<code>entry.S</code>):</p> <pre><code>    .section .text.entry\n    .globl _entry\n_entry:\n    lla sp, boot_stack_top\n    call main\n\n    .section .bss.stack\n    .globl boot_stack\nboot_stack:\n    .space 4096 * 4\n    .globl boot_stack_top\nboot_stack_top:\n</code></pre> <p>In this segment of code:</p> <ul> <li>We utilize the <code>auipc</code> and <code>addi</code> instructions to direct the stack pointer towards <code>boot_stack_top</code>, a stack we have pre-allocated for the initial kernel entry.</li> <li>Through the <code>auipc</code> and <code>jalr</code> instructions, we execute a jump to the main function to continue the program's execution.</li> </ul> <p>Why Use Assembly for Kernel Entry?</p> <p>At the kernel entry, OpenSBI does not set the stack pointer (<code>sp</code>). Since C requires a stack for local variables and function calls, we use assembly to initialize <code>sp</code>.</p> <p>The kernel then jumps to <code>main</code> in <code>main.c</code>:</p> <p>observe main function in file main.c</p> <pre><code>void main() {\n    printf(\"\\n\");\n    printf(\"clean bss: %p - %p\\n\", s_bss, e_bss);\n    memset(s_bss, 0, e_bss - s_bss);\n    printf(\"Kernel booted.\\n\");\n    printf(\"Hello World!\\n\");\n\n    printf(\"sysregs:\\n\");\n    print_sysregs();\n    printf(\"%d\\n\", global_variable);\n\n    printf(\"kernel ends, parking...\\n\");\n    while (1);\n}\n</code></pre> <ul> <li>Clears the <code>.bss</code> section (normally done by the Linux kernel, but we\u2019re the kernel now).</li> <li>Prints messages and enters an infinite loop.</li> </ul> <pre><code>clean bss: 0x0000000080207000 - 0x0000000080207000\nKernel booted.\nHello World!\n</code></pre> <p>Lab Report 3</p> <p>Attempt to read the <code>mvendorid</code> CSR.  </p> <p>In <code>main.c</code>, add before the <code>while(1);</code> loop:</p> <pre><code>uint64 x;\nasm volatile(\"csrr %0, mvendorid\" : \"=r\"(x));\nprintf(\"csr: %p\\n\", x);\n</code></pre> <p>Compile and run with <code>make run</code>. Can your program read the <code>mvendorid</code> CSR value?  </p> <p>Refer to the RISC-V Privileged Manual (riscv-privileged.pdf), Sections 2.1 (CSR Address Mapping Conventions) and 2.2 (CSR Listing), and explain why your program might restart infinitely.</p>"},{"location":"laben/xv6lab-baremetal/#sbi-call","title":"SBI Call","text":"<p>In this lab\u2019s kernel, <code>printf</code> calls <code>consputc</code> to print characters to the console, which ultimately invokes <code>sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0)</code>.</p> <p>To access hardware functions (e.g., <code>sbi_console_putchar</code> and <code>sbi_console_getchar</code>), we set registers like <code>a0</code> and <code>a1</code>, then use the <code>ecall</code> instruction to request service from OpenSBI in M mode. OpenSBI processes the request and returns.</p> <p>Inline Assembly</p> <p>ecall (environment call): When we execute this instruction in S-mode, it triggers an <code>ecall-from-s-mode-exception</code>, entering the interrupt handling process in M-mode (e.g., setting a timer, etc.); when we execute this instruction in U-mode, it triggers an <code>ecall-from-u-mode-exception</code>, entering the interrupt handling process in S-mode (commonly used for system calls).</p> <p>Note that C language cannot directly invoke <code>ecall</code>; it needs to be implemented using inline assembly.</p> <p>Calling Convention</p> <p>A Calling Convention defines the rules for function calls between the caller and callee.</p> <p>including:  </p> <ol> <li>How parameters and return values are passed.  </li> <li>Which registers the caller and callee must preserve.</li> </ol> <p>SBI\u2019s calling convention (riscv-sbi.pdf):  </p> <p>All SBI functions share a single binary encoding, which facilitates the mixing of SBI extensions. The SBI specification follows the below calling convention.</p> <ul> <li>An ECALL is used as the control transfer instruction between the supervisor and the SEE.</li> <li>a7 encodes the SBI extension ID (EID),</li> <li>a6 encodes the SBI function ID (FID) for a given extension ID encoded in a7 for any SBI extension defined in or after SBI v0.2.</li> <li>All registers except a0 &amp; a1 must be preserved across an SBI call by the callee.</li> <li>SBI functions must return a pair of values in a0 and a1, with a0 returning an error code. </li> </ul> <p>For legacy extensions (e.g., <code>putchar</code>/<code>getchar</code>):  </p> <ul> <li>Nothing is returned in a1 register.</li> <li>All registers except a0 must be preserved across an SBI call by the callee.</li> <li>The value returned in a0 register is SBI legacy extension specific.</li> </ul> <p>According to the RISC-V Calling Convention, parameters are passed through the <code>a</code> series of registers, starting from <code>a0</code>.  </p> <p>In the <code>sbi_call_legacy</code> function, we first declare four variables and specify that they should be directly assigned to the corresponding registers (<code>register</code>, <code>asm(\"a0\")</code>).  </p> <p>Next, we assign the value of <code>a7</code> to indicate which SBI function we want to call, and assign the three parameters to <code>a0</code>, <code>a1</code>, and <code>a2</code> respectively.  </p> <p>Then, we use <code>asm volatile</code> to perform the <code>ecall</code> instruction.  </p> <p>Finally, we return the value of the <code>a0</code> register.</p> <pre><code>const uint64 SBI_CONSOLE_PUTCHAR = 1;\nconst uint64 SBI_CONSOLE_GETCHAR = 2;\n\nstatic int inline sbi_call_legacy(uint64 which, uint64 arg0, uint64 arg1, uint64 arg2)\n{\n    register uint64 a0 asm(\"a0\") = arg0;\n    register uint64 a1 asm(\"a1\") = arg1;\n    register uint64 a2 asm(\"a2\") = arg2;\n    register uint64 a7 asm(\"a7\") = which;\n    asm volatile(\"ecall\" : \"=r\"(a0) : \"r\"(a0), \"r\"(a1), \"r\"(a2), \"r\"(a7) : \"memory\");\n    return a0;\n}\n\nvoid console_putchar(int c) {\n    sbi_call_legacy(SBI_CONSOLE_PUTCHAR, c, 0, 0);\n}\n</code></pre> <p><code>asm volatile</code> is used to directly insert assembly code (inline assembly) into C code. It consists of four parts:</p> <pre><code>asm asm-qualifiers ( AssemblerTemplate \n                 : OutputOperands \n                 [ : InputOperands\n                 [ : Clobbers ] ])\n</code></pre> <p>We use <code>volatile</code> as an asm-qualifier to indicate that the compiler should not perform any potential optimizations on this segment of code.  </p> <p><code>AssemblerTemplate</code> represents the template of the assembly code.  <code>OutputOperands</code> specifies which C variables should be treated as the output of this assembly segment.  <code>InputOperands</code> specifies which C variables should be treated as the input of this assembly segment.  <code>Clobbers</code> indicates which registers or system states will be modified by this assembly code.</p> <ul> <li>See: https://gcc.gnu.org/onlinedocs/gcc-12.1.0/gcc/Extended-Asm.html</li> </ul> <p>Lab Report 4</p> <p>Call the newer SBI function <code>sbi_get_spec_version()</code>.  </p> <p>In <code>main.c</code>, add before the <code>while(1);</code> loop:</p> <pre><code>struct sbiret ret = sbi_call(?, ?, 0, 0, 0);\nprintf(\"sbicall: err: %d, ret: %p\\n\", ret.error, ret.value);\n</code></pre> <p>Refer to the SBI manual (riscv-sbi.pdf) to fill in the <code>?</code> values. Compile and run with <code>make run</code>, then explain the output values.</p>"},{"location":"laben/xv6lab-contextswitch/","title":"Context Switch","text":""},{"location":"laben/xv6lab-contextswitch/#experiment-objectives","title":"Experiment Objectives","text":"<ol> <li>Understand process management.</li> <li>Understand context switching.</li> <li>Master the process of multi-core process switching in xv6.</li> </ol> <p>xv6-lab3 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab3</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab3 xv6lab3</code> to download the xv6-lab3 code.</p> <p>Run the kernel for this lab with <code>make runsmp</code> using multiple cores (4). You should see the following output:</p> <pre><code>Boot another cpus.\n...\nSystem has 4 cpus online\n...\nkthread: all threads exited, count 6288388\n[INFO  1,1] init: kthread: init ends!\n[PANIC 1,1] os/proc.c:225: init process exited\n[PANIC 0,-1] os/trap.c:41: other CPU has panicked\n[PANIC 2,-1] os/trap.c:41: other CPU has panicked\n[PANIC 3,-1] os/trap.c:41: other CPU has panicked\n</code></pre> <p>Context switching is a fundamental concept in operating systems. This chapter focuses on the technical implementation of context switching and the design of the scheduler in xv6.</p>"},{"location":"laben/xv6lab-contextswitch/#experimental-scenario","title":"Experimental Scenario","text":"<p>In this experiment, we will run the xv6 operating system on a RISC-V CPU with 4 cores.</p> <p>Upon system startup, we create and execute the <code>init</code> process. The <code>init</code> process spawns 8 kernel threads called <code>worker</code> and places them into the scheduling queue. Subsequently, the 4 cores take turns running these 8 <code>worker</code> threads until they exit. The parent <code>init</code> process waits for all 8 child threads to complete before terminating.</p> <p>The experimental scenario revolves around the scheduling and switching of these 9 threads. Below are the execution details of <code>init</code> and <code>worker</code>. In later sections, we will step through the knowledge points and specific workflows involved in process switching.</p>"},{"location":"laben/xv6lab-contextswitch/#init","title":"init()","text":"<p>code: nommu_init.c</p> <p>The <code>init</code> process executes the <code>init</code> function, which creates 8 kernel threads, all running the <code>worker</code> function. These 8 kernel threads increment a shared variable <code>count</code>, calling <code>yield</code> every 1000 increments.</p> <p>The <code>init</code> function calls <code>wait</code> to wait for all created kernel threads to exit, then prints the final value of the shared variable <code>count</code>.</p> <pre><code>#define NTHREAD 8\n\nvolatile uint64 count = 0;\n\nvoid worker(uint64 id) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        count++;\n        if (i % 1000 == 0) {\n            infof(\"thread %d: count %d, yielding\", id, count);\n            yield();\n        }\n    }\n    exit(id + 114514);\n}\n\nvoid init(uint64) {\n    infof(\"kthread: init starts!\");\n    int pids[NTHREAD];\n    for (int i = 0; i &lt; NTHREAD; i++) {\n        pids[i] = create_kthread(worker, i);\n    }\n    int retcode;\n    for (int i = 0; i &lt; NTHREAD; i++) {\n        int pid = wait(pids[i], &amp;retcode);\n        infof(\"thread %d exited with code %d, expected %d\", pid, retcode, i + 114514);\n    }\n    printf(\"kthread: all threads exited, count %d\\n\", count);\n    infof(\"kthread: init ends!\");\n    exit(0);\n}\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#what-is-context","title":"What is Context?","text":"<p>In operating systems, a context refers to the complete set of state information required for a program to run at a given moment. In xv6, we define each process as an independent schedulable entity, meaning every process has its own context.</p> <p>Understanding context is crucial because when the operating system needs to switch between processes, it must save the current process\u2019s context and load the context of the process to be executed next. This ensures that the process can resume execution from its previous state when it regains CPU control. The process of saving and restoring context is the core of context switching.</p> <p>Imagine reading a book and needing to pause to do something else. You might use a bookmark to mark your place\u2014this bookmark represents your \"reading context.\" When you return, the bookmark tells you where to resume. Similarly, in an operating system, context serves this purpose, though the information it saves and restores is far more complex.</p>"},{"location":"laben/xv6lab-contextswitch/#why-context-switching","title":"Why Context Switching?","text":"<p>From a scheduling perspective, context switching is a key mechanism for enabling multitasking and resource multiplexing:</p> <ol> <li> <p>Time-Division Multiplexing of CPU Resources</p> <p>When multiple ready processes need to run, the operating system must allow them to take turns using the CPU. Even with a single CPU, time-sharing multiplexing enables processes to appear to run concurrently by executing them in turns. The scheduler decides which process to run at any given moment based on policies like Round Robin or Priority Scheduling. Context switching is required to transition to the scheduled process.</p> </li> <li> <p>Improving System Throughput</p> <p>When a process blocks due to an I/O operation, the CPU becomes idle. Context switching allows the scheduler to switch to another ready process, enabling the CPU to perform other tasks while waiting for I/O, thus improving resource utilization and system throughput.</p> </li> <li> <p>Responsiveness for Interactive Tasks</p> <p>Interactive programs require timely responses. Context switching allows the scheduler to pause a running batch job and quickly switch to an interactive task needing immediate attention, enhancing user experience.</p> </li> </ol>"},{"location":"laben/xv6lab-contextswitch/#when-does-context-switching-occur","title":"When Does Context Switching Occur?","text":"<p>Context switching typically occurs in the following situations:</p> <ol> <li> <p>Time Slice Expiration</p> <p>In time-slice-based round-robin scheduling, when a process exhausts its allocated time slice, a clock interrupt triggers, and the operating system forcibly performs a context switch to another ready process.</p> </li> <li> <p>Process Blocking</p> <p>A process may initiate a system call to wait for I/O, wait for an event (e.g., a semaphore), or request a resource that isn\u2019t immediately available. </p> <p>In such cases, the process voluntarily relinquishes the CPU, and the scheduler selects another ready process to run.</p> </li> <li> <p>Voluntary Yield</p> <p>A process calls the <code>yield</code> system call to voluntarily give up its remaining time slice, typically when it senses it has no immediate work to do.</p> </li> </ol>"},{"location":"laben/xv6lab-contextswitch/#xv6-process","title":"xv6 Process","text":"<p>Process, Thread, and Kernel Thread</p> <p>A process is an instance of a program, with its own independent address space, memory, file descriptors, and other resources.  A thread is an execution unit within a process and the basic unit of CPU scheduling. Threads have their own stack and register state, while threads within the same process share the process\u2019s address space and most resources. Typically, a process can contain multiple threads.</p> <p>In this course, xv6 simplifies its implementation with the following rules:</p> <ol> <li>Each process has exactly one thread. Thus, in xv6, a process is the basic unit of CPU scheduling.</li> <li>Each user process has two execution environments: a user-mode (U-mode) environment and a kernel-mode (S-mode) environment, the latter called a kernel thread.</li> </ol> <p>In this lab, we have not yet introduced user mode, so each process consists solely of a kernel thread. User space will be covered in labs a few weeks from now.</p> <p>Related code: <code>os/proc.h</code>, <code>os/sched.c</code>, <code>os/smp.c</code></p> <p>In xv6, the Process Control Block (PCB) is defined as follows:</p> <pre><code>enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };\n\nstruct proc {\n    spinlock_t lock;\n    // p-&gt;lock must be held when accessing these fields:\n    enum procstate state;  // Process state\n    int pid;               // Process ID\n    uint64 exit_code;\n    void *sleep_chan;\n    int killed;\n    struct proc *parent;    // Parent process\n    uint64 __kva kstack;    // Virtual address of kernel stack\n    struct context context; // swtch() here to run process\n\n    // Userspace: User Memory Management, not covered in today's lab\n    struct mm *mm;\n    struct vma *vma_brk;\n    struct trapframe *__kva trapframe;  // data page for trampoline.S\n};\n</code></pre> <p>Each process has its own PID, process state, parent pointer, kernel stack, and kernel context.</p> <p>For processes with user mode (not yet implemented in this lab\u2019s code), the PCB includes a <code>struct mm</code> for memory management and a <code>trapframe</code> to store data when a trap occurs in user mode.</p> <p>Additionally, each process has a <code>spinlock_t</code> spinlock. Although we haven\u2019t covered locks and concurrency in theory yet, xv6 mandates that all accesses to <code>struct proc</code> members occur while holding <code>p-&gt;lock</code>.</p> <p>What is a Lock?</p> <p>A lock is a basic tool for controlling concurrent access.</p> <p>We stipulate that when holding a spinlock: 1. The CPU cannot be interrupted, and 2. Other CPUs cannot hold the same lock simultaneously.</p> <p>We use the <code>acquire</code> and <code>release</code> primitives to denote locking and unlocking actions.</p> <p>If a lock cannot be acquired with <code>acquire</code>, the CPU spins in place until the lock becomes available.</p>"},{"location":"laben/xv6lab-contextswitch/#struct-cpu","title":"<code>struct cpu</code>","text":"<p>In xv6, we use <code>struct cpu</code> to describe the state of each CPU, and the <code>mycpu()</code> function retrieves the current CPU object.</p> <pre><code>struct cpu {\n    int mhart_id;                  // mhartid for this cpu, passed by OpenSBI\n    struct proc *proc;             // current process\n    struct context sched_context;  // scheduler context, swtch() here to run scheduler\n    int inkernel_trap;             // whether we are in a kernel trap context\n    int noff;                      // how many push-off\n    int interrupt_on;              // Is the interrupt enabled before the first push-off?\n    uint64 sched_kstack_top;       // top of per-CPU scheduler kernel stack\n    int cpuid;                     // for debug purposes\n};\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#process-initialization","title":"Process Initialization","text":"<p>To simplify implementation, xv6 limits the maximum number of processes to a fixed value of 512 and uses a pointer array to index all processes.</p> <p>At system boot, xv6 calls <code>proc_init</code> to initialize process-related resources. This function first initializes the spinlocks required by the process module and the <code>proc_allocator</code> pool for <code>struct proc</code>. It then initializes 512 processes, each allocated a <code>struct proc*</code> PCB from <code>proc_allocator</code>, zeroed out with <code>memset</code>, and assigned a kernel stack <code>kstack</code>.</p> <p>kalloc</p> <p>The <code>kalloc.c</code> module handles the following:</p> <ol> <li>Allocate and free a 4KiB page: <code>kallocpage</code>, <code>kfreepage</code>.</li> <li>Allocate and free fixed-size objects: <code>allocator_init</code>, <code>kalloc</code>, <code>kfree</code>.</li> </ol> <pre><code>struct proc *pool[NPROC];\n\n// Initialize the proc table at boot time.\nvoid proc_init() {\n    // We only init once.\n    static int proc_inited = 0;\n    assert(proc_inited == 0);\n    proc_inited = 1;\n\n    spinlock_init(&amp;pid_lock, \"pid\");\n    spinlock_init(&amp;wait_lock, \"wait\");\n    allocator_init(&amp;proc_allocator, \"proc\", sizeof(struct proc), NPROC);\n\n    struct proc *p;\n    for (int i = 0; i &lt; NPROC; i++) {\n        p = kalloc(&amp;proc_allocator);\n        memset(p, 0, sizeof(*p));\n        spinlock_init(&amp;p-&gt;lock, \"proc\");\n        p-&gt;index = i;\n        p-&gt;state = UNUSED;\n\n        p-&gt;kstack = (uint64)kallocpage();\n        assert(p-&gt;kstack);\n\n        pool[i] = p;\n    }\n    sched_init();\n}\n</code></pre> <p>When a PCB is needed, <code>allocproc</code> searches the <code>pool</code> for an unallocated process, performs final initialization, and returns it. We\u2019ll explain how xv6 initializes a process\u2019s context later.</p> <pre><code>// Look in the process table for an UNUSED proc.\n// If found, initialize state required to run in the kernel.\n// If there are no free procs, or a memory allocation fails, return 0.\nstruct proc *allocproc() {\n    struct proc *p;\n    // Find an UNUSED proc\n    for (int i = 0; i &lt; NPROC; i++) {\n        p = pool[i];\n        acquire(&amp;p-&gt;lock);\n        if (p-&gt;state == UNUSED) {\n            goto found;\n        }\n        release(&amp;p-&gt;lock);\n    }\n    return 0;\n\nfound:\n    // Initialize a proc\n    tracef(\"init proc %p\", p);\n    p-&gt;pid        = allocpid();\n    p-&gt;state      = USED;\n    p-&gt;killed     = 0;\n    p-&gt;sleep_chan = NULL;\n    p-&gt;parent     = NULL;\n    p-&gt;exit_code  = 0;\n\n    memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));\n    memset((void *)p-&gt;kstack, 0, PGSIZE);\n\n    if (!init_proc)\n        init_proc = p;\n\n    assert(holding(&amp;p-&gt;lock));\n\n    return p;\n}\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#xv6-context-switch","title":"xv6 Context Switch","text":"<p>For a program, its visible and modifiable state consists of all its registers and memory space. In kernel space, all kernel threads share the same memory space (unlike user processes, which have distinct memory spaces). Thus, for kernel processes, we only need to save their register states. In xv6, we define a process\u2019s kernel context as the following structure:</p> <pre><code>// Saved registers for kernel context switches.\nstruct context {\n    uint64 ra;\n    uint64 sp;\n\n    // Callee-saved\n    uint64 s0;\n    uint64 s1;\n    uint64 s2;\n    uint64 s3;\n    uint64 s4;\n    uint64 s5;\n    uint64 s6;\n    uint64 s7;\n    uint64 s8;\n    uint64 s9;\n    uint64 s10;\n    uint64 s11;\n};\n</code></pre> <p>In the <code>switch.S</code> file, we define the \"function\" <code>swtch</code> with the prototype <code>void swtch(struct context *old, struct context *new)</code>.</p> <pre><code># Context switch\n#   void swtch(struct context *old, struct context *new);\n# Save current registers in old. Load from new.\n\n.globl swtch\nswtch:\n    sd ra, 0(a0)\n    sd sp, 8(a0)\n    sd s0, 16(a0)\n    sd s1, 24(a0)\n    sd s2, 32(a0)\n    sd s3, 40(a0)\n    sd s4, 48(a0)\n    sd s5, 56(a0)\n    sd s6, 64(a0)\n    sd s7, 72(a0)\n    sd s8, 80(a0)\n    sd s9, 88(a0)\n    sd s10, 96(a0)\n    sd s11, 104(a0)\n\n    ld ra, 0(a1)\n    ld sp, 8(a1)\n    ld s0, 16(a1)\n    ld s1, 24(a1)\n    ld s2, 32(a1)\n    ld s3, 40(a1)\n    ld s4, 48(a1)\n    ld s5, 56(a1)\n    ld s6, 64(a1)\n    ld s7, 72(a1)\n    ld s8, 80(a1)\n    ld s9, 88(a1)\n    ld s10, 96(a1)\n    ld s11, 104(a1)\n\n    ret\n</code></pre> <p>When performing a context switch, we call the <code>swtch</code> function with two <code>struct context*</code> pointers: one indicating where the current context should be saved (<code>old</code>) and another indicating where execution should resume from (<code>new</code>).</p> <p>Since we\u2019re calling <code>swtch</code> from C, the compiler adheres to the RISC-V Calling Convention, setting up the environment accordingly. For example, the return address is written to the <code>ra</code> register, and some registers are saved on the stack.</p> <p>Per the RISC-V Calling Convention, registers are divided into caller-saved and callee-saved. For caller-saved registers, the caller must save them if their values need to persist across the call; the callee can modify them freely. For callee-saved registers, the caller assumes they remain unchanged, and the callee must save and restore them if used. These registers are typically saved on the stack frame (handled automatically by the compiler).</p> <p>Thus, <code>swtch</code> only needs to save <code>sp</code>, <code>ra</code>, and all callee-saved registers (<code>s0-s11</code>) into the <code>old</code> structure to preserve the caller\u2019s execution state. Conversely, restoring from <code>new</code> involves loading these registers.</p> <p></p> <p>The diagram below illustrates the switch from P1 to P2, where P1 and P2 each have their own stack and context structure.</p> <p></p> <p>When P1 executes its function, the prologue saves the caller\u2019s return address and allocates stack space for local variables. Before calling <code>swtch</code>, the compiler saves all caller-saved registers onto the stack and generates a <code>jal swtch</code> instruction, which sets <code>ra</code> to the next instruction in P1 (commonly <code>pc+4</code>).</p> <p>During the <code>swtch</code> call, <code>a0</code> points to P1\u2019s <code>struct context</code>. The <code>swtch</code> function uses <code>sd</code> instructions to save <code>ra</code>, <code>sp</code>, and <code>s0-s11</code> into this structure.</p> <p>Next, <code>swtch</code> loads P2\u2019s context from <code>a1</code> using <code>ld</code> instructions, restoring <code>ra</code>, <code>sp</code>, and <code>s0-s11</code> from P2\u2019s <code>struct context</code>.</p> <p>When the CPU executes <code>ret</code>, the program counter (<code>pc</code>) is set to the value of <code>ra</code>, resuming execution at the address saved from P2\u2019s last <code>swtch</code> call.</p> <p>This completes the switch from P1 to P2. (Note: P1 and P2 here represent arbitrary programs, not necessarily OS processes.)</p> <p>Additionally, <code>swtch</code> operates in pairs: if a process exits via <code>swtch</code>, its next return must result from another process calling <code>swtch</code> to switch back.</p>"},{"location":"laben/xv6lab-contextswitch/#lab-exercise-1","title":"Lab Exercise 1","text":"<p>Understand the <code>swtch</code> function at the assembly level.</p> <p>Assume you have two <code>struct context</code> structures, <code>ctx_a</code> and <code>ctx_b</code>:</p> <pre><code>struct context ctx_a = {\n    .ra = 0x0,\n    .sp = 0x0,\n};\nstruct context ctx_b = {\n    .ra = 0x802dead0,\n    .sp = 0x7fffB000,\n};\n</code></pre> <p>Suppose you are executing <code>swtch(&amp;ctx_a, &amp;ctx_b)</code>. The corresponding assembly code and surrounding instructions are as follows:</p> <pre><code>// a0: address of ctx_a, a1: address of ctx_b\n    80205720:   05848593            addi    a1,s1,88\n    80205724:   00002097            auipc   ra,0x2\n    80205728:   1b4080e7            jalr    436(ra) # 802078d8 &lt;swtch&gt;\n    8020572c:   008ab503            ld  a0,8(s5)\n    80205730:   24951263            bne a0,s1,80205974 &lt;scheduler+0x304&gt;\n</code></pre> <p>The <code>swtch</code> function is located at address <code>802078d8</code>, with the following assembly:</p> <pre><code>swtch:\n    802078d8:   00153023            sd  ra,0(a0)\n    802078dc:   00253423            sd  sp,8(a0)\n    // store s0 - s11, ignored.\n\n    80207910:   0005b083            ld  ra,0(a1)\n    80207914:   0085b103            ld  sp,8(a1)\n    // restore s0 - s11, ignored.\n\n    80207948:   00008067            ret\n</code></pre> <p>At this point, the PC register points to <code>0x80205728</code>. Fill in the table below with the register or memory state changes for each subsequent instruction.</p>"},{"location":"laben/xv6lab-contextswitch/#xv6-scheduler","title":"xv6 Scheduler","text":"<p>In xv6, each CPU has its own scheduler. The <code>scheduler</code> function never returns; it runs in an infinite <code>while(1)</code> loop. Each iteration attempts to fetch a task from the queue and, if successful, switches to that process using <code>swtch</code>.</p> <p>If no task is available, it checks if all processes have exited. If so, the system should terminate; if not, some processes may be sleeping (waiting for resources) or running on other CPUs. In this case, the <code>wfi</code> (Wait For Interrupt) instruction is used to idle the CPU until the next clock interrupt, equivalent to a <code>while(1);</code> spin loop.</p> <p>If a process is successfully fetched, it is locked with <code>acquire(&amp;p-&gt;lock)</code>, its state is set to <code>RUNNING</code>, and the current CPU\u2019s running process is updated (<code>c-&gt;proc = p</code>).</p> <p>mycpu and curr_proc</p> <p>In a single-processor system, only one process runs on the CPU at a time, and we define a global <code>struct proc* curr_proc</code> to represent the current process. In a multi-processor system, each CPU has its own <code>curr_proc</code>, tracked via the <code>struct cpu</code> structure. A global array <code>struct cpu cpus[4]</code> represents the 4 CPUs, and the <code>tp</code> register indicates the current CPU ID via <code>cpuid()</code>, which directly reads and returns <code>tp</code>.</p> <p>Next, the <code>swtch</code> function jumps to the saved context of the process, storing the current context in <code>cpu-&gt;sched_context</code>.</p> <p>For the scheduler, we enforce the following rules:</p> <ol> <li>Process switching must go through the scheduler; Process A switches to the scheduler, then to Process B, never directly from A to B.</li> <li>When switching to a process <code>p</code>, the CPU holds <code>p-&gt;lock</code> before leaving the scheduler, implying interrupts are disabled.</li> <li>When switching back from process <code>p</code> to the scheduler, the CPU holds <code>p-&gt;lock</code>.</li> </ol> <pre><code>// Scheduler never returns.  It loops, doing:\n//  - choose a process to run.\n//  - swtch to start running that process.\n//  - eventually that process transfers control\n//    via swtch back to the scheduler.\nvoid scheduler() {\n    struct proc *p;\n    struct cpu *c = mycpu();\n\n    // We only get here once.\n    // After each cpu boots, it calls scheduler().\n    // If this scheduler finds any possible process to run, it will switch to it.\n    //  And the scheduler context is saved on \"mycpu()-&gt;sched_context\"\n\n    for (;;) {\n        // intr may be on here.\n\n        p = fetch_task();\n        if (p == NULL) {\n            // if we cannot find a process in the task_queue\n            //  maybe some processes are SLEEPING and some are RUNNABLE\n            if (all_dead()) {\n                panic(\"[cpu %d] scheduler dead.\", c-&gt;cpuid);\n            } else {\n                // nothing to run; stop running on this core until an interrupt.\n                intr_on();\n                asm volatile(\"wfi\");\n                intr_off();\n                continue;\n            }\n        }\n\n        acquire(&amp;p-&gt;lock);\n        assert(p-&gt;state == RUNNABLE);\n        infof(\"switch to proc %d(%d)\", p-&gt;index, p-&gt;pid);\n        p-&gt;state = RUNNING;\n        c-&gt;proc  = p;\n        swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context);\n\n        // When we get back here, someone must have called swtch(..., &amp;c-&gt;sched_context);\n        assert(c-&gt;proc == p);\n        assert(!intr_get());        // scheduler should never have intr_on()\n        assert(holding(&amp;p-&gt;lock));  // whoever switch to us must acquire p-&gt;lock\n        c-&gt;proc = NULL;\n\n        if (p-&gt;state == RUNNABLE) {\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n</code></pre> <p>When returning from <code>swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context)</code>, we can deduce:</p> <ol> <li>Since <code>swtch</code> operates in pairs, our last exit via <code>swtch</code> means someone called <code>swtch(..., &amp;c-&gt;sched_context)</code> to return here.</li> <li>This is a per-CPU scheduler, and we handed control to process <code>p</code> upon leaving, so the return must come from <code>p</code> switching back.</li> </ol> <p>Thus, we include three assertions to ensure the scheduler operates correctly:</p> <ol> <li>Interrupts must be off when <code>swtch</code> returns.</li> <li>We must hold <code>p-&gt;lock</code>.</li> <li>The current CPU\u2019s running process must be <code>p</code>.</li> </ol> <p>Finally, we clear <code>c-&gt;proc</code>. If <code>p</code> remains <code>RUNNABLE</code>, it is requeued. After releasing <code>p-&gt;lock</code>, the scheduler proceeds to the next iteration.</p>"},{"location":"laben/xv6lab-contextswitch/#sched-function","title":"sched Function","text":"<p>The <code>sched</code> function relinquishes CPU control from the current kernel process back to the scheduler.</p> <pre><code>// Switch to scheduler.  Must hold only p-&gt;lock\n// and have changed proc-&gt;state. Saves and restores\n// interrupt_on because interrupt_on is a property of this\n// kernel thread, not this CPU. It should\n// be proc-&gt;interrupt_on and proc-&gt;noff, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid sched() {\n    int interrupt_on;\n    struct proc *p = curr_proc();\n\n    if (!holding(&amp;p-&gt;lock))\n        panic(\"not holding p-&gt;lock\");\n    if (mycpu()-&gt;noff != 1)\n        panic(\"holding another locks\");\n    if (p-&gt;state == RUNNING)\n        panic(\"sched running process\");\n    if (mycpu()-&gt;inkernel_trap)\n        panic(\"sched should never be called in kernel trap context.\");\n    assert(!intr_get());\n\n    interrupt_on = mycpu()-&gt;interrupt_on;\n\n    infof(\"switch to scheduler %d(%d)\", p-&gt;index, p-&gt;pid);\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    infof(\"switch back from scheduler %d(%d)\", p-&gt;index, p-&gt;pid);\n\n    mycpu()-&gt;interrupt_on = interrupt_on;\n\n    // if scheduler returns here: p-&gt;lock must be holding.\n    if (!holding(&amp;p-&gt;lock))\n        panic(\"not holding p-&gt;lock after sched.swtch returns\");\n}\n</code></pre> <p>We mandate the following conditions for <code>sched</code>:</p> <ol> <li>The CPU must hold <code>curr_proc()-&gt;lock</code> since we\u2019re manipulating the <code>struct proc</code>.</li> <li> <p>No other locks are held besides <code>curr_proc()-&gt;lock</code> to prevent kernel deadlocks.</p> <p>This is enforced by checking <code>mycpu()-&gt;noff</code>, which increments with each <code>acquire</code> and decrements with each <code>release</code>.</p> </li> <li> <p><code>p-&gt;state</code> must have been changed to a non-<code>RUNNING</code> state.</p> </li> <li><code>sched</code> must not be called from a kernel trap context.</li> </ol> <p>If these checks pass, <code>swtch</code> saves the current process state to <code>p-&gt;context</code> and jumps to the scheduler\u2019s context (<code>&amp;mycpu()-&gt;sched_context</code>).</p> <p>Similarly, if the scheduler switches back, it must hold <code>p-&gt;lock</code> when relinquishing CPU control.</p>"},{"location":"laben/xv6lab-contextswitch/#the-first-process-init","title":"The First Process - init","text":"<p>So far, we\u2019ve covered the Process Control Block (<code>struct proc</code>), the principles of context switching, and the scheduler\u2019s design in xv6. Now, we\u2019ll explore how the first process (a kernel thread) is launched in xv6.</p> <p>In <code>main.c</code>, the <code>bootcpu_init</code> function creates the first kernel thread <code>init</code> with <code>create_kthread(init, 0x1919810);</code>, indicating that the first process will execute the <code>init()</code> function with a parameter.</p> <p><code>create_kthread</code> allocates a PCB via <code>allocproc()</code>, initializes its <code>struct context</code> (the execution environment for its first scheduling), marks it as runnable, and adds it to the scheduler\u2019s queue.</p> <pre><code>int create_kthread(void (*fn)(uint64), uint64 arg) {\n    struct proc *p = allocproc();\n    if (!p)\n        return -1;\n\n    // Initialize process state\n    p-&gt;context.ra = (uint64)first_sched_ret;\n    p-&gt;context.sp = p-&gt;kstack + PGSIZE;\n    p-&gt;context.s1 = (uint64)fn;\n    p-&gt;context.s2 = arg;\n\n    p-&gt;state = RUNNABLE;\n    p-&gt;parent = init_proc;\n\n    int pid = p-&gt;pid;\n    add_task(p);\n    release(&amp;p-&gt;lock);\n\n    return pid;\n}\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#first-scheduling","title":"First Scheduling","text":"<p>When the <code>init</code> kernel thread is first scheduled, the scheduler retrieves it from the task queue and executes <code>swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context)</code> (where <code>p</code> is <code>init</code>). After <code>swtch</code> executes <code>ret</code>, the CPU switches to <code>init</code>\u2019s kernel stack (<code>p-&gt;kstack + PGSIZE</code>) and runs <code>first_sched_ret</code>. This function reads the target function and argument from the <code>s1</code> and <code>s2</code> registers, releases <code>p-&gt;lock</code> per scheduler rules, enables interrupts, and jumps to the specified function.</p> <pre><code>static void first_sched_ret(void) {\n    // s0: frame pointer, s1: fn, s2: uint64 arg\n    void (*fn)(uint64);\n    uint64 arg;\n    asm volatile(\"mv %0, s1\":\"=r\"(fn));\n    asm volatile(\"mv %0, s2\":\"=r\"(arg));\n\n    release(&amp;curr_proc()-&gt;lock);\n    intr_on();\n    fn(arg);\n    panic(\"first_sched_ret should never return. You should use exit to terminate kthread\");\n}\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#execution-flowchart-for-first-scheduling","title":"Execution Flowchart for First Scheduling","text":""},{"location":"laben/xv6lab-contextswitch/#lab-exercise-2","title":"Lab Exercise 2","text":"<p>Draw a flowchart for switching between two processes, modeled after the diagram above. Assume P1 and P2 have been scheduled at least once, having exited the <code>first_sched_ret</code> phase, with their context\u2019s <code>ra</code> pointing to the line after <code>swtch</code> in the <code>sched</code> function.</p> <p>The flow begins at the top-left corner, where the scheduler fetches P1 from <code>fetch_task</code> and uses <code>swtch</code> to switch to the address saved in P1\u2019s context\u2014specifically, the line after <code>swtch</code> in P1\u2019s <code>sched()</code> call (<code>sched() ends</code>), where P1 last switched back to the scheduler.</p> <p>The first arrow is provided. Draw the remaining arrows based on the following steps, indicating only where each <code>swtch</code> transfers control:</p> <ol> <li>After switching from the scheduler to P1, P1 enters its next work loop, then calls <code>yield</code>, <code>sched</code>, and reaches the <code>swtch</code> at the top-right. Indicate where this <code>swtch</code> transfers control.</li> <li>Control returns to the scheduler, which enters its next loop, fetches P2 from <code>fetch_task()</code>, and reaches the <code>swtch</code> at the bottom-left. Indicate where this <code>swtch</code> transfers control.</li> <li>After switching from the scheduler to P2, P2 enters its next work loop, then calls <code>yield</code>, <code>sched</code>, and reaches the <code>swtch</code> at the bottom-right. Indicate where this <code>swtch</code> transfers control.</li> </ol>"},{"location":"laben/xv6lab-contextswitch/#worker","title":"worker","text":"<p>After the first scheduling, <code>init</code> creates 8 <code>worker</code> kernel threads and adds them to the ready queue. Idle CPU cores looping in the scheduler can then fetch and execute a <code>worker</code>. Meanwhile, <code>init</code> enters a waiting state via <code>wait()</code>, freeing a CPU core. From then on, 4 CPU cores execute the 8 <code>worker</code> threads.</p> <p>These 8 <code>worker</code> threads increment the shared variable <code>count</code>, calling <code>yield</code> every 1000 increments. A <code>worker</code> calling <code>yield</code> relinquishes its CPU core, which then schedules the next ready process. A related assignment will later deepen our understanding of this process.</p>"},{"location":"laben/xv6lab-contextswitch/#reading","title":"Reading","text":""},{"location":"laben/xv6lab-contextswitch/#disabling-interrupts","title":"Disabling Interrupts","text":"<p>In kernel code, we sometimes want execution to proceed without interruption or preemption by other tasks. This can be achieved by disabling interrupts (though exceptions still jump to the trap handler).</p> <p>We use <code>push_off()</code> and <code>pop_off()</code> as a pair to disable and enable interrupts. Since <code>push_off</code> calls may be nested, we treat disabling interrupts as a stack-like operation, restoring interrupts only when the stack is empty. Two variables are tracked in <code>struct cpu</code>:</p> <ol> <li> <p><code>noff</code>: The current depth of <code>push_off</code>/<code>pop_off</code>.</p> <p>For example, after <code>push_off()</code>, <code>push_off()</code>, <code>pop_off()</code>, <code>noff</code> should be 1.</p> </li> <li> <p><code>interrupt_on</code>: Whether interrupts were enabled when <code>noff == 0</code>, i.e., before the first <code>push_off</code>.</p> </li> </ol> <pre><code>void push_off(void) {\n    uint64 ra = r_ra();\n\n    int old = intr_get();\n    intr_off();\n\n    if (mycpu()-&gt;noff == 0) {\n        // warnf(\"intr on saved: %p\", ra);\n        mycpu()-&gt;interrupt_on = old;\n    }\n    mycpu()-&gt;noff += 1;\n}\n\nvoid pop_off(void) {\n    uint64 ra = r_ra();\n\n    struct cpu *c = mycpu();\n    if (intr_get())\n        panic(\"pop_off - interruptible\");\n    if (c-&gt;noff &lt; 1)\n        panic(\"pop_off - unpair\");\n    c-&gt;noff -= 1;\n    if (c-&gt;noff == 0 &amp;&amp; c-&gt;interrupt_on) {\n        if (c-&gt;inkernel_trap)\n            panic(\"pop_off-&gt;intr_on happens in kernel trap\");\n        // We only open the interrupt if:\n        //    1. the push-pop stack is cleared, and\n        //    2. the interrupt was on before the first push-off\n        intr_on();\n    }\n}\n</code></pre>"},{"location":"laben/xv6lab-contextswitch/#why-save-cpu-interrupt_on","title":"Why Save <code>cpu-&gt;interrupt_on</code>?","text":"<p>This attribute pertains to the current kernel thread, not the CPU itself. Since <code>push_off</code>/<code>pop_off</code> may be used without a process context, we store <code>interrupt_on</code> in <code>struct cpu</code> rather than <code>struct proc</code>. During <code>sched</code>-based kernel thread switches, this attribute is preserved on the kernel thread\u2019s stack.</p> <p>We don\u2019t need to save <code>noff</code> because we enforce it to be 1.</p> <p>If we omit saving <code>interrupt_on</code>, the diagram below shows how Kernel Process 1\u2019s (red) interrupt state erroneously affects Kernel Process 2 (yellow) via <code>sched</code> and the scheduler (blue):</p> <p>Kernel Process 2 runs with interrupts off, then calls <code>sched</code> and pauses (dashed line). Kernel Process 1 begins with interrupts on (solid line). When P1 calls <code>sched</code> to switch to the scheduler, <code>acquire-&gt;push_off</code> saves the interrupt state to <code>cpu-&gt;interrupt_on</code>. The scheduler then resumes P2, which calls <code>release-&gt;pop_off</code>, incorrectly restoring interrupts to on. For P2, this violates the context switching rule that the execution context remains unchanged, as it resumes with interrupts on despite having them off before the switch.</p> <p></p>"},{"location":"laben/xv6lab-interrupts/","title":"Trap, Exception, and Interrupt","text":""},{"location":"laben/xv6lab-interrupts/#objectives-of-experiment","title":"Objectives of Experiment","text":"<ol> <li>Understand exceptional control flow.</li> <li>Learn how the RISC-V architecture supports CPU interrupts.</li> <li>Master the Trap handling process.</li> </ol> <p>xv6-lab2 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab2</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab2 xv6lab2</code> to download the xv6-lab2 code.</p> <p>Run <code>make run</code> to execute the kernel for this lab, and you will encounter a Kernel Panic.</p> <p>Recommended Reading</p> <p>CSAPP, Chapter 8, Exceptional Control Flow.</p> <p>https://csapp.cs.cmu.edu/2e/ch8-preview.pdf</p>"},{"location":"laben/xv6lab-interrupts/#exceptional-control-flow","title":"Exceptional Control Flow","text":"<p>In a normal program execution state, the control flow (which can be thought of as the sequence of the program counter, or <code>pc</code>) proceeds step-by-step according to the predefined order of the program. However, an operating system inevitably needs to handle situations that fall \"outside the predefined plan,\" such as program errors or changes in external state\u2014e.g., a network packet arriving at the NIC, or a user pressing a key on the keyboard. Modern operating systems manage these events by altering the control flow, and we refer to this altered control flow as Exceptional Control Flow (ECF).</p>"},{"location":"laben/xv6lab-interrupts/#exceptions-traps-and-interrupts","title":"Exceptions, Traps, and Interrupts","text":"<p>In the RISC-V architecture, we define Exception, Interrupt, and Trap as follows:</p> <ul> <li>Exception: An unusual condition that occurs at the moment of instruction execution.</li> <li>Interrupt: An external event that is asynchronous to the current RISC-V core\u2019s instruction execution.</li> <li>Trap: A synchronous transfer of control flow caused by an exception or interrupt. We can consider a Trap as the handling behavior for Exceptions and Interrupts.</li> </ul> <p>What is Synchronous/Asynchronous?</p> <p>Recall the single-cycle RISC-V CPU implemented in a digital logic course. We have a clock signal <code>clk</code>, and every (n) clock cycles, one instruction is executed.</p> <p>Synchronous exceptions arise during instruction execution and are thus aligned with the <code>clk</code> signal, whereas asynchronous exceptions are entirely independent of the current instruction or <code>clk</code>.</p> <p></p> <p>Thus, it\u2019s clear why the control flow transfer referred to as a Trap is \"synchronous\": we must at least wait for the clock cycle to arrive before performing the control flow transfer.</p> <p>We use the term exception to refer to an unusual condition occurring at run time associated with an instruction in the current RISC-V thread. We use the term trap to refer to the synchronous transfer of control to a trap handler caused by an exceptional condition occurring within a RISC-V thread. Trap handlers usually execute in a more privileged environment.</p> <p>We use the term interrupt to refer to an external event that occurs asynchronously to the current RISC-V thread. When an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and subsequently experiences a trap.</p> <p>Source: riscv-spec-v2.1.pdf, Section 1.3 \"Exceptions, Traps, and Interrupts\".</p> <p>Differences Between RISC-V and x86</p> <p>Different textbooks provide similar definitions for Exception, Trap, and Interrupt. For example, CSAPP, referencing the x86 model, describes four types of control flow interruptions. The main distinctions lie in whether the exceptional control flow is synchronous with the instruction stream and whether the control flow returns to the original program after jumping to the exceptional control flow.</p> <p></p> <p>For instance, exception types in x86 include Page Fault (page missing exception) and Machine Check (Abort) (memory or hardware error).</p> <p>However, in the RISC-V model, the return behavior mentioned above can be simulated in software. Thus, in the RISC-V hardware model, there are only two causes of control flow changes: Exceptions and Interrupts, with the result of such changes being entry into a Trap.</p> <p>Note: RISC-V employs an extremely minimalist design philosophy at the hardware level: anything that can be handled by software is left out of hardware.</p>"},{"location":"laben/xv6lab-interrupts/#csr-mstatussstatus","title":"CSR: mstatus/sstatus","text":"<p>CSR</p> <p>If you\u2019re unfamiliar with CSR, please review the slides from the previous lab session.</p> <p>You might find keywords like WPRI, WLRL, and WARL in the CSR field definitions confusing. Refer to riscv-privilege.pdf, Section 2.3 \"CSR Field Specifications\". For now, you can simply assume that bit fields defined by these keywords are ones we don\u2019t need to care about or modify.</p> <p>mstatus/sstatus: Machine/Supervisor Status Register. This register holds the control state of the RISC-V core. <code>sstatus</code> is essentially a Restricted View of <code>mstatus</code>.</p> <p></p> <p></p> <p>Since the RISC-V manual\u2019s definitions for each CSR register field are notoriously hard to locate, we provide a quick reference table here:</p> Field Full Name (Guessed) Meaning SPP Supervisor Previous Privilege The privilege level of the Hart before entering Supervisor mode. SIE Supervisor Interrupt Enabled Interrupt enable flag in Supervisor mode. SPIE Supervisor Previous Interrupt Enabled Interrupt enable state before entering Supervisor mode. SUM Supervisor User-Memory Allows Supervisor mode to access pages with the U-bit set. <p>Other fields we don\u2019t currently use are omitted here.</p>"},{"location":"laben/xv6lab-interrupts/#trap-related-registers","title":"Trap-Related Registers","text":"<p>Here\u2019s a list of registers involved in the Trap handling process:</p> <ul> <li>stvec: Supervisor Trap Vector Base Address Register<ul> <li>Stores the address of the Trap handler function. Often referred to as the \"interrupt vector,\" which we\u2019ll explain later.</li> </ul> </li> <li>sip: Supervisor Interrupt Pending<ul> <li>Indicates which interrupts are pending.</li> </ul> </li> <li>sie: Supervisor Interrupt Enabled<ul> <li>Indicates which interrupts can be processed.</li> <li>Note: Don\u2019t confuse this with <code>sstatus.SIE</code>.</li> </ul> </li> <li>sepc: Supervisor Exception Program Counter<ul> <li>The PC value at the time of the interrupt.</li> </ul> </li> <li>scause: Supervisor Cause<ul> <li>The reason for the interrupt.</li> </ul> </li> <li>stval: Supervisor Trap Value<ul> <li>Additional information about the interrupt.</li> </ul> </li> </ul>"},{"location":"laben/xv6lab-interrupts/#stvec","title":"stvec","text":"<p>When an exception or interrupt occurs, a Trap handler is needed to process it. The <code>stvec</code> (Supervisor Trap Vector Base Address Register) serves as the base address of the so-called \"Trap vector table.\" The vector table maps different types of Traps to their corresponding handlers.  If there\u2019s only one handler, <code>stvec</code> can directly point to that handler\u2019s address.</p> <p>stvec</p> <p><code>stvec</code> mandates that the Trap handler entry must be aligned to 4 bytes (i.e., the last two bits are 0). These last two bits also indicate two modes:</p> <ol> <li>Direct Mode: All Traps enter at <code>pc &lt;= BASE</code>.</li> <li>Vectored Mode: For asynchronous interrupts, <code>pc &lt;= BASE + 4 * cause</code>.</li> </ol> <p>In our code, we use Direct Mode.</p> <p></p>"},{"location":"laben/xv6lab-interrupts/#scause","title":"scause","text":"<p>When a Trap is caught and enters Supervisor Mode (S-mode), the <code>scause</code> register is written with a code indicating the event that caused the Trap.</p> <p></p> <p></p>"},{"location":"laben/xv6lab-interrupts/#sie-sip","title":"sie &amp; sip","text":"<p>The <code>sip</code> register is a 64-bit read-write register that stores information about pending interrupts, while <code>sie</code> is a corresponding 64-bit read-write register containing interrupt enable bits.</p> <p>Interrupt cause number <code>i</code> (as shown in CSR <code>scause</code>) corresponds to bit <code>i</code> in the <code>sip</code> and <code>sie</code> registers. Bits 15:0 are allocated to standard interrupt causes, while bits 16 and above are reserved for platform-specific or custom use.</p> <p></p> <p></p>"},{"location":"laben/xv6lab-interrupts/#sepc","title":"sepc","text":"<p>When a Trap is caught and enters Supervisor Mode (S-mode),  the <code>sepc</code> register is written with the virtual address of the instruction that was interrupted or encountered an exception.</p>"},{"location":"laben/xv6lab-interrupts/#stval","title":"stval","text":"<p>When a Trap is caught and enters Supervisor Mode (S-mode), the <code>stval</code> register is written with specific information related to the exception to assist software in handling the Trap.</p> <p>For exceptions such as breakpoints, misaligned addresses, access faults, or page faults during instruction fetch, load, or store operations,  <code>stval</code> is set to a non-zero value representing the virtual address that caused the exception.</p>"},{"location":"laben/xv6lab-interrupts/#how-the-cpu-handles-traps","title":"How the CPU Handles Traps","text":"<p>The Trap handling process can be divided into three main stages:</p> <ol> <li>Entering the Trap</li> <li>Trap Handler</li> <li>Returning from the Trap</li> </ol>"},{"location":"laben/xv6lab-interrupts/#1-entering-the-trap","title":"1. Entering the Trap","text":"<p>When an Exception occurs, or the Hart is ready to handle an Interrupt, a Trap is triggered, and the CPU performs the following actions in hardware:</p> <ol> <li>scause &lt;= {1b'Is_Interrupt, 63b'Cause}</li> <li>stval &lt;= Trap_Value</li> <li>sepc &lt;= pc</li> <li>sstatus.SPP &lt;= Current_Privilege_Level</li> <li>sstatus.SPIE &lt;= sstatus.SIE</li> <li>sstatus.SIE &lt;= 0</li> <li>pc &lt;= stvec</li> </ol> <p>In summary: Set <code>scause</code> and <code>stval</code> =&gt; Save the PC to <code>sepc</code> =&gt; Save the current privilege level (U/S) to <code>sstatus.SPP</code> =&gt; Save the current interrupt state to <code>sstatus.SPIE</code> =&gt; Disable interrupts by setting <code>sstatus.SIE = 0</code> to prevent interrupts during Trap handling =&gt; Jump to <code>stvec</code>.</p>"},{"location":"laben/xv6lab-interrupts/#2-trap-handler","title":"2. Trap Handler","text":"<p>The <code>stvec</code> register stores the address of the Trap handler. After the CPU records the information related to the exception or interrupt causing the Trap, the <code>pc</code> points to the address stored in <code>stvec</code>, executing the corresponding Trap handler. The Trap handler then processes the event based on the information stored in the registers, using different software behaviors as needed.</p>"},{"location":"laben/xv6lab-interrupts/#3-returning-from-the-trap-sret","title":"3. Returning from the Trap (<code>sret</code>)","text":"<p>RISC-V uses the <code>sret</code> instruction to exit a Trap in Supervisor mode, performing the following steps:</p> <ol> <li>sstauts.SIE &lt;= sstatus.SPIE</li> <li>Current_Privilege_Level &lt;= sstauts.SPP</li> <li>pc &lt;= epc</li> </ol> <p>Restore <code>sstatus.SIE</code> from <code>sstatus.SPIE</code> =&gt; Set the privilege level (U/S) to <code>sstatus.SPP</code> =&gt; Set the PC to <code>sepc</code>.</p> <p>The <code>sret</code> instruction is essentially the reverse of the three steps performed when entering a Trap: restoring <code>SIE</code>, the privilege level, and the PC register.</p>"},{"location":"laben/xv6lab-interrupts/#code-walkthrough","title":"Code Walkthrough","text":"<p>After the operating system boots, we initialize the <code>stvec</code> register to point to <code>kernel_trap_entry</code>.</p> <pre><code>// trap.c\nvoid set_kerneltrap() {\n    assert(IS_ALIGNED((uint64)kernel_trap_entry, 4));\n    w_stvec((uint64)kernel_trap_entry);  // DIRECT\n}\n</code></pre> <p>When a Trap occurs, the CPU, after storing the relevant information, jumps to the <code>kernel_trap_entry</code> function pointed to by <code>stvec</code>, which serves as the interrupt vector entry point for S-mode.</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // we store all registers in the stack\n    add sp, sp, -0x100\n    sd x0, 0x00(sp)\n    sd x1, 0x08(sp)\n    sd x2, 0x10(sp)\n    // ...\n    sd x30, 0xf0(sp)\n    sd x31, 0xf8(sp)\n\n    // ...\n</code></pre> <p>The entry point allocates 0x100 bytes of stack space and saves all general-purpose registers (GPRs) onto the stack. At this point, the stack holds 32 registers, each occupying 8 bytes, totaling 0x100 bytes, with addresses ranging from low to high corresponding to registers <code>x0</code> to <code>x31</code>. We define a <code>struct ktrapframe</code> whose memory layout matches the register layout on the stack.  This allows us to dereference a <code>struct ktrapframe*</code> pointer in C to access all GPRs saved on the stack.</p> <pre><code>struct ktrapframe {\n    uint64 x0;  // x0\n    uint64 ra;\n    uint64 sp;\n    uint64 gp;\n    uint64 tp;\n    uint64 t0;\n    uint64 t1;\n    uint64 t2;\n    uint64 s0;\n    uint64 s1;\n    uint64 a0;\n    uint64 a1;\n    uint64 a2;\n    uint64 a3;\n    uint64 a4;\n    uint64 a5;\n    uint64 a6;\n    uint64 a7;\n    uint64 s2;\n    uint64 s3;\n    uint64 s4;\n    uint64 s5;\n    uint64 s6;\n    uint64 s7;\n    uint64 s8;\n    uint64 s9;\n    uint64 s10;\n    uint64 s11;\n    uint64 t3;\n    uint64 t4;\n    uint64 t5;\n    uint64 t6;\n\n    // 32 * 8 bytes = 256 (0x100) bytes\n};\n</code></pre> <p>Stack</p> <p>Upon entering the Trap handler, we can assume the previous program was executing C code and had a valid stack.</p> <p>We naturally want the Trap handler to be written in C, which also requires a valid stack space. Thus, we can directly reuse the stack space of the program that was executing, as long as we ensure the <code>sp</code> pointer can be restored.</p> <p>Additionally, the C compiler maintains stack balance: it deallocates as much space as it allocates. Therefore, as long as our assembly-level stack operations are balanced, we can safely use the existing stack for context saving, leaving the rest to the compiler.</p> <p>Context</p> <p>Trap handling requires \"pausing the current task but being able to resume it later.\" For the CPU, this simply means saving the original registers, performing other tasks, and then restoring the registers.</p> <p>Upon entering the Trap handler, the 31 GPRs (<code>x1</code>-<code>x31</code>) are in use by the original program. The Trap handler must ensure that when control returns to the original program, the GPRs remain consistent with their state before the Trap. Thus, we need memory space to save these registers and restore their original values upon returning from the Trap. We refer to these registers as the Context of the original program.</p> <p>Therefore, we implement a context-switching mechanism in assembly, which involves two steps:</p> <ul> <li>Save the CPU registers (context) to memory (on the stack).</li> <li>Restore the CPU registers from memory (the stack).</li> </ul> <p>Next, we set <code>a0</code> to <code>sp</code> and call <code>kernel_trap</code> to continue Trap handling in C code.</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // ...\n\n    mv a0, sp   // make a0 point to the ktrapframe structure\n    call kernel_trap\n\n    // ...\n</code></pre> <p>Since RISC-V uses <code>a0</code> to pass the first argument, <code>a0</code> now points to the <code>struct ktrapframe</code> on the stack. Thus, the first parameter of the <code>kernel_trap</code> function is <code>struct ktrapframe* ktf</code>, corresponding to the value of <code>a0</code>.</p> <pre><code>void kernel_trap(struct ktrapframe *ktf) {\n    assert(!intr_get());\n\n    if ((r_sstatus() &amp; SSTATUS_SPP) == 0)\n        panic(\"kerneltrap: not from supervisor mode\");\n\n    uint64 cause = r_scause();\n    uint64 exception_code = cause &amp; SCAUSE_EXCEPTION_CODE_MASK;\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        // handle interrupt\n        switch (exception_code) {\n            case SupervisorTimer:\n                debugf(\"s-timer interrupt, cycle: %d\", r_time());\n                set_next_timer();\n                break;\n            case SupervisorExternal:\n                debugf(\"s-external interrupt.\");\n                plic_handle();\n                break;\n            default:\n                errorf(\"unhandled interrupt: %d\", cause);\n                goto kernel_panic;\n        }\n    } else {\n        // kernel exception, unexpected.\n        goto kernel_panic;\n    }\n\n    assert(!intr_get());\n    return;\n\nkernel_panic:\n    panicked = 1;\n\n    errorf(\"=========== Kernel Panic ===========\");\n    print_sysregs(true);\n    print_ktrapframe(ktf);\n\n    panic(\"kernel panic\");\n}\n</code></pre> <p>Upon entering <code>kernel_trap</code>, the CPU\u2019s interrupt bit <code>sstatus.SIE</code> should remain disabled, and the Previous Privilege should be Supervisor mode. We use assertions to ensure the code executes as expected.</p> <p>Why We Write Assertions</p> <p>Assertions are a critical debugging and error-detection tool in operating system development. They help developers catch potential logic errors early in program execution. By inserting assertions in the code, we can immediately detect states or conditions that deviate from expectations, rather than waiting for a crash or unpredictable behavior and then guessing the cause.</p> <p>In other words, if we can detect at some point that the program\u2019s state has deviated from our expectations, we can make it crash at the \"first scene\" to provide more effective debugging information.</p> <p>Next, we read the <code>scause</code> register to determine whether the Trap was caused by an interrupt or an exception. We handle timer interrupts and PLIC-managed external interrupts. For any other unexpected Trap causes, we print the <code>ktrapframe</code> structure saved on the stack for debugging and use the <code>panic</code> macro to indicate an unrecoverable kernel error, halting the system.</p> <p>Finally, we exit <code>kernel_trap</code> and return to <code>kernel_trap_entry</code> to continue execution.</p> <pre><code>    .globl kernel_trap_entry\n    .align 2\nkernel_trap_entry:\n    // ...\n    call kernel_trap\n\n    // restore all registers\n    //ld x0, 0x00(sp) // do not write to x0\n    ld x1, 0x08(sp)\n    ld x2, 0x10(sp)\n    // ...\n    ld x30, 0xf0(sp)\n    ld x31, 0xf8(sp)\n\n    // restore stack\n    add sp, sp, 0x100\n\n    // return from trap\n    sret\n</code></pre> <p>After exiting the C environment, we restore all GPRs from the stack, restore the stack space, and use <code>sret</code> to exit the Trap.</p> <p>The <code>sret</code> instruction restores the value of <code>sepc</code> to the PC register.</p> <p>The following diagram illustrates the stack structure during the process of entering the Trap, constructing the <code>ktrapframe</code>, and then restoring and exiting with <code>sret</code>:</p> <p></p>"},{"location":"laben/xv6lab-interrupts/#lab-report","title":"Lab Report","text":"<p>Question 1</p> <p>Based on this week\u2019s lab content, use the GDB debugger to print the value of <code>stvec</code> when the code from last week\u2019s lab runs to the <code>main</code> function. Further, using this <code>stvec</code> value, explain why the operating system reboots infinitely after failing to read the CSR <code>mvendorid</code> value.</p> <p>You may need to use GDB commands like <code>b main</code> (set a breakpoint at the <code>main</code> function entry), <code>c</code> (continue execution), and <code>print $stvec</code>.</p> <p>Question 2</p> <p>In <code>main.c</code>, the <code>ebreak</code> instruction actively triggers an exception. Run the kernel with <code>make run</code>, and you\u2019ll observe a <code>Kernel Panic</code> along with some printed CSRs.</p> <p>Refer to the RISC-V Privileged Architecture Manual, Section <code>4.1.1 Supervisor Status Register (sstatus)</code>, and extract the values of the <code>SIE</code>, <code>SPIE</code>, and <code>SPP</code> bits from the <code>sstatus</code> value printed in the Kernel Panic log. Explain their meanings.</p> <p>Referring to the description of Interrupt/Exception Codes in <code>scause</code>, write down the meaning of the current <code>scause</code> value.</p> <p>Next, modify the <code>else</code> branch in the <code>kernel_trap</code> function in <code>trap.c</code> so that the exception caused by <code>ebreak</code> does not jump to the <code>kernel_panic</code> label but instead exits the <code>kernel_trap</code> handler:</p> <pre><code>if (cause &amp; SCAUSE_INTERRUPT) {\n    // handle interrupt\n    // ...\n} else {\n    if (exception_code == ?) {\n        debugf(\"breakpoint\");\n    } else {\n        // kernel exception, unexpected.\n        goto kernel_panic;\n    }\n}\n</code></pre> <p>Write what should replace the <code>?</code>. Run the kernel with <code>make run</code>. What do you observe? Explain the results.</p> <p>Question 3</p> <p>The RISC-V Privileged Architecture Manual, Section <code>3.3.1 Environment Call and Breakpoint</code>, explains the <code>ecall</code> and <code>ebreak</code> instructions as follows:</p> <p>ECALL and EBREAK cause the receiving privilege mode\u2019s epc register to be set to the address of the ECALL or EBREAK instruction itself, not the address of the following instruction. As ECALL and EBREAK cause synchronous exceptions, they are not considered to retire, and should not increment the minstret CSR.</p> <p>Add a line of code after <code>debugf(\"breakpoint\");</code> to ensure that, upon exiting the Trap, the subsequent instruction is executed instead of repeatedly executing <code>ebreak</code>.</p> <p>Note: You can refer to the disassembled kernel image in <code>build/kernel.asm</code> to see the instructions at each address.</p> <p>Note 2: You can use the functions <code>w_sepc()</code> and <code>r_sepc()</code> defined in <code>riscv.h</code> to read/write the <code>sepc</code> register.</p>"},{"location":"laben/xv6lab-interrupts/#interrupt","title":"Interrupt","text":"<p>The RISC-V specification defines three standard interrupts for each Hart in M/S modes: Timer Interrupt, Software Interrupt, and External Interrupt.</p>"},{"location":"laben/xv6lab-interrupts/#when-can-an-interrupt-be-handled","title":"When Can an Interrupt Be Handled?","text":"<p>RISC-V defines three standard interrupts\u2014Software Interrupt, Timer Interrupt, and External Interrupt\u2014corresponding to Exception Codes 1, 5, and 9 in <code>scause</code>, and bits 1, 5, and 9 in <code>sip</code>/<code>sie</code>.</p> <p>When an interrupt arrives, the RISC-V core checks whether it can currently handle the interrupt and enter a Trap:</p> <ul> <li>(Currently running in S-mode with <code>sstatus.SIE == 1</code>) OR currently running in U-mode.</li> <li>The interrupt type\u2019s bit <code>i</code> is set to 1 in both <code>sie</code> and <code>sip</code>.</li> </ul> <p>An interrupt i will trap to S-mode if both of the following are true:</p> <p>(a) either the current privilege mode is S and the SIE bit in the sstatus register is set, or the current privilege mode has less privilege than S-mode; and</p> <p>(b) bit i is set in both sip and sie.</p> <p>When a Software/Timer/External Interrupt reaches the CPU, the corresponding bit in <code>sip</code> is set high. The CPU then evaluates the above conditions, entering a Trap if they are met.</p>"},{"location":"laben/xv6lab-interrupts/#timer-interrupt","title":"Timer Interrupt","text":"<p>A timer interrupt can be understood as a program that executes periodically. It triggers an interrupt at fixed intervals, during which we can perform operations like process scheduling.</p> <p>The RISC-V platform provides a real-time counter, the <code>time</code> register, which increments at a constant frequency and is shared across all cores. Additionally, RISC-V provides each core with a <code>timecmp</code> register. Whenever <code>time &gt;= timecmp</code>, the core sets the <code>sip.STIP</code> bit high for a timer interrupt. If the core meets the conditions to enter a Trap, it does so.</p> <p>The SBI provides an SBI call, <code>SBI_SET_TIMER</code>, allowing Supervisor-mode software to set the <code>timecmp</code> register. Knowing the frequency of the <code>time</code> register, we can calculate how much <code>time</code> will increase in a given period (e.g., 10ms) and set <code>timecmp</code> accordingly to receive a timer interrupt after 10ms. Each time a timer interrupt occurs, we recalculate and set the next <code>timecmp</code>, achieving a timer interrupt every 10ms.</p> <p>The timer-related code is located in <code>timer.c</code>.</p> <p>During timer interrupt initialization, we use the SBI call <code>SET_TIMER</code> to set <code>timecmp</code> and enable the timer interrupt in <code>sie</code> with <code>SIE_STIE</code>. </p> <p>When handling a timer interrupt in <code>kernel_trap</code>, we calculate the next <code>timecmp</code> and call <code>SET_TIMER</code> again via SBI, repeating the cycle.</p> <p>Lab Report - Question 4</p> <p>Comment out the line <code>asm volatile(\"ebreak\" ::: \"s11\");</code> in <code>main.c</code> and uncomment <code>intr_on()</code>.</p> <p>Run <code>make run</code> and observe the cycle count printed each time a timer interrupt is triggered.</p> <p>Comment out the call to <code>set_next_timer()</code> in <code>kernel_trap</code> in <code>trap.c</code>, then run <code>make run</code> again and observe the cycle count printed for each timer interrupt.</p> <p>Explain the observed phenomena and why they occur.</p> <p>mtimecmp and stimecmp</p> <p>In fact, the standard RISC-V Privileged Architecture Manual only defines the <code>mtimecmp</code> register for M-mode. S-mode software must use an SBI call to set the timer interrupt, which internally uses OpenSBI to set <code>mtimecmp</code> and sets <code>STIP</code> in <code>mtvec</code> to emulate a timer interrupt for S-mode. This reflects RISC-V\u2019s hardware design principle of leaving tasks to software whenever possible, with M-mode emulating behavior for higher-level software.</p> <p>However, privilege mode switches are quite time-consuming. To improve Supervisor timer interrupt performance, the RISC-V Sstc extension introduces the <code>stimecmp</code> CSR, allowing Supervisor mode to directly set its timer interrupt counter.</p> <p>We can disable the Sstc extension in QEMU\u2019s CPU flags (<code>-cpu rv64,sstc=off</code>) to observe OpenSBI\u2019s behavior without Sstc. Use the command <code>qemu-system-riscv64 -nographic -machine virt -cpu rv64,svadu=off,sstc=off -m 512 -kernel build/kernel -S -gdb tcp::3333</code> to start QEMU with a debugger.</p> <p>After attaching GDB, use the <code>c</code> (continue) command to proceed. When QEMU outputs <code>kernel_trap: s-timer interrupt</code>, press Ctrl-C in the GDB terminal to interrupt execution. Use <code>print $mtvec</code> to get the M-mode interrupt vector address, and set a breakpoint with <code>b *0x800004f0</code> at the interrupt vector.</p> <p>Resume execution with <code>c</code>. When the breakpoint at <code>0x800004f0</code> is hit, use <code>print $mcause</code> to check the M-mode Trap cause.</p> <p>Without Sstc, you should see <code>mcause</code> alternate between <code>0x8000000000000007</code> (M-mode Timer Interrupt) and <code>0x9</code> (S-mode <code>ecall</code>). With the Sstc extension, <code>mcause</code> will only show <code>0x9</code>. In this case, OpenSBI directly sets <code>stimecmp</code> when using <code>SBI_SET_TIMER</code>, avoiding the routing of S-mode timer interrupts through OpenSBI.</p>"},{"location":"laben/xv6lab-interrupts/#external-interrupt","title":"External Interrupt","text":"<p>When we previously described interrupts and Traps, we mentioned, \"When an Interrupt arrives, the RISC-V core...\". So, how do external interrupts reach each core?</p> <p>The PLIC (Platform-Level Interrupt Controller) is an IP core on the RISC-V platform for managing external interrupts. Each RISC-V platform has multiple cores (Harts), but typically only one PLIC.</p> <p>In short, each peripheral notifies the PLIC when it has an interrupt to process, with each device assigned an interrupt number. The PLIC routes the interrupt to one or more cores based on preconfigured rules, setting the <code>mip.MEIP</code> or <code>sip.SEIP</code> bit of the target core(s) to request an interrupt.</p> <p>The core must claim the interrupt from the PLIC to handle it and complete it after processing.</p> <p>Specification: https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc</p> <p>AMD64 and Aarch64</p> <p>Similar global interrupt controllers exist on x86 (IA32), x86-64 (AMD64), and ARM platforms: PIC, APIC, GIC</p>"},{"location":"laben/xv6lab-interrupts/#plic-structure","title":"PLIC Structure","text":"<p>The PLIC can manage 1\u20131023 interrupt sources, each with a priority level (Priority). The PLIC refers to interrupt recipients as Hart Contexts (where a Hart Context is a privilege mode on a given Hart). Each Context can be viewed as a tuple (Hart ID, Privilege Level), corresponding to a Hart and a privilege level. Since RISC-V does not yet specify User-Mode Interrupts (the privilege spec only defines <code>mie/mip</code> and <code>sie/sip</code> for Machine and Supervisor modes), we can assume each core has two Contexts: one for M-mode and one for S-mode external interrupts.</p> <p>The PLIC can manage 0\u201315,871 Contexts, setting whether each interrupt source is allowed to route to a specific Context (Enabled Bit) and the Priority Threshold for each Context.</p> <p>The PLIC sets the <code>mip.MEIP</code> or <code>sip.SEIP</code> bit of a Hart, and whether the Hart enters an interrupt Trap depends on the conditions described earlier.</p> <p></p>"},{"location":"laben/xv6lab-interrupts/#memory-mapped-registers","title":"Memory-Mapped Registers","text":"<p>The PLIC exposes its management interface via Memory-Mapped Registers. We use offsets to locate each register. Typically, such an IP core has a fixed base address, which in QEMU is <code>0x0c00_0000</code>.</p> <p>Memory-Mapped Register, MMIO</p> <p>Memory-Mapped Registers are a critical technique in computer architecture for peripheral device and hardware control.</p> <p>A Memory-Mapped Register maps a hardware device\u2019s registers directly into the processor\u2019s memory address space. This allows the CPU to access a specific address as if it were memory, when it actually corresponds to a register within a device.</p> <p>I/O operations using Memory-Mapped Registers are called Memory-Mapped I/O (MMIO).</p> <pre><code>gef &gt; monitor info mtree\n    000000000c000000-000000000c5fffff (prio 0, i/o): riscv.sifive.plic\n</code></pre> <p>For example, the Specification\u2019s Memory Map defines <code>base + 0x4 * i</code> as the priority of interrupt source <code>i</code>:</p> <pre><code>base + 0x000000: Reserved (interrupt source 0 does not exist)\nbase + 0x000004: Interrupt source 1 priority\nbase + 0x000008: Interrupt source 2 priority\n...\nbase + 0x000FFC: Interrupt source 1023 priority\n</code></pre> <p>In <code>plicinit</code>, we set the Interrupt Priority of UART0 (interrupt 10) to 1 at <code>base + 10*4 = 1</code>. In <code>plicinithart</code>, we enable the S-mode Context of the current Hart to receive interrupt 10 and set its Priority Threshold to 0. Finally, we enable the core\u2019s <code>sie.SEIE</code> bit to allow Supervisor-Mode External Interrupts. Before the <code>while(1)</code> loop in <code>main.c</code>, we use <code>intr_on</code> to enable S-mode interrupts for the entire CPU.</p>"},{"location":"laben/xv6lab-interrupts/#claim-complete","title":"Claim &amp; Complete","text":"<p>When a Hart enters a Trap due to an External Interrupt, it must claim the interrupt from the PLIC to process it. After handling, it must complete the interrupt to notify the PLIC.</p> <p></p>"},{"location":"laben/xv6lab-interrupts/#serial-port-interrupt","title":"Serial Port Interrupt","text":"<p>On the QEMU platform, the serial port uses the <code>uart8250</code> device model, exposing eight MMIO registers. For details, see: https://www.lammertbies.nl/comm/info/serial-uart</p> <p>The <code>uart8250</code> has a read port (<code>RHR</code>) and a write port (<code>THR</code>), with bits in the <code>LSR</code> register indicating whether the read port has data and the write port is free. Read and write functions are in <code>uartgetc</code> and <code>uart_putchar</code>.</p> <p>In the serial initialization function <code>console_init</code>, we write specific flags to the <code>IER</code> register at the <code>uart8250</code>\u2019s MMIO address, enabling the device to generate an interrupt when input is available. We then register interrupt 10 with the PLIC, routing it to the current core\u2019s S-mode, and handle it in <code>kernel_trap</code>.</p> <pre><code>if (cause &amp; SCAUSE_INTERRUPT) {\n    // handle interrupt\n    switch (exception_code) {\n        case SupervisorExternal:\n            debugf(\"s-external interrupt.\");\n            plic_handle();\n            break;\n    }\n}\n</code></pre> <p>The <code>plic_handle</code> function claims the current external interrupt\u2019s source number from the PLIC. If it\u2019s UART0\u2019s interrupt 10, it passes it to <code>uart_intr()</code> for processing.</p>"},{"location":"laben/xv6lab-pagefault/","title":"Page Fault","text":""},{"location":"laben/xv6lab-pagefault/#experiment-objectives","title":"Experiment Objectives","text":"<ol> <li>Understand what a page fault is.</li> <li>Master the three types of page fault handling methods.</li> <li>Learn several basic page replacement algorithms.</li> </ol> <p>xv6-lab7 Code Branch</p> <p>https://github.com/yuk1i/SUSTechOS/tree/pgfault</p> <p>Note: The repository is not the same as the previous SUSTech-OS-2025.</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTechOS -b pgfault xv6lab7</code> to download the xv6lab7 code.</p> <p>Use <code>make run</code> to run the kernel for this lab, and run the <code>pgfault</code> program. Refer to <code>user/src/pgfault.c</code> to observe the behavior of the kernel.</p>"},{"location":"laben/xv6lab-pagefault/#page-fault_1","title":"Page Fault","text":"<p>A Page Fault is an exception. If a requested virtual address (for instruction fetch, read, or write) does not match the page table's description, the MMU triggers a Page Fault exception. The <code>Exception Code</code> in <code>scause</code> defines three types of Page Faults: <code>Instruction page fault</code>, <code>Load page fault</code>, and <code>Store/AMO page fault</code>.</p> <p>The privileged architecture manual, in section <code>4.3.2 Virtual Address Translation Process</code>, specifies all scenarios that may cause a page fault during address translation.</p> <p>When an exception occurs, <code>stval</code> is set to the virtual address causing the Page Fault:</p> <p>If stval is written with a nonzero value when a breakpoint, address-misaligned, access-fault, or page-fault exception occurs on an instruction fetch, load, or store, then stval will contain the faulting virtual address.</p>"},{"location":"laben/xv6lab-pagefault/#demand-paging","title":"Demand Paging","text":"<p>In modern operating systems, Demand Paging is a memory management strategy that loads a page into memory only when a program accesses it. Unlike traditional methods that load all pages of a program into memory at once, demand paging uses memory resources more efficiently and avoids waste.</p> <p>In the current xv6 system, each user process's stack is allocated 8 physical pages. But do user processes really need all 8 pages?  The stack grows from high to low addresses, meaning it expands dynamically during execution. Early in a process's lifecycle, it may not use all allocated stack space, so allocating a large amount of memory upfront could waste resources.</p> <p>Instead, we can initially allocate only 2 physical pages for the stack and allocate additional pages when the user process needs them.  When a user process accesses a virtual address, the CPU may find no mapping for it in the page table, triggering a Page Fault.</p> <p>Although this virtual address is invalid to the CPU, the kernel has reserved space for it. Upon receiving the Page Fault, the kernel recognizes that the process needs this page, allocates a physical page, updates the page table, and resumes execution from the faulting instruction. The CPU then finds the address valid, and to the user process, the brief pause is imperceptible.</p>"},{"location":"laben/xv6lab-pagefault/#page-fault_2","title":"Page Fault","text":"<p>As mentioned, when a process requests memory, the operating system grants it a range of virtual addresses without allocating corresponding physical memory. When the process accesses such an address, the lack of a physical mapping triggers a page fault, prompting the OS to allocate physical memory and establish the address mapping in the page table.</p> <p>A page fault occurs when the CPU accesses a virtual address without a corresponding physical memory mapping. Possible causes include:</p> <ol> <li>No Page Table Entry (PTE) exists for the virtual address (invalid virtual address or valid but unmapped).</li> <li>The current privilege level cannot access the PTE.</li> </ol> <p>In Linux, page faults are categorized into three types:</p> <ol> <li>Major page fault (hard page fault) </li> </ol> <p>The requested virtual address's content is not in memory and must be loaded from external storage, often because the page was swapped out to a swap space.</p> <ol> <li>Minor page fault (soft page fault) </li> </ol> <p>The virtual address lacks a mapping in the page table, common when a process first accesses newly allocated memory or when multiple processes share memory without established mappings.</p> <ol> <li>Invalid fault </li> </ol> <p>The accessed virtual address is illegal.</p> <p>In xv6, the page fault handling process is as follows:</p> <p></p>"},{"location":"laben/xv6lab-pagefault/#implementation","title":"Implementation","text":"<p>In xv6, a user\u2019s virtual address space is represented in two ways: the VMA (Virtual Memory Area) structure and the page table. The latter is required by the CPU for address translation, while the former is more convenient for OS code.</p> <p>When allocating virtual address space for a user, we store it in the VMA structure but do not map physical pages immediately. Physical pages are mapped only when the user accesses the address, triggering a Page Fault.</p> <p>When a Page Fault occurs, we check if the virtual address in <code>stval</code> is within the VMA structure. If not, the exception indicates an illegal memory access by the user program. If it is, the address is a valid user virtual address, so we allocate a physical page and map it in the page table.</p> <p>Alternative Approach</p> <p>Another way to mark a virtual address as \"valid but unmapped\" leverages the PTE structure. The 0<sup>th</sup> bit, the <code>V</code> (valid) flag, is checked by the MMU during address translation. If set to 0, the PTE is considered unusable, and the upper 63 bits are ignored.</p> <p>In the OS, memory-aligned pointers always have a 0 in the least significant bit. Thus, we can store a pointer in the PTE instead of a valid PTE, pointing to a kernel object representing a \"valid but unmapped\" virtual address. During a Page Fault, we can extract information from this object.</p> <p>Related Implementation</p> <p>If interested, you can refer to MIT 6.828\u2019s original mmap lab and implement mmap on our modified xv6 (which differs from the original xv6).  </p> <p>https://pdos.csail.mit.edu/6.828/2024/labs/mmap.html</p>"},{"location":"laben/xv6lab-pagefault/#page-replacement-swap","title":"Page Replacement (Swap)","text":"<p>When allocating a physical page, we call <code>kallocpage</code>. But what happens when no free physical pages are available?</p> <p>In cases of allocation failure, we can return an error to the caller, as seen in <code>fork</code> and <code>exec</code>, which return a negative number to indicate failure.</p> <p>Sometimes, we want the kernel to maintain sufficient physical pages. When available physical pages fall below a threshold (referred to as low/high watermark in theory), the kernel can swap out pages to secondary storage (e.g., a hard disk, as per CSAPP\u2019s Memory Hierarchy) to free up space.</p> <p>CSAPP: Memory Hierarchy</p> <p></p> <p>What if a swapped-out page is needed later? Recalling Demand Paging, pages are loaded only when accessed, causing a Page Fault. For swapped-out pages, the corresponding PTE becomes invalid, triggering a Page Fault upon access. The kernel then swaps in the page from secondary storage, reestablishes the page table mapping, and resumes execution.</p> <p>The strategy for choosing which page to swap out is called a page replacement algorithm.</p> <p>The following flowchart illustrates when page replacement is needed: </p> <p>Referring to the Memory Hierarchy, secondary storage (e.g., disks) has slower access speeds and higher latency than memory. Thus, we aim to minimize swapping. How do we choose which pages to swap out?</p>"},{"location":"laben/xv6lab-pagefault/#page-replacement-algorithms","title":"Page Replacement Algorithms","text":"<p>For problems involving limited resources and the need to evict items, two implementation-friendly algorithms are commonly used: FIFO and LRU (e.g., in CPU L1/L2/L3 caches or TLBs).</p> <ul> <li> <p>First In First Out (FIFO) Page Replacement Algorithm: This algorithm always evicts the page that entered memory first, i.e., it selects the page that has resided in memory the longest for eviction. It works by linking the pages loaded into memory during the execution of an application into a queue in the order they were loaded. The head of the queue points to the page that has been in memory the longest, while the tail points to the most recently loaded page. When a page needs to be evicted, the algorithm easily finds the target page at the head of the queue. The FIFO algorithm performs well only when the application accesses the address space in a linear sequence; otherwise, its efficiency is low. This is because frequently accessed pages often reside in memory the longest and end up being evicted due to becoming \"old.\" Another drawback of the FIFO algorithm is its anomaly (Belady\u2019s anomaly), where increasing the number of physical page frames can paradoxically increase the number of page faults.</p> </li> <li> <p>Least Recently Used (LRU) Algorithm: Leveraging the principle of locality, this algorithm predicts future access patterns based on past behavior. It assumes that pages accessed recently are more likely to be accessed again, while those unused for a long time are less likely to be needed. The algorithm compares the most recent access times of the pages currently in memory and evicts the one that was accessed the furthest in the past.</p> </li> <li> <p>Clock Page Replacement Algorithm: This is an approximate implementation of the LRU algorithm. The clock algorithm organizes pages into a circular linked list, resembling the face of a clock. A pointer (called the current pointer) points to the oldest page, i.e., the one that was loaded earliest. Additionally, the clock algorithm requires an access bit in the page table entry (PTE) to indicate whether the corresponding page has been accessed recently. When the page is accessed, the CPU\u2019s MMU hardware sets the access bit to \"1.\" When the operating system needs to evict a page, it checks the access bit of the page pointed to by the current pointer. If the bit is \"0,\" the page is evicted. If the page has been modified, it must also be written back to the disk. If the access bit is \"1,\" it is reset to \"0,\" and the pointer moves to the next page. This algorithm approximates the LRU idea, is easy to implement, and has low overhead, though it requires hardware support to set the access bit. The clock algorithm is essentially similar to FIFO but skips pages with an access bit of \"1.\"</p> </li> <li> <p>Enhanced Clock Page Replacement Algorithm: In the clock algorithm, only the access status of a page is considered during eviction. However, in practice, whether a page has been modified should also be taken into account. Evicting a modified page requires writing it back to the disk, making the replacement cost higher than for an unmodified page. Thus, the enhanced clock algorithm prioritizes evicting unmodified pages to reduce disk operations. In addition to tracking access status, this algorithm also considers modification status. It aims to evict pages that are both least recently used and unmodified during their residence in memory. This requires adding an access bit and a modified bit to each page table entry. When a page is accessed, the CPU\u2019s MMU hardware sets the access bit to \"1.\" When a page is written to, the modified bit is set to \"1.\" These two bits create four possible combinations: (0, 0) indicates the page was neither accessed nor modified recently and is the first choice for eviction; (0, 1) means the page was not accessed recently but was modified, making it the second choice; (1, 0) means the page was accessed recently but not modified, the third choice; and (1, 1) means the page was both accessed and modified recently, the last choice. Compared to the basic clock algorithm, the enhanced version further reduces disk I/O operations. However, finding a suitable page for eviction may require multiple scans, increasing the algorithm\u2019s execution overhead.</p> </li> </ul>"},{"location":"laben/xv6lab-pagefault/#pte-ad","title":"PTE A/D","text":"<p>How does the OS know a page was \"recently accessed\"?</p> <p>The PTE includes two flags: A (Access) and D (Dirty), indicating whether the mapped virtual address was read or written, respectively. The MMU sets these bits during address translation, allowing the OS to track access.</p> <p>For \"recently,\" the OS can use an approximation. For example, it might clear all A/D bits every 10ms. If the bits are set at the next check, the page was accessed within that 10ms window.</p>"},{"location":"laben/xv6lab-paging/","title":"RISC-V Page Table Model &amp; xv6 Kernel Page Tables","text":""},{"location":"laben/xv6lab-paging/#experiment-objectives","title":"Experiment Objectives","text":"<ol> <li>Understand the RISC-V SV39 page table model.</li> <li>Master the mechanism of virtual address to physical address translation.</li> <li>Understand how XV6 manages memory and creates page tables.</li> </ol>"},{"location":"laben/xv6lab-paging/#segmentation","title":"Segmentation","text":"<p>From the perspective of memory access protection, we desire memory access to be permission-protected. This involves two aspects:</p> <ol> <li>Whether the memory address is readable, writable, or executable.</li> <li>Whether the memory address allows access from lower privilege levels.</li> </ol> <p>In other words, for each memory address, we want to verify that its operational permissions align with the original program design.</p> <p>In CPU implementations, memory is addressed in byte units. Managing access permissions for every single byte would incur an unimaginable cost.  However, we can group code and data with the same permissions together, dividing the program's memory space into several large segments. Each segment has its own base address (Base), size limit (Limit), and permission settings. This is the approach of using Segmentation for memory protection.</p> <p>Segmentation has several disadvantages in memory space management, such as requiring contiguous physical memory, difficulty in dynamically resizing, and fragmentation issues. Therefore, modern CPUs and operating systems use the Paging mechanism for memory management.</p>"},{"location":"laben/xv6lab-paging/#paging","title":"Paging","text":"<p>The paging mechanism divides the program space (virtual address space) into fixed-size pages and similarly splits physical memory into pages of the same size. This allows sufficient memory allocation for a process even when physical addresses are non-contiguous, while appearing contiguous from the virtual address perspective.</p> <p>Why do we need a virtual address space?</p> <p>If we only had physical memory space, we could still write programs, but all programs\u2014including the kernel and user programs\u2014would operate in the same address space. The address <code>0x80200000</code> accessed by a user program would be the same as <code>0x80200000</code> accessed by the kernel. Is this a problem? If only one program is running, it\u2019s fine. But when multiple programs share the same memory space, issues arise: how do we prevent programs from interfering with or even sabotaging each other?</p> <p>A straightforward solution is to ensure that <code>0x80200000</code> accessed by a user program and <code>0x80200000</code> accessed by the kernel are not the same address. Since we only have one physical memory, we can introduce a \"translation\" mechanism to create distinct address spaces: the addresses used by programs (virtual addresses) must be \"translated\" into actual physical memory addresses. This \"translation\" process is implemented using a \"dictionary\" (page table)\u2014given an address before translation, the corresponding translated address can be looked up in the dictionary.</p> <p>Each program has its own unique \"dictionary,\" and the memory it can use is limited to what\u2019s defined in its dictionary.</p> <p>Does the \"dictionary\" translate every usable byte? Imagine that storing the translation result for each byte requires at least one byte. For 1MB of memory, we\u2019d need at least a 1MB \"dictionary,\" which is highly inefficient. In practice, a program\u2019s memory usage is typically orders of magnitude larger than bytes\u2014often in KB units (hence the ancient saying, \"640K ought to be enough for anybody,\" not \"640B ought to be enough for anybody\"). Thus, we can group many contiguous bytes together for translation, ensuring the difference between pre- and post-translation values is consistent. This is the concept of a \"page.\"</p>"},{"location":"laben/xv6lab-paging/#virtual-address-physical-address","title":"Virtual Address =&gt; Physical Address","text":"<p>A critical aspect of the paging mechanism is how to establish and resolve the mapping from virtual addresses to physical addresses. Below, we explain this from the perspective of \"how to obtain the corresponding physical address from a virtual address\":</p>"},{"location":"laben/xv6lab-paging/#single-level-page-table","title":"Single-Level Page Table","text":"<p>The figure below illustrates a single-level page table paging mechanism (single-level refers to requiring only one layer of page table lookup to obtain the physical address, hereafter called a \"single-level page table\"):</p> <p></p> <p>Using the figure as an example, we start with a virtual address ( Virtual Address ), which is 6 bits long. Bits 5\u20134 (the top 2 bits) represent the page number (VPN, Virtual Page Number), while bits 3\u20130 (the bottom 4 bits) represent the offset (Offset).</p> <p>Using the virtual address, we can query the page table ( Page Table ), which resides in the memory space pointed to by the page table base address ( PageTablePtr, Page Table Pointer , a physical address). The page table consists of several consecutively stored page table entries (PTE, Page Table Entry). In a single-level page table, each PTE contains the physical page number (Page Frame #) + some flag bits. Although the figure shows each PTE seemingly containing a page number (Page #), in actual designs, the page number (VPN) is not stored in the PTE. Since PTEs are stored contiguously, knowing the PTE size (in bits) and the virtual page number (VPN, indicating which PTE to query) allows us to calculate the PTE address as <code>page table base address + page number \u00d7 PTE size</code>. The content at this address yields the physical page number. The page table base address is stored in an architecture-specified register.</p> <p>After obtaining the physical page number, the physical address of the page can be calculated as <code>physical page number \u00d7 page size</code> (assuming the physical space starts at 0x0). A page can be large\u2014how do we get the address of a specific byte within it? Using the offset, the specific physical address corresponding to the virtual address is <code>page physical address + offset</code>.</p> <p>An Example</p> <p>Suppose the page size is 4KiB. To locate each byte within a page, the offset must represent 4096 distinct positions, requiring 12 bits (2<sup>12</sup> = 4096). Alternatively, if the offset is 12 bits, the page size can be deduced as 2<sup>12</sup> bytes.</p> <p>In the single-level page table from the figure, the offset is 4 bits, indicating a page size of 2<sup>4</sup> = 16B. Given a virtual address <code>100100</code> (binary), the page number is <code>10</code> (binary, i.e., 2 in decimal). Using page number 2, we look up the PTE content, which is <code>5</code> (binary). The physical page number is 5, and the physical page address is: physical base address + physical page number \u00d7 page size = 0 + 5 \u00d7 16 = 80 (decimal). The offset from the virtual address <code>100100</code> is <code>0100</code> (4 in decimal), querying the 5<sup>th</sup> byte of the page (address 0 counts as one byte). Thus, the physical address is 80 + 4 = 84 (decimal) (5 \u00d7 16 + 4 = 0101 shifted left 4 bits + 0100 = 0101 0100 in binary). Pay attention to whether calculations use binary, decimal, or hexadecimal (storage is always binary).</p>"},{"location":"laben/xv6lab-paging/#multi-level-page-table","title":"Multi-Level Page Table","text":"<p>In systems, the page size is typically 4KiB. In a 32-bit system with a 32-bit virtual address space (2^32 = 4GiB), a single-level page table would require 1M PTEs to map all physical pages. Assuming each PTE is 4B, the page table size would be 4MiB. Since virtual addresses are contiguous (i.e., high-order VPNs are contiguous) and PTEs are stored consecutively like an array, even if a process uses minimal space, a complete, contiguous page table is needed for address translation (unused intermediate PTEs cannot be omitted). In an OS, beyond the kernel page table, each process gets its own page table, and with many processes, the overhead of storing all page tables becomes significant.</p> <p>This necessitates multi-level page tables, as shown below in a two-level page table mechanism (Sv32):</p> <p></p> <p>Unlike a single-level page table, Sv32 splits the virtual address into three parts: <code>VPN[1], VPN[0], offset</code>. In Sv32, each page is 4KiB, each PTE is 4 bytes, and each page table contains <code>2^10 = 1024</code> PTEs.</p> <p>The translation process for a 32-bit virtual address in the figure is as follows:</p> <pre><code>    1. Use `PageTablePtr + VPN1 * 4` to get the first-level PTE address (`PageTablePtr` is stored in a designated register).\n    2. Retrieve the PFN from the first-level PTE, representing the base address of the second-level page table. Compute the second-level page table base address as `PFN * 4Ki`.\n    3. Use `second-level page table base address + VPN0 * 4` to get the second-level PTE address.\n    4. Retrieve the PFN from the second-level PTE, representing the final physical page. Compute the final physical address as `PFN * 4Ki + offset`.\n</code></pre> <p>Thinking</p> <p>Why does a multi-level page table save space compared to a single-level page table?</p> <p>Consider a 4GiB memory space with a 4KiB page size and 4-byte PTEs. If a process only needs one 4KiB page at the high virtual address (0xffff_f000) and one at the low virtual address (0x0000_0000), we can compare the page table space required under single-level and two-level mechanisms.</p> <p>Single-Level Page Table: Despite needing only the 0<sup>th</sup> and last PTEs, a single-level page table requires 4GiB / 4KiB = 1M contiguous PTEs to map the entire virtual address space. Thus, the page table size is 1M * 4B = 4MiB.</p> <p>Multi-Level Page Table: In a multi-level mechanism, the address space managed by each lower-level page table increases hierarchically.  In Sv32, each PTE in the second-level page table manages <code>4KiB</code>, so the entire second-level table manages <code>1024 * 4KiB = 4MiB</code>. Each PTE in the first-level page table manages a second-level page table, meaning each first-level PTE effectively manages <code>4MiB</code>.</p> <p>For large, contiguous unused regions, we can avoid allocating second-level page tables, which is why multi-level page tables save space.</p> <p>In this case, we allocate two PTEs in the first-level page table to manage two second-level page tables. In the first second-level table, the 0<sup>th</sup> PTE maps virtual address <code>0x0000_0000</code>. In the second, the 1023<sup>rd</sup> PTE maps <code>0xffff_f000</code>.</p> <p>Summary: To manage these two virtual pages, the two-level page table requires 2 second-level tables and 1 first-level table (unused second-level PTEs can be marked invalid without allocation). Since both levels\u2019 page tables are 4KB, the total space is 2 * 4KB + 4KB = 12KB.</p> <p>This example shows that the hierarchical management of a two-level page table significantly reduces space overhead, especially when mapping sparse memory.</p> <p>Note</p> <p>The translation of virtual to physical addresses is performed by the CPU\u2019s Memory Management Unit (MMU) and does not require us to write code for it.</p> <p>Our task in the OS is to construct the \"dictionary\"\u2014the page table\u2014by allocating page table space and filling in PTEs.</p>"},{"location":"laben/xv6lab-paging/#translation-lookaside-buffer-tlb","title":"Translation Lookaside Buffer (TLB)","text":"<p>Physical memory access is much slower than CPU execution, often requiring hundreds of clock cycles per access (known as the \"von Neumann bottleneck\").</p> <p>Page tables are stored in physical memory. Following the page table mechanism step-by-step, translating a virtual address to a physical one requires 3 physical memory accesses, followed by another to fetch the desired data, significantly reducing efficiency.</p> <p>Fortunately, virtual address access exhibits temporal locality and spatial locality:</p> <ul> <li>Temporal locality: An address accessed once is likely to be accessed again soon.</li> <li>Spatial locality: If an address is accessed, nearby addresses are likely to be accessed soon.</li> </ul> <p>Thus, CPUs use a Translation Lookaside Buffer (TLB) to cache recently completed virtual-to-physical page mappings. Due to locality, a mapping is likely to have been recently performed, so checking the TLB first can bypass multiple memory accesses if the mapping is found.</p> <p>However, if we modify the root page table register (e.g., changing the PPN field), switching to a completely different page table, the TLB\u2019s cached mappings become outdated and potentially incorrect. In this case, we must use a specific instruction to flush the TLB. In RISC-V, this is <code>sfence.vma</code>.</p> <p>Similarly, manually modifying a PTE alters the mapping, but the TLB doesn\u2019t automatically refresh. We must explicitly flush it.</p> <p>In RISC-V, <code>sfence.vma</code> without parameters flushes the entire TLB. With a virtual address parameter, it flushes only that address\u2019s mapping.</p>"},{"location":"laben/xv6lab-paging/#risc-v-sv39-paging-mechanism","title":"RISC-V Sv39 Paging Mechanism","text":""},{"location":"laben/xv6lab-paging/#satp","title":"satp","text":"<p>The satp (Supervisor Address Translation and Protection) register controls address translation in S-mode and U-mode, with three fields: <code>MODE</code>, <code>ASID</code>, and <code>PPN</code>.</p> <p></p> <p>Mode specifies the address translation mode. A value of 0 disables translation, treating all requested addresses as physical, while <code>PPN</code> denotes the root page table\u2019s base address. In this course, we use Sv39 as the page table mode.</p> <p>We can ignore ASID for now.</p> <p></p>"},{"location":"laben/xv6lab-paging/#sv39","title":"Sv39","text":"<p>RISC-V\u2019s Sv39 mode supports a 39-bit virtual address space, with each page being 4KiB and each PTE 8 bytes, meaning each page table has <code>2^9 = 512</code> PTEs. Sv39 requires each page table to be a page-aligned, i.e., its base address aligns to 4KiB.</p> <p>RISC-V CPUs use 64-bit virtual addresses. In Sv39, only 39 bits are effective, and bits 63\u201339 must match bit 38 (sign-extension). Otherwise, the virtual address is illegal. Thus, Sv39\u2019s virtual address space totals <code>(1 &lt;&lt; 39) = 512 GiB</code>, split into 256 GiB of low addresses (<code>0x0000_0000_0000_0000</code> - <code>0x0000_003f_xxxx_xxxx</code>) and 256 GiB of high addresses (<code>0xffff_ffc0_0000_0000</code> - <code>0xffff_ffff_xxxx_xxxx</code>).</p> <p></p> <p>The virtual address is divided into four parts: VPN[2-0] (Virtual Page Number) and page offset. The three-level VPNs serve as indices in the three-level page table, while the page offset indicates the address\u2019s offset within the translated page.</p> <p>An Sv39 PTE is 8 bytes, split into PPN (Physical Page Number) and Flags. The PPN, combined with the virtual address\u2019s page offset, forms the final physical address, while Flags specify access permissions and other details.</p>"},{"location":"laben/xv6lab-paging/#flags","title":"Flags","text":"<p>Flags are defined as follows:</p> <ul> <li>D, A: Dirty, Accessed. Indicate if the page was recently accessed/written.</li> <li>G: Global. Indicates the mapping exists in all page tables.</li> <li>U: User. Allows access in user privilege mode.</li> <li>V: Valid. Marks the PTE as valid; otherwise, the entire PTE is invalid.</li> <li>R, W, X: Read, Write, Executable permissions.</li> </ul> <p>RWX is defined as shown below: Note that <code>XWR == 3'b000</code> indicates the physical address [PPN: 12b0] is the base address of the next-level page table; otherwise, the PTE is a leaf PTE.</p> <p></p>"},{"location":"laben/xv6lab-paging/#a-d","title":"A &amp; D","text":"<p>Each page PTE includes Accessed (A) and Dirty (D) bits:</p> <ul> <li>A: Set if the virtual page was read, written, or fetched (instruction fetch) since the last A-bit clear.</li> <li>D: Set if the virtual page was written since the last D-bit clear.</li> </ul> <p>When accessing a virtual page with A=0 or writing with D=0, RISC-V allows two update methods:</p> <ol> <li>Trigger a PageFault, requiring the Supervisor exception handler to manually set A/D bits.</li> <li>Hardware automatically sets A/D bits.</li> </ol> <p>Supervisor software must handle both cases correctly.</p>"},{"location":"laben/xv6lab-paging/#permission-checks","title":"Permission Checks","text":"<p>Intuitively, a readable page needs the R bit, a writable page needs the W bit, and an executable page needs the X bit.</p> <p>However, if a page has the U bit and the CPU is in S-mode, we must check the SUM (Supervisor User Memory access) bit in <code>sstatus</code>. If <code>sstatus.SUM == 1</code>, access is permitted; otherwise, it causes a Page Fault.</p> <p>Typically, S-mode runs with <code>sstatus.SUM == 0</code>. To access user data via the page table, we set this flag to 1 and clear it afterward. This process is often called the uaccess primitive.</p> <p>See also: https://github.com/torvalds/linux/blob/master/arch/riscv/include/asm/uaccess.h</p> <p>The Sv39 address translation process is shown below (L2, L1, L0 represent VPN2, VPN1, VPN0, with lower addresses at the bottom and higher at the top in the Page Directory):</p> <p></p> <p>See also: riscv-privilege.pdf, 4.3.2 Virtual Address Translation Process</p> <p>Text description: <code>{xx | yy}</code> denotes concatenating <code>yy</code> bits to the right of <code>xx</code> bits, similar to Verilog syntax.</p> <ol> <li>Decompose Virtual Address: <code>{ 25'signed_ext, 9'VPN2, 9'VPN1, 9'VPN0, 12'pgoff} = 64'VirtualAddress</code></li> <li>Use the PPN from the satp register as the first-level page table\u2019s base address.</li> <li>Use VPN2 as the index to find pte2 in the first-level page table.</li> </ol> <p>Equivalent C code: <code>uint64 pte2 = *(uint64*)(satp.base + VPN2 * 8);</code></p> <ol> <li>If <code>pte2.WXR != 3'b000</code>, it\u2019s a 1GiB huge page mapping.</li> </ol> <p>Check if PPN is 1GiB-aligned: <code>pte2.PPN1 == 9'b0 &amp;&amp; pte2.PPN0 == 9'b0</code>. If true, go to step 10; otherwise, Page Fault.</p> <ol> <li><code>{pte2.PPN, 12'b0}</code> is the second-level page table\u2019s base address.</li> <li>Use VPN1 as the index to find pte1 in the second-level page table.</li> </ol> <p>Equivalent C code: <code>uint64 pte1 = *(uint64*)((pte2.ppn &lt;&lt; 12) + VPN1 * 8);</code></p> <ol> <li>If <code>pte1.WXR != 3'b000</code>, it\u2019s a 2MiB huge page mapping.</li> </ol> <p>Check if PPN is 2MiB-aligned: <code>pte2.PPN0 == 9'b0</code>. If true, go to step 10; otherwise, Page Fault.</p> <ol> <li>Otherwise, <code>{pte1.PPN | 12'b0}</code> is the third-level page table\u2019s base address.</li> <li>Use VPN0 as the index to find PTE in the third-level page table.</li> </ol> <p>Equivalent C code: <code>uint64 pte0 = *(uint64*)((pte1.ppn &lt;&lt; 12) + VPN0 * 8);</code></p> <ol> <li> <p>Compute the final physical address: <code>PA = (leaf_pte.ppn &lt;&lt; 12) | final_page_offset</code>,</p> <p>For 2MiB huge pages: <code>final_page_offset = {9'VPN0, 12'pgoff}</code>.</p> <p>For 1GiB huge pages: <code>final_page_offset = {9'VPN1, 9'VPN0, 12'pgoff}</code>.</p> <p>Otherwise: <code>final_page_offset = 12'pgoff</code>.</p> </li> <li> <p>Permission check: Verify <code>leaf_pte.rwx</code> matches the memory access request.</p> </li> </ol>"},{"location":"laben/xv6lab-paging/#huge-page-mapping","title":"Huge Page Mapping","text":"<p>When all XWR bits in Flags are 0, the PTE points to the next-level page table. If any XWR bit is non-zero, the PTE is a leaf node, meaning its PPN represents the physical page\u2019s base address, not a page table\u2019s base address.</p> <p>For example, in Sv39, given a virtual address VA[38:0], we compute the first-level PTE address using <code>satp.PPN \u00d7 4096 + VPN2</code>. If the PTE\u2019s XWR is 001, it\u2019s a leaf PTE (huge page mapping). Since the first-level PTE is a leaf, the virtual address interpretation changes from:</p> <p></p> <p>to:</p> <p></p> <p>The physical address becomes <code>PTE.PPN \u00d7 4096 + VA[29:0]</code>. Here, the 30-bit offset represents a large space (2<sup>30</sup> bytes = 1GiB) starting from PTE.PPN \u00d7 4096, called a giga-page. (Note: In architectures supporting huge pages, the base address must align to its size, e.g., giga-page base addresses must align to 1GB, meaning the lower 30 bits of PTE.PPN * 4096 must be 0.)</p> <p>Similarly, if a second-level PTE is a leaf, its <code>[20:0]</code> bits represent a combined offset for a smaller huge page, called a mega-page. Typically, third-level PTEs are leaves, pointing to a base page (4KB).</p>"},{"location":"laben/xv6lab-paging/#lab-classroom-report","title":"Lab Classroom Report","text":"<ol> <li>Referring to the Sv39 address translation mode, decode the following virtual addresses and write their VPN[2-0] and offset in binary. Note: Use binary representation!</li> </ol> vaddr VPN2 VPN1 VPN0 offset <code>0x0000_0000_8020_1234</code> <code>0x0000_003f_ffff_f000</code> <code>0xffff_ffd1_dead_beef</code> <p>Hint: Use the Windows Calculator in Programmer mode to convert between hex, decimal, and binary, or use Python3\u2019s <code>bin(0x1122_3344)</code> to convert to binary.</p> <ol> <li>Referring to Sv39 mode, manually perform address translation and list all valid mappings in the page table.</li> </ol> <p><code>satp: 0x8000000000080400</code></p> <p>Hexdump of partial memory is shown below. The left side of the colon is the address; the right side shows two <code>uint64_t</code> values in hex at that address and address + 0x8. Unspecified memory is all 0s. The hexdump is in little-endian order, so no endianness adjustment is needed.</p> <pre><code>0x8040_0000:\n0x0000000080400000:     0x0000000020100401\n0x00000000804004a8:     0x0000000020101401\n0x00000000804007f8:     0x0000000020100c01\n\n0x8040_1000:\n0x0000000080401000:     0x0000000020100801\n\n0x8040_2000:\n0x0000000080402008:     0x000000002000001f\n0x0000000080402010:     0x000000002000041f\n\n0x8040_3000:\n0x0000000080403ff8:     0x0000000020101001\n\n0x8040_4000:\n0x0000000080404ff8:     0x000000003777400b\n\n0x8040_5000:\n0x00000000804056f0:     0x00000037ab400043\n</code></pre> <p>Note: All numbers are in hexadecimal; follow the format of the first row in the table.</p> Virtual Address Size PPN Flags(DAGUXWRV) <code>0xdead_beef_aabb_ccdd</code> <code>0x00aa_eeff</code> <code>0x8899_0000</code> <code>DA-UWXRV</code> <ol> <li>On the RISC-V platform, the page size is <code>4KiB</code>. In 32-bit mode, we use Sv32; in 64-bit mode, we use Sv39. Given that Sv32 PTEs are 4 bytes and Sv39 PTEs are 8 bytes:</li> </ol> <p>Sv32 page tables consist of 2^10 page-table entries (PTEs), each of four bytes. A page table is exactly the size of a page and must always be aligned to a page boundary. The physical page number of the root page table is stored in the satp register.</p> <p>Sv39 page tables contain 2^9 page table entries (PTEs), eight bytes each. A page table is exactly the size of a page and must always be aligned to a page boundary. The physical page number of the root page table is stored in the satp register\u2019s PPN field.</p> <p>Briefly explain why each VPN in Sv32 is 10 bits, while each VPN in Sv39 is 9 bits.</p>"},{"location":"laben/xv6lab-paging/#experiment-scenario","title":"Experiment Scenario","text":"<p>xv6-lab4 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab4</p> <p>Use <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab4 xv6lab4</code> to download the xv6-lab4 code.</p> <p>Run <code>make run</code> to start the kernel for this lab. The kernel will perform relocation and boot, eventually running with a high-address PC and SP.</p> <pre><code>Kernel Starts Relocating...\nKernel size: 0x000000000002e000, Rounded to 2MiB: 0x0000000000200000\n[INFO  0,-1] bootcpu_start_relocation: Kernel phy_base: 0x0000000080200000, phy_end_4k:0x000000008022e000, phy_end_2M 0x0000000080400000\nMapping Identity: 0x0000000080200000 to 0x0000000080200000\nMapping kernel image: 0xffffffff80200000 to 0x0000000080200000\nMapping Direct Mapping: 0xffffffc080400000 to 0x0000000080400000\nEnable SATP on temporary pagetable.\nBoot HART Relocated. We are at high address now! PC: 0xffffffff80203d68\n[INFO  0,-1] kvm_init: boot-stage page allocator: base 0xffffffc080400000, end 0xffffffc080600000\n[INFO  0,-1] kvmmake: Memory after kernel image (phys) size = 0x0000000007c00000\n[INFO  0,-1] kvm_init: enable pageing at 0x8000000000080400\n[INFO  0,-1] kvm_init: boot-stage page allocator ends up: base 0xffffffc080400000, used: 0xffffffc080411000\nRelocated. Boot halt sp at 0xffffffffff001fb0\n</code></pre> <p>In this lab\u2019s code, we will construct a virtual address space for the kernel and transition the OS from running in physical address space to virtual address space.</p> <p>The code execution flow is as follows:</p> <ol> <li> <p><code>entry.S</code>\u2019s <code>_entry</code>: OS entry point.</p> </li> <li> <p><code>main.c</code>\u2019s <code>bootcpu_entry</code>: C language entry point.</p> </li> <li> <p><code>main.c</code>\u2019s <code>bootcpu_start_relocation</code>: Relocate PC and satp, setting a temporary page table.</p> </li> <li> <p><code>main.c</code>\u2019s <code>bootcpu_relocating</code>: Call <code>kvm_init</code> to complete kernel page table setup and switch.</p> </li> <li> <p><code>main.c</code>\u2019s <code>bootcpu_init</code>: Kernel initialization, jumping to <code>scheduler</code>.</p> </li> </ol> <p>To switch from running in physical address space to virtual address space, we first need to understand where the kernel resides in physical space:</p>"},{"location":"laben/xv6lab-paging/#risc-v-physical-address-layout","title":"RISC-V Physical Address Layout","text":"<p>RISC-V maps physical memory (DDR/DRAM) starting at physical address <code>0x8000_0000</code>, not <code>0x0000_0000</code>.</p> <p>For example, with 128 MiB (0x0800_0000) of DRAM, a RISC-V core maps it to <code>[0x8000_0000, 0x8800_0000)</code>.</p> <p>For QEMU\u2019s virt machine, we can examine the source code for its physical address mappings:</p> <pre><code>static const MemMapEntry virt_memmap[] = {\n    [VIRT_DEBUG] =        {        0x0,         0x100 },\n    [VIRT_MROM] =         {     0x1000,        0xf000 },\n    [VIRT_TEST] =         {   0x100000,        0x1000 },\n    [VIRT_RTC] =          {   0x101000,        0x1000 },\n    [VIRT_CLINT] =        {  0x2000000,       0x10000 },\n    [VIRT_ACLINT_SSWI] =  {  0x2F00000,        0x4000 },\n    [VIRT_PCIE_PIO] =     {  0x3000000,       0x10000 },\n    [VIRT_PLATFORM_BUS] = {  0x4000000,     0x2000000 },\n    [VIRT_PLIC] =         {  0xc000000, VIRT_PLIC_SIZE(VIRT_CPUS_MAX * 2) },\n    [VIRT_APLIC_M] =      {  0xc000000, APLIC_SIZE(VIRT_CPUS_MAX) },\n    [VIRT_APLIC_S] =      {  0xd000000, APLIC_SIZE(VIRT_CPUS_MAX) },\n    [VIRT_UART0] =        { 0x10000000,         0x100 },\n    [VIRT_VIRTIO] =       { 0x10001000,        0x1000 },\n    [VIRT_FW_CFG] =       { 0x10100000,          0x18 },\n    [VIRT_FLASH] =        { 0x20000000,     0x4000000 },\n    [VIRT_IMSIC_M] =      { 0x24000000, VIRT_IMSIC_MAX_SIZE },\n    [VIRT_IMSIC_S] =      { 0x28000000, VIRT_IMSIC_MAX_SIZE },\n    [VIRT_PCIE_ECAM] =    { 0x30000000,    0x10000000 },\n    [VIRT_PCIE_MMIO] =    { 0x40000000,    0x40000000 },\n    [VIRT_DRAM] =         { 0x80000000,           0x0 },\n};\n</code></pre> <p>For our OS experiments, we only need to focus on DRAM and some peripherals (PLIC, UART):</p> <code>Base</code> Size Description <code>0x0000_1000</code> <code>0x0000_f000</code> BootROM <code>0x0c00_0000</code> <code>0x0060_0000</code> PLIC <code>0x1000_0000</code> <code>0x0000_0100</code> Serial UART <code>0x8000_0000</code> DRAM Size DRAM <p></p> <p>Next, we need to design a memory layout determining how we establish address mappings for the kernel.</p>"},{"location":"laben/xv6lab-paging/#xv6-kernel-memory-layout","title":"xv6 Kernel Memory Layout","text":"<p>Sv39 virtual addresses use sign-extension for high bits, creating a large gap between <code>&lt; 256 GiB</code> and <code>256 GiB ~ 512 GiB</code>. We leverage this to distinguish user addresses (low, starting with <code>0x0000</code>) from kernel addresses (high, starting with <code>0xffff</code>).</p> <code>Base Address</code> Description <code>0x0000_0000_xxxx_xxxx</code> Userspace <code>0x0000_003f_ffff_e000</code> Trapframe <code>0x0000_003f_ffff_f000</code> Trampoline <code>0xffff_ffc0_0000_0000</code> Kernel Direct Mapping of all available physical pages <code>0xffff_fffd_0000_0000</code> Kernel Heap (fixed-size object) <code>0xffff_ffff_8020_0000</code> Kernel Image (.text, .data, .bss) <code>0xffff_ffff_a000_0000</code> Device Memory-Mapped IO <code>0xffff_ffff_d000_0000</code> Kernel stack for processes <code>0xffff_ffff_ff00_0000</code> Kernel stack for per-cpu scheduler <ul> <li>Trampoline serves as a bridge between user and kernel space, placed at the top of the lower 128 GiB.</li> <li>The kernel image (<code>build/kernel</code> ELF file) is mapped to virtual address <code>0xffff_ffff_8020_0000</code>, offset from its physical address <code>0x8020_0000</code> by a constant <code>0xffff_ffff_0000_0000</code>.</li> <li>Additional pages needed by the kernel, such as per-CPU scheduler stacks and MMIO for peripherals, are mapped.</li> <li>All remaining available physical pages are direct-mapped to <code>0xffff_ffc0_80xx_xxxx</code> and managed by <code>kalloc</code>.</li> </ul> <p></p> <p>Direct Mapping</p> <p>For available physical memory, we use Direct Mapping: <code>virtual address = physical address + constant offset</code>.</p> <p>Direct Mapping allows the kernel to directly manipulate all available physical memory, except the kernel image itself.</p> <p>Without Direct Mapping, we\u2019d need to map newly allocated pages into the kernel\u2019s virtual address space to access them. With it, adding a constant offset to a physical address yields a kernel-accessible virtual address:</p> <pre><code>#define KERNEL_DIRECT_MAPPING_BASE  0xffffffc000000000ull\n\n#define KVA_TO_PA(x) (((uint64)(x)) - KERNEL_DIRECT_MAPPING_BASE)\n#define PA_TO_KVA(x) (((uint64)(x)) + KERNEL_DIRECT_MAPPING_BASE)\n</code></pre> <p>After designing the kernel memory layout, we need to transition the kernel from physical to virtual address space, starting with relocation:</p>"},{"location":"laben/xv6lab-paging/#relocation","title":"Relocation","text":"<p>The kernel image (<code>build/kernel</code> ELF file) is initially placed at physical address <code>0x8020_0000</code>. Now, we need to map it to a high address using a fixed offset.</p> <p>Symbols (variables, functions) defined in the kernel are loaded by OpenSBI to physical addresses like <code>0x0000_0000_8020_abcd</code>, and we map them to virtual addresses like <code>0xffff_ffff_8020_abcd</code>. The difference between these addresses is always a fixed value, defined as the kernel offset.</p> <p>We define this as the macro <code>KERNEL_OFFSET</code> and provide macros <code>KIVA_TO_PA</code> and <code>PA_TO_KIVA</code> for conversion (KIVA: Kernel Image Virtual Address):</p> <pre><code>#define KERNEL_VIRT_BASE 0xffffffff80200000ull\n#define KERNEL_PHYS_BASE 0x80200000ull\n#define KERNEL_OFFSET    ((uint64)(KERNEL_VIRT_BASE - KERNEL_PHYS_BASE))\n\n// (Kernel Image Virtual Address) TO (Physical Address)\n#define KIVA_TO_PA(x) (((uint64)(x)) - KERNEL_OFFSET)\n#define PA_TO_KIVA(x) (((uint64)(x)) + KERNEL_OFFSET)\n</code></pre> <p>Shifting the base address of the entire image doesn\u2019t alter the distance between symbols:</p> <ol> <li>Symbol a loads to PA_a <code>0x0000_0000_8020_dead</code>, symbol b to PA_b <code>0x0000_0000_8020_beef</code>.</li> <li>Symbol a maps to VA_a <code>0xffff_ffff_8020_dead</code>, symbol b to VA_b <code>0xffff_ffff_8020_beef</code>.</li> <li><code>PA_a - PA_b = VA_a - VA_b</code>.</li> </ol> <p>This property allows relocation of the kernel image using PC-relative addressing. With PC-relative addressing, we calculate a target symbol\u2019s address using the current PC plus an offset (<code>target = pc + offset</code>, via <code>auipc</code> and <code>addi</code> in assembly), rather than absolute addressing (<code>target = immediate</code>).  Thus, we can relocate the entire kernel image to any base address, as long as symbol offsets remain fixed during compilation and loading. This is also the principle behind Linux\u2019s KASLR (Kernel Address Space Layout Randomization, see: https://lwn.net/Articles/569635/).</p> <p>To relocate the kernel image, we:</p> <ol> <li>Map the kernel image to virtual address <code>0xffff_ffff_8020_0000</code>.</li> <li>Jump the PC to a high address like <code>0xffff_ffff_8020_xxxx</code>.</li> </ol> <p>We expect the kernel to run at <code>0xffff_ffff_8020_0000</code>, so we modify <code>kernel.ld</code> to ensure the linker aligns it correctly:</p> <pre><code>OUTPUT_ARCH(riscv)\nENTRY(_entry)\nBASE_ADDRESS = 0xffffffff80200000;\n</code></pre> <p>However, OpenSBI cannot load the kernel ELF to a physical address if the Program Header\u2019s expected physical address (PhysAddr) is the high address <code>0xffff_ffff_8020_0000</code>, which is invalid during loading. </p> <p>Thus, we specify <code>AT(0x80200000)</code> after the <code>.text</code> section to indicate it should load to physical address <code>0x8020_0000</code>. This ensures the ELF\u2019s Program Headers have <code>VirtAddr = 0xffff_ffff_8020_0000</code> and <code>PhysAddr = 0x8020_0000</code>:</p> <pre><code>BASE_ADDRESS = 0xffffffff80200000;\nSECTIONS\n{\n    . = BASE_ADDRESS;\n    skernel = .;\n    s_text = .;\n\n    .text : AT(0x80200000) {\n        *(.text.entry)\n        // ...\n    }\n    // ...\n}\n</code></pre> <p>Running <code>make run</code> now shows OpenSBI correctly locating the kernel\u2019s entry point:</p> <pre><code>Domain0 Next Address      : 0x0000000080200000\nDomain0 Next Arg1         : 0x000000009fe00000\nDomain0 Next Mode         : S-mode\n...\nclean bss: 0x00000000802ac000 - 0x00000000802b3000\nKernel is Relocating...\n</code></pre> <p>Next, we build page tables to enable the MMU to translate virtual addresses per our layout.</p> <p>If we directly build the kernel memory layout\u2019s page table, switching would require instructions like:</p> <ol> <li><code>csrw satp</code>: Set the satp register to enable Sv39 translation.</li> <li><code>...</code></li> </ol> <p>After executing the first instruction, the PC is at a physical address <code>0x8020_xxxx</code>. However, after we execute the first instruction to set the <code>satp</code> register, the second instruction will immediately begin to execute. At this point, our PC still points to the physical address of the second instruction, and this physical address is invalid in the current page table. As a result, our second instruction will trigger an Instruction Page Fault exception.</p> <p>In other words, after setting up the kernel page table, we cannot directly switch to a page table containing only high addresses because, at that moment, our PC pointer still points to a low address. We cannot simultaneously perform both the PC switch and the <code>satp</code> switch. Therefore, we need a temporary page table that includes two parts of mappings:</p> <ol> <li>VA <code>0x0000_0000_8020_0000</code> -&gt; PA <code>0x8020_0000</code></li> <li>VA <code>0xffff_ffff_8020_0000</code> -&gt; PA <code>0x8020_0000</code></li> </ol> <p>After enabling Sv39 with the first instruction, the PC (next instruction\u2019s physical address) remains a valid virtual address. We load an immediate value into a register and use <code>jr</code> to jump to the high address.</p> <p>This process is called Relocation.</p> <p>See also: https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-6.html</p>"},{"location":"laben/xv6lab-paging/#relocation_start-code-explanation","title":"<code>relocation_start</code> Code Explanation","text":"<p>In the temporary page table for <code>relocation_start</code>, we use 2 MiB huge page mappings. We allocate four aligned physical pages:</p> <pre><code>static char relocate_pagetable[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_ident[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_direct_mapping[PGSIZE] __attribute__((aligned(PGSIZE)));\nstatic char relocate_pagetable_level1_high[PGSIZE] __attribute__((aligned(PGSIZE)));\n</code></pre> <p>We compute the kernel image\u2019s end (<code>ekernel</code>) and round it up to 2MiB, as 2 MiB huge pages require both virtual and physical addresses to be 2MiB-aligned:</p> <pre><code>// Kernel Start Point must be aligned to 2MiB\nassert(IS_ALIGNED(KERNEL_PHYS_BASE, PGSIZE_2M));\n\n// Calculate Kernel image size, and round up to 2MiB.\nuint64 kernel_size = (uint64)ekernel - (uint64)skernel;\nuint64 kernel_size_4K = ROUNDUP_2N(kernel_size, PGSIZE);\nuint64 kernel_size_2M = ROUNDUP_2N(kernel_size, PGSIZE_2M);\n\nkernel_image_end_4k = KERNEL_PHYS_BASE + kernel_size_4K;\nkernel_image_end_2M = KERNEL_PHYS_BASE + kernel_size_2M;\n\nprintf(\"Kernel size: %p, Rounded to 2MiB: %p\\n\", kernel_size, kernel_size_2M);\n</code></pre> <p>After <code>kernel_image_end_2M</code>, we allocate another 2MiB page as the first memory pool for Kernel Direct Mapping (explained later):</p> <pre><code>// Calculate Kernel Mapping Base &amp; End\nuint64 kernel_phys_base = KERNEL_PHYS_BASE;\nuint64 kernel_phys_end = kernel_phys_base + kernel_size_2M;\nuint64 kernel_virt_base = KERNEL_VIRT_BASE;\nuint64 kernel_virt_end = kernel_virt_base + kernel_size_2M;\n\n// Calculate the first Direct Mapping Base &amp; End\nuint64 kernel_la_phy_base = kernel_image_end_2M;\nuint64 kernel_la_base = KERNEL_DIRECT_MAPPING_BASE + kernel_la_phy_base;\nuint64 kernel_la_end = kernel_la_base + PGSIZE_2M;\n</code></pre> <p>We then map: VA <code>0x0000_0000_8020_0000</code> -&gt; PA <code>0x8020_0000</code>:</p> <ol> <li>Add a PTE to <code>pgt_root</code> pointing to the first-level page table <code>pgt_ident</code>.</li> <li>From <code>kernel_phys_base</code> to <code>kernel_phys_end</code>, add a PTE every 2 MiB.</li> <li>Compute the virtual address (here, <code>va = pa</code>).</li> <li>Compute <code>VPN1</code> and add the mapping to <code>pgt_ident</code>.</li> </ol> <pre><code>// We will still have some instructions executed on pc 0x8020xxxx before jumping to KIVA.\n// Step 2. Setup Identity Mapping for 0x80200000 -&gt; 0x80200000, using 2MiB huge page.\n{\n    uint64 VPN2 = PX(2, kernel_phys_base);\n    pgt_root[VPN2] = MAKE_PTE((uint64)pgt_ident, 0);\n\n    for (uint64 pa = kernel_phys_base; pa &lt; kernel_phys_end; pa += PGSIZE_2M) {\n        uint64 va = pa;\n        uint64 vpn1 = PX(1, va);\n        pgt_ident[vpn1] = MAKE_PTE(pa, PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);\n        printf(\"Mapping Identity: %p to %p\\n\", va, pa);\n    }\n}\n</code></pre> <p>Next, map the kernel ELF\u2019s virtual address: VA <code>0xffff_ffff_8020_0000</code> -&gt; PA <code>0x8020_0000</code> Now <code>va = pa + KERNEL_OFFSET</code>.</p> <p>Finally, map the first Direct Mapping block: VA <code>0xffff_ffc0_80xx_0000</code> -&gt; the first free 2 MiB physical page <code>0x80xx_0000</code>.</p>"},{"location":"laben/xv6lab-paging/#kernel-page-table","title":"Kernel Page Table","text":"<p>code: <code>os/kvm.c</code></p> <p>After relocation, the PC is at a high address, and the SP is at a high address in <code>boot_stack</code>:</p> <pre><code>Mapping Identity: 0x0000000080200000 to 0x0000000080200000\nMapping kernel image: 0xffffffff80200000 to 0x0000000080200000\nMapping Direct Mapping: 0xffffffc080400000 to 0x0000000080400000\nEnable SATP on temporary pagetable.\nBoot HART Relocated. We are at high address now! PC: 0xffffffff80203d68, SP: 0xffffffff80223ff0\n</code></pre> <p>In <code>bootcpu_relocating</code>, we call <code>kvm_init()</code> to construct the final kernel page table and switch to it.</p> <p>Building the kernel page table requires allocating physical pages for the tables, called the boot-stage page allocator. These pages are persistent and never freed. Since we\u2019ll need to access them later, we place their physical addresses in the Direct Mapping range, accessible via Direct Mapping virtual addresses. During relocation, we borrow a 2MiB region in the Direct Mapping range: <code>[0x8040_0000, 0x8060_0000)</code> after aligning <code>e_kernel</code> (0x802x_0000) to 2MiB (0x8040_0000). <pre><code>[INFO  0,-1] kvm_init: boot-stage page allocator: base 0xffffffc080400000, end 0xffffffc080600000\n</code></pre></p> <p>The <code>kvmmake</code> function calls <code>kvmmap</code> to map each region sequentially:</p> <pre><code>static pagetable_t kvmmake() {\n    pagetable_t kpgtbl;\n    kpgtbl = (pagetable_t)allocsetuppage();\n    memset(kpgtbl, 0, PGSIZE);\n\n    // Step.1 : Kernel Image\n    // Step.2 : Kernel Trampoline\n    // Step.3 : Kernel Device MMIO :\n    // Step.4 : Kernel Scheduler stack:\n    // Step.5 : Kernel Direct Mapping\n}\n</code></pre> <p><code>kvmmap</code>\u2019s prototype is <code>void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)</code>, mapping <code>[va, va+sz)</code> to <code>[pa, pa+sz)</code>.</p> <ol> <li>For the Kernel Image, we map three sections: <code>.text</code> (RX), <code>.rodata</code> (RO), <code>.data (.bss)</code> (RW). We use symbols like <code>e_text</code> from <code>kernel.ld</code> to determine start and end addresses. Referencing <code>s_text</code> directly yields its virtual address via <code>auipc</code>, convertible to physical via <code>KIVA_TO_PA</code>.</li> </ol> <p>A special page in <code>.text</code>, the trampoline, is mapped to <code>0x3f_ffff_f000</code> (covered in the next lesson):</p> <pre><code>    // map kernel text executable and read-only.\n    // 0xffff_ffff_8020_0000 -&gt; 0x8020_0000\n    kvmmap(kpgtbl, (uint64)s_text, KIVA_TO_PA(s_text), (uint64)e_text - (uint64)s_text, PTE_A | PTE_R | PTE_X);\n\n    // map kernel ro_data: s_rodata to e_rodata\n    kvmmap(kpgtbl, (uint64)s_rodata, KIVA_TO_PA(s_rodata), (uint64)e_rodata - (uint64)s_rodata, PTE_A | PTE_R);\n\n    // map kernel .s_data to .e_bss,\n    uint64 kimage_data_size = KIVA_TO_PA(e_bss) - KIVA_TO_PA(s_data);\n    kvmmap(kpgtbl, (uint64)s_data, KIVA_TO_PA(s_data), kimage_data_size, PTE_A | PTE_D | PTE_R | PTE_W);\n\n    // map trampoline\n    kvmmap(kpgtbl, (uint64)TRAMPOLINE, KIVA_TO_PA(trampoline), PGSIZE, PTE_A | PTE_R | PTE_X);\n</code></pre> <p>The <code>kernel_pagetable</code> structure looks like:</p> <pre><code>=== PageTable at 0xffffffc080400000 ===\n[ff], pte[0xffffffc0804007f8]: 0x0000003fc0000000 -&gt; 0x0000000080403000 -------V\n  [1ff], pte[0xffffffc080403ff8]: 0x0000003fffe00000 -&gt; 0x0000000080404000 -------V\n    [1ff], pte[0xffffffc080404ff8]: 0x0000003ffffff000 -&gt; 0x000000008020a000 -A--X-RV\n[1fe], pte[0xffffffc080400ff0]: 0xffffffff80000000 -&gt; 0x0000000080401000 -------V\n  [1], pte[0xffffffc080401008]: 0xffffffff80200000 -&gt; 0x0000000080402000 -------V\n    [0], pte[0xffffffc080402000]: 0xffffffff80200000 -&gt; 0x0000000080200000 -A--X-RV\n    ...\n    [9], pte[0xffffffc080402048]: 0xffffffff80209000 -&gt; 0x0000000080209000 -A--X-RV\n    [b], pte[0xffffffc080402058]: 0xffffffff8020b000 -&gt; 0x000000008020b000 -A----RV\n    ...\n    [20], pte[0xffffffc080402100]: 0xffffffff80220000 -&gt; 0x0000000080220000 -A----RV\n    [21], pte[0xffffffc080402108]: 0xffffffff80221000 -&gt; 0x0000000080221000 DA---WRV\n    ...\n    [2c], pte[0xffffffc080402160]: 0xffffffff8022c000 -&gt; 0x000000008022c000 DA---WRV\n=== END ===\n</code></pre> <ol> <li>Map MMIO regions for peripherals (PLIC and UART0):</li> </ol> <pre><code>    // Step.3 : Kernel Device MMIO :\n    kvmmap(kpgtbl, KERNEL_PLIC_BASE, PLIC_PHYS, KERNEL_PLIC_SIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n    kvmmap(kpgtbl, KERNEL_UART0_BASE, UART0_PHYS, KERNEL_UART0_SIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n</code></pre> <ol> <li>Map each CPU\u2019s scheduler stack, with each stack spanning two <code>PGSIZE</code> pages and separated by a guard page (unmapped address). Stack overflow triggers a Page Fault rather than silent errors:</li> </ol> <pre><code>    // Step.4 : Kernel Scheduler stack:\n    uint64 sched_stack = KERNEL_STACK_SCHED;\n    for (int i = 0; i &lt; NCPU; i++) {\n        struct cpu *c = getcpu(i);\n        // allocate #KERNEL_STACK_SIZE / PGSIZE pages\n        for (uint64 va = sched_stack; va &lt; sched_stack + KERNEL_STACK_SIZE; va += PGSIZE) {\n            uint64 __pa newpg = KVA_TO_PA(allockernelpage());\n            debugf(\"map halt %d, va:%p, pa:%p\", i, va, newpg);\n            kvmmap(kpgtbl, va, newpg, PGSIZE, PTE_A | PTE_D | PTE_R | PTE_W);\n        }\n        c-&gt;sched_kstack_top = sched_stack + KERNEL_STACK_SIZE;\n        // double the sched_stack to make a significant gap between different cpus.\n        //  if any kernel stack overflows, it will page fault.\n        sched_stack += 2 * KERNEL_STACK_SIZE;\n    }\n</code></pre> <p>The scheduler stack structure is:</p> <pre><code>[1ff], pte[0xffffffc080400ff8]: 0xffffffffc0000000 -&gt; 0x0000000080405000 -------V\n  [1f8], pte[0xffffffc080405fc0]: 0xffffffffff000000 -&gt; 0x0000000080408000 -------V\n    [0], pte[0xffffffc080408000]: 0xffffffffff000000 -&gt; 0x0000000080407000 DA---WRV\n    [1], pte[0xffffffc080408008]: 0xffffffffff001000 -&gt; 0x0000000080409000 DA---WRV\n    [4], pte[0xffffffc080408020]: 0xffffffffff004000 -&gt; 0x000000008040a000 DA---WRV\n    [5], pte[0xffffffc080408028]: 0xffffffffff005000 -&gt; 0x000000008040b000 DA---WRV\n    [8], pte[0xffffffc080408040]: 0xffffffffff008000 -&gt; 0x000000008040c000 DA---WRV\n    [9], pte[0xffffffc080408048]: 0xffffffffff009000 -&gt; 0x000000008040d000 DA---WRV\n    [c], pte[0xffffffc080408060]: 0xffffffffff00c000 -&gt; 0x000000008040e000 DA---WRV\n    [d], pte[0xffffffc080408068]: 0xffffffffff00d000 -&gt; 0x000000008040f000 DA---WRV\n</code></pre> <ol> <li>Map all Direct Mapping-managed pages from <code>kernel_image_end_2M</code> to the end of physical memory, starting at <code>0xffffffc0_80400000 -&gt; 0x00000000_80400000</code>. The <code>boot-stage page allocator</code> region (<code>[0x8040_0000, 0x8060_0000)</code>) is included. </li> </ol> <p>Remaining space is managed by <code>kalloc.c</code>'s <code>kpgmgr</code>, excluding the boot-stage allocator region:</p> <pre><code>    // So page allocator should starts after these used pages.\n    kpage_allocator_base = init_page_allocator;\n    kpage_allocator_size = available_mems - (init_page_allocator - init_page_allocator_base);\n</code></pre>"},{"location":"laben/xv6lab-paging/#kvmmap","title":"kvmmap","text":"<p><code>kvmmap</code> constructs Sv39\u2019s three-level page tables for <code>vaddr</code>, allocating physical pages and filling PTEs. For unallocated lower-level tables, it allocates a page from <code>allockernelpage</code> and sets the parent PTE (<code>RWX=000</code>). At the final level, it sets <code>pgtbl_level0[vpn0] = MAKE_PTE(paddr, perm)</code>.</p> <p>For 2MiB-aligned regions, it uses a 2MiB huge page if <code>IS_ALIGNED(vaddr, PGSIZE_2M) &amp;&amp; IS_ALIGNED(paddr, PGSIZE_2M) &amp;&amp; sz &gt;= PGSIZE_2M</code>:</p> <pre><code>void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm) {\n    assert(PGALIGNED(va));\n    assert(PGALIGNED(pa));\n    assert(PGALIGNED(sz));\n\n    debugf(\"va:%p, pa:%p, sz:%x\", va, pa, sz);\n\n    pagetable_t __kva pgtbl_level1, pgtbl_level0;\n    uint64 vpn2, vpn1, vpn0;\n\n    uint64 __kva vaddr     = va;\n    uint64 __kva paddr     = pa;\n    uint64 __kva vaddr_end = vaddr + sz;\n\n    while (vaddr &lt; vaddr_end) {\n        // try to add mapping: vaddr -&gt; pa\n        vpn2 = PX(2, vaddr);\n        vpn1 = PX(1, vaddr);\n        vpn0 = PX(0, vaddr);\n\n        if (!(kpgtbl[vpn2] &amp; PTE_V)) {\n            // kpgtbl[vpn2] is not a valid PTE, allocate the level 1 pagetable.\n            uint64 __kva newpg = allockernelpage();\n            memset((void *)newpg, 0, PGSIZE);\n            pgtbl_level1 = (pagetable_t)newpg;\n            kpgtbl[vpn2] = MAKE_PTE(KVA_TO_PA(newpg), 0);\n        } else {\n            pte_t pte = kpgtbl[vpn2];\n            // check validity: pte must points to next level page table.\n            if ((pte &amp; PTE_R) || (pte &amp; PTE_W) || (pte &amp; PTE_X))\n                panic(\"kvmmap: vaddr %p already mapped at level 2\", vaddr);\n            pgtbl_level1 = (pagetable_t)PA_TO_KVA(PTE2PA(kpgtbl[vpn2]));\n        }\n        if (!(pgtbl_level1[vpn1] &amp; PTE_V)) {\n            // pgtbl_level1[vpn1] is not a valid PTE.\n            //   try to allocate 2M page\n            //   , or allocate the level 1 pagetable.\n            if (IS_ALIGNED(vaddr, PGSIZE_2M) &amp;&amp; IS_ALIGNED(paddr, PGSIZE_2M) &amp;&amp; sz &gt;= PGSIZE_2M) {\n                // it's ok for a huge page.\n                pgtbl_level1[vpn1] = MAKE_PTE(paddr, perm);\n                vaddr += PGSIZE_2M;\n                paddr += PGSIZE_2M;\n                sz -= PGSIZE_2M;\n                continue;\n            }\n            uint64 __kva newpg = allockernelpage();\n            memset((void *)newpg, 0, PGSIZE);\n            pgtbl_level0       = (pagetable_t)newpg;\n            pgtbl_level1[vpn1] = MAKE_PTE(KVA_TO_PA(newpg), 0);\n        } else {\n            pte_t pte = pgtbl_level1[vpn1];\n            // check validity: pte must points to next level page table.\n            if ((pte &amp; PTE_R) || (pte &amp; PTE_W) || (pte &amp; PTE_X))\n                panic(\"kvmmap: vaddr %p already mapped at level 1\", vaddr);\n            pgtbl_level0 = (pagetable_t)PA_TO_KVA(PTE2PA(pgtbl_level1[vpn1]));\n        }\n        // check validity: pte must points to next level page table.\n        if (pgtbl_level0[vpn0] &amp; PTE_V)\n            panic(\"kvmmap: vaddr %p already mapped at level 0\", vaddr);\n        pgtbl_level0[vpn0] = MAKE_PTE(paddr, perm);\n        vaddr += PGSIZE;\n        paddr += PGSIZE;\n        sz -= PGSIZE;\n    }\n    assert(vaddr == vaddr_end);\n    assert(sz == 0);\n}\n</code></pre>"},{"location":"laben/xv6lab-paging/#kalloc-module","title":"kalloc Module","text":"<p><code>kalloc.c</code> manages Direct Mapping region physical pages after boot, with two functions:</p> <ol> <li>Physical page allocation: <code>void *__pa kallocpage()</code>, <code>void kfreepage(void *__pa pa)</code>.</li> <li>Dynamic allocation/recycling of fixed-type objects: <code>allocator_init</code>, <code>kalloc</code>, <code>kfree</code>.</li> </ol> <p>After taking over remaining physical memory (purple section in the diagram), <code>kalloc</code> allocates:</p> <ol> <li>Memory pools for each object allocator.</li> <li>Kernel stacks for each process.</li> <li>Kernel stacks for each CPU scheduler.</li> </ol> <p>Subsequently, user-space pages and page table configuration pages are managed by <code>kalloc</code>.</p>"},{"location":"laben/xv6lab-paging/#experiment-reflection-questions","title":"Experiment Reflection Questions","text":"<p>Note: These are not required for the classroom report.</p> <p>Question</p> <p>In <code>kernel.ld</code>, the virtual address for <code>_entry</code> is <code>0xffff_ffff_8020_0000</code>. <code>entry.S</code> uses this code to jump:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 code:riscv:RISCV \u2500\u2500\u2500\u2500\n\u25cf\u2192  0x80200000 &lt;skernel+0000&gt;   auipc  sp, 0xac\n    0x80200004 &lt;skernel+0004&gt;   mv     sp, sp\n    0x80200008 &lt;skernel+0008&gt;   auipc  ra, 0x2\n    0x8020000c &lt;skernel+000c&gt;   jalr   488(ra)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 source:os/entry.S+4 \u2500\u2500\u2500\u2500\n    3  _entry:\n\u2192   4      lla sp, boot_stack_top\n    5      call bootcpu_entry\n</code></pre> <p>Why, when running at <code>0x0000_0000_8020_0000</code>, can <code>lla</code> load <code>boot_stack_top</code> and <code>call bootcpu_entry</code> find the correct physical address <code>0x8020_416c</code>, instead of the invalid virtual address <code>0xffff_ffff_8020_416c</code>?</p> <p>Hint: How do we address? Recall addressing modes from computer architecture.</p> <p>Page Tables and Memory Protection</p> <p>In <code>main.c</code>\u2019s <code>bootcpu_init</code>, before <code>infof(\"start scheduler!\");</code>, insert:</p> <pre><code>static volatile uint64 number = 0xdeadbeefaabbccdd;\nprintf(\"addr  of number: %p\\n\", &amp;number);\nprintf(\"value of number: %p\\n\", number);\n*(uint64*)&amp;number = 0xdeadbeef00100073; // 00100073 is an ebreak instruction.\nprintf(\"changed value of number: %p\\n\", number);\n((void(*)())&amp;number)(); // execute a function, which address is &amp;number\npanic(\"qwq\");\n</code></pre> <p>Run <code>make run</code>. You should encounter a Kernel Panic with Code = 12. Consult the manual to understand why.</p> <p>Return to the <code>xv6lab3</code> directory, run <code>git reset --hard da5eb84e</code>, make the same changes, and run <code>make clean &amp;&amp; make run</code>. You\u2019ll get a Kernel Panic with Code = 3, indicating the <code>ebreak</code> instruction executed.</p> <p>This demonstrates memory protection via page tables at the same privilege level: it prevents unintended behavior.</p> <p>If you change <code>number</code> to <code>const static volatile</code>, you\u2019ll get a Code = 15 panic, as <code>const</code> places it in <code>.rodata</code> (mapped <code>R--</code>).</p> <p>Similarly, try modifying <code>scheduler</code>:</p> <pre><code>*(uint32*)&amp;scheduler = 0x00100073; // 00100073: ebreak\ninfof(\"start scheduler!\");\nscheduler();\n</code></pre> <p>Compare the behavior across both lab repositories.</p>"},{"location":"laben/xv6lab-scheduling/","title":"CPU Scheduling","text":""},{"location":"laben/xv6lab-scheduling/#experiment-objectives","title":"Experiment Objectives","text":"<ol> <li>Master the xv6 scheduling process</li> <li>Master the specific implementation of the Round-Robin scheduling algorithm</li> </ol> <p>xv6-lab9 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab9</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab9 xv6lab9</code> to download the xv6-lab9 code.</p> <p>Use <code>make run</code> to run the kernel for this Lab, which will start the first user process <code>init</code>, and <code>init</code> will start the Shell process <code>sh</code>. In <code>sh</code>, enter <code>schedtest</code> to run the user program and observe the results.</p> <p>In this experiment scenario, we will enable the timer interrupt. The timer interrupt will trigger at set intervals, and the timer interrupt handler will schedule the next user process. Multiple user processes will run in a Round-Robin manner, with each process executing for one time slice until completion.</p>"},{"location":"laben/xv6lab-scheduling/#timer-interrupt","title":"Timer Interrupt","text":"<p>We have already learned about timer interrupts in the Week 4 lab session.</p> <p>One thing to note is that we need to trigger a timer interrupt at regular intervals, but the <code>sbi_set_timer()</code> interface can only set one timer interrupt at a time. Therefore, we set the first timer interrupt during initialization, and in each timer interrupt handler, we set the next timer interrupt.</p> <p>The preparation for the timer interrupt includes the initialization of the timer interrupt <code>timer_init()</code> and the setting of the next timer interrupt <code>set_next_timer()</code>:</p> <pre><code>//os/timer.c\n\n/// Enable timer interrupt\nvoid timer_init() {\n    // Enable supervisor timer interrupt\n    w_sie(r_sie() | SIE_STIE);\n    set_next_timer();\n}\n\n/// Set the next timer interrupt\nvoid set_next_timer() {\n    const uint64 timebase = CPU_FREQ / TICKS_PER_SEC;\n    if (on_vf2_board) {\n        set_timer(get_cycle() + timebase);\n    } else {\n        w_stimecmp(r_time() + timebase);\n    }\n}\n</code></pre> <p>After the operating system starts, it will call <code>timer_init()</code> to enable the timer interrupt and set the first timer interrupt:</p> <pre><code>//os/main.c\n\nstatic void bootcpu_init(){\n    //......\n\n    timer_init();\n\n    //......\n\n}\n</code></pre> <p>During the execution of a user process, once a timer interrupt is triggered, it will jump to the trap handling process <code>usertrap()</code> to handle the timer interrupt.</p> <p>When handling the timer interrupt, the next timer interrupt is set, and <code>which_dev</code> is set to 1, where 1 indicates that scheduling is needed. Afterward, at the end of the trap handling function, the value of <code>which_dev</code> is checked. If it is 1, <code>yield()</code> is called to relinquish CPU resources and schedule the next process.</p> <pre><code>//os/trap.c\n\nvoid usertrap() {\n    //......\n\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        which_dev = handle_intr();\n    }\n    //......\n\n    // If it's a timer interrupt, call yield to give up CPU.\n    if (which_dev == 1)\n        yield();\n    //.......\n}\n\nstatic int handle_intr(void) {\n    uint64 cause = r_scause();\n    uint64 code  = cause &amp; SCAUSE_EXCEPTION_CODE_MASK;\n    if (code == SupervisorTimer) {\n        tracef(\"Timer interrupt!\");\n        if (cpuid() == 0) {\n            acquire(&amp;tickslock);\n            ticks++;\n            wakeup(&amp;ticks);\n            release(&amp;tickslock);\n        }\n        set_next_timer(); // Set next timer\n        return 1;\n    } else if (code == SupervisorExternal) {\n        tracef(\"External interrupt from usertrap!\");\n        plic_handle();\n        return 2;\n    } else {\n        return 0;\n    }\n}\n</code></pre>"},{"location":"laben/xv6lab-scheduling/#scheduling-algorithm-round-robin","title":"Scheduling Algorithm -- Round Robin","text":"<p>In <code>sched.c</code>, we have a queue <code>task_queue</code> that manages processes in the <code>RUNNABLE</code> state. This linked list is called the ready queue.</p> <p>In xv6, a process will be set to <code>Runnable</code> and enqueued to the tail of the ready queue via <code>add_task()</code> at the following moments: - fork  - exec -&gt; load_init_app - wakeup - yield -&gt; sched -&gt; scheduler</p> <p>When the scheduler retrieves the ready process <code>p</code> at the head of the queue via <code>fetch_task</code>, the process is removed from the ready queue, and its state is changed to <code>RUNNING</code>.</p> <p>Since we always add processes to the tail of the ready queue and select the next ready process from the head, we have implemented the Round-Robin scheduling algorithm.</p> <pre><code>//os/sched.c\nvoid scheduler() {\n    //.......\n\n    for (;;) {\n        // Interrupts may be enabled here.\n\n        p = fetch_task();\n        //......\n\n        acquire(&amp;p-&gt;lock);\n        assert(p-&gt;state == RUNNABLE);\n        debugf(\"Switch to process %d(%d)\", p-&gt;index, p-&gt;pid);\n        p-&gt;state = RUNNING;\n        c-&gt;proc  = p;\n        swtch(&amp;c-&gt;sched_context, &amp;p-&gt;context);\n\n        // When we get back here, someone must have called swtch(..., &amp;c-&gt;sched_context);\n        assert(c-&gt;proc == p);\n        assert(!intr_get());        // Scheduler should never have interrupts enabled\n        assert(holding(&amp;p-&gt;lock));  // Whoever switched to us must acquire p-&gt;lock\n        c-&gt;proc = NULL;\n\n        if (p-&gt;state == RUNNABLE) {\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n\nvoid sched() {\n    //......\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    //......\n}\n\n// Give up the CPU for one scheduling round.\nvoid yield() {\n    struct proc *p = curr_proc();\n    debugf(\"Yield: (%d)%p\", p-&gt;pid, p);\n\n    // lab9 CPU scheduling:\n    infof(\"Yield: %d\", p-&gt;pid);\n\n    acquire(&amp;p-&gt;lock);\n    p-&gt;state = RUNNABLE;\n    sched();\n    release(&amp;p-&gt;lock);\n}\n</code></pre> <p>Question</p> <p>Combining the content of this week and Week 5, summarize which functions of which processes are involved when a timer interrupt triggers a switch from one process to another.</p>"},{"location":"laben/xv6lab-sync/","title":"Mutual Exclusion &amp; Synchronization","text":"<p>synclab &amp; xv6lab8 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab8</p> <p>Use the command git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab8 synclab to download the synclab code.</p> <p>Enter the <code>sync-lab</code> folder, read the README.md (recommended to read after class), and run the example programs inside.</p> <p>For the xv6 part of the code, refer to the main repository, and use <code>git clone https://github.com/yuk1i/SUSTechOS xv6lab8</code> to download the code.</p>"},{"location":"laben/xv6lab-sync/#multiple-processes-programming","title":"Multiple Processes Programming","text":"<p>It is often said that processes have independent address spaces, while threads share an address space. This introduces the concept of shared memory: multiple threads within a process share a portion of the memory space.</p> <p>This leads to a problem: what happens when one thread is reading or writing to a memory address while another thread is also reading or writing to the same address?</p>"},{"location":"laben/xv6lab-sync/#mutual-exclusion","title":"Mutual Exclusion","text":"<p>Function Declarations</p> <p>In the following code, we will use simplified functions to represent thread creation and related operations:</p> <ul> <li> <p><code>create(func)</code>: Creates a thread that starts running from the given function <code>func</code>.</p> </li> <li> <p><code>join()</code>: Waits for all threads to exit.</p> </li> <li> <p><code>usleep()</code>: Waits for a few microseconds.</p> </li> </ul> <p>Before understanding why we need mutual exclusion, we must first grasp what a data race is.</p>"},{"location":"laben/xv6lab-sync/#counterfeit-alipay","title":"Counterfeit Alipay","text":"<p>code</p> <pre><code>#include \"thread.h\"\n\nunsigned long money = 30;\n\nvoid deduct() {\n    if (money &gt;= 1) {\n        usleep(1);\n        money -= 1;\n    }\n}\n\nvoid main() {\n    for (int i = 0; i &lt; 100; i++) create(deduct);\n    join();\n    printf(\"money = %lu\\n\", money);\n}\n</code></pre> <p>Compile and run with <code>gcc -O2 alipay.c &amp;&amp; ./a.out</code> to experience being a billionaire.</p> <pre><code>$ gcc -O2 alipay.c &amp;&amp; ./a.out\nmoney = 18446744073709551547\n</code></pre> <p>Counterfeit Alipay creates 100 threads, each checking if there is money in the wallet and deducting if there is (local ordering). <code>usleep</code> is used to force a period of waiting.</p> <p>In this problem, the wallet <code>money</code> is the shared resource. We observe that <code>money</code> suddenly becomes a very large value due to an overflow caused by subtraction on an <code>unsigned long</code>. Consider the following execution diagram, enforcing a global ordering on all white blocks:</p> <p></p> <p>In the worst case, when only 1 yuan remains in the wallet, two threads both check and see a balance of 1 yuan, so both deduct, leading to an overflow.</p> <p>Multithreading in a Mathematical Model</p> <p>Label the steps <code>money &gt;= 1 ?</code> and <code>money--</code> as A and B. A always executes before B, written as <code>A &gt; B</code> (<code>A</code> happens-before <code>B</code>).</p> <p>We find that the global ordering of multithreaded execution steps is a permutation of each thread's local ordering steps.</p> <p>The global ordering consists of four steps <code>{A1, B1, A2, B2}</code>, where any permutation satisfying the local orderings <code>A1 &gt; B1</code> and <code>A2 &gt; B2</code> is a valid global ordering. For example, <code>(A1, B1, A2, B2)</code>, <code>(A2, B2, A1, B1)</code>, and <code>(A1, A2, B1, B2)</code> are valid global orderings, with the latter being the source of the bug.</p> <p>If you're interested, try answering this question: We can mathematically verify the correctness of a multithreaded program by enumerating all global orderings and ensuring none cause bugs. From the perspective of computational complexity theory, is solving this problem a P problem, an NP problem, or an NP-complete problem?</p> <p>If we remove the <code>usleep</code> after <code>if (money &gt;= 0)</code>, the program is likely to produce the correct result. This is because the instruction sequence for checking and deducting is so short that a data race is unlikely. However, unlikely \u2260 impossible. When dealing with concurrency, we need correctness.</p> <p>In the mathematical model, <code>(A1, A2, B1, B2)</code> means both thread 1 and thread 2 observe <code>money == 1</code> and both execute <code>money--</code>. The solution is to make <code>(A, B)</code> indivisible. This can be understood from multiple perspectives:</p> <ol> <li> <p>We no longer allow <code>(A1, B1)</code> and <code>(A2, B2)</code> to interleave, i.e., we exclude <code>(A1, A2, B1, B2)</code> from the set of \"valid global orderings.\"</p> </li> <li> <p>We can package <code>(A, B)</code> as an uninterruptible whole. From the perspective of other CPUs, these two events happen instantaneously (i.e., atomically). This means other CPUs cannot observe the intermediate state of this whole.</p> </li> <li> <p>Note that the second description is essentially a Critical Section.</p> </li> </ol> <p>Takeaway Message</p> <p>Humans are single-threaded beings. In the model of multiprocessor programming, single-threaded thinking is no longer always correct; shared variables can be modified by others at any moment.</p>"},{"location":"laben/xv6lab-sync/#single-core-processor","title":"Single-Core Processor","text":"<p>If you understand the three perspectives above, the solution on a single CPU becomes clear: we prevent a context switch between <code>(A, B)</code>. This is the first method we learn for achieving mutual exclusion: disabling interrupts. This is also how the kernel implements an \"uninterruptible whole.\"</p> <p>However, disabling interrupts is not a universal solution. User mode cannot disable interrupts. (Recall: Conditions for allowing interrupts)</p>"},{"location":"laben/xv6lab-sync/#atomic-compare-and-swap-instruction","title":"Atomic Compare-And-Swap Instruction","text":"<p>For the Counterfeit Alipay example, we can understand the issue from another angle: when thread 2 checks <code>money</code> and before it performs <code>money--</code>, thread 1 has already modified <code>money</code>, making thread 2's condition for <code>money--</code> invalid.</p> <p>We can abstract this further: when attempting to modify a variable (memory address), its value is no longer the original value.</p> <p>Fortunately, modern CPUs generally provide a special instruction: when modifying a memory address's value, it checks if the address's value matches the expected original value. This is called the Compare-And-Swap (CAS) instruction. In most cases, this instruction is executed atomically, meaning it appears to complete instantaneously to other CPUs.</p> <p>We can modify the <code>deduct</code> function as follows, clearly distinguishing the shared variable <code>money</code> from its local copy <code>local_money</code>. Whenever we want to modify <code>money</code>, we use <code>__sync_bool_compare_and_swap(&amp;money, local_money, local_money - 1)</code> to update the memory address <code>&amp;money</code>, expecting its current value to match the value we read (<code>local_money</code>). If it matches, <code>&amp;money</code> is updated to the new value (<code>local_money - 1</code>) and returns <code>true</code>. If it doesn't match, it means another CPU has updated the memory, so the value is not updated, and <code>false</code> is returned. This function generates an atomic instruction <code>lock cmpxchg</code>. On RISC-V, this is an <code>amoswap</code> instruction.</p> <pre><code>// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval). \n//   -&gt; return true if the comparison is successful and newval is written.\nunsigned long money = 30;\n\nvoid deduct() {\n    long local_money;\n    do {\n        local_money = money;\n        if (local_money == 0)\n            break;\n        usleep(1);\n    } while(!__sync_bool_compare_and_swap(&amp;money, local_money, local_money - 1));\n    // will be compiled to: \n    // 124e:       f0 48 0f b1 15 f1 2d     lock cmpxchg QWORD PTR [rip+0x2df1],rdx\n}\n</code></pre> <p>GCC's documentation for <code>__sync</code> built-in atomic instructions: https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fsync-Builtins.html</p>"},{"location":"laben/xv6lab-sync/#lock-primitive","title":"Lock Primitive","text":"<p>Although we can use <code>__sync</code> atomic instructions to solve the Counterfeit Alipay example, we still need a general method to achieve mutual exclusion.</p> <p>Recall the fundamental requirement of mutual exclusion: at any given moment, only one thread can execute. We define a set of primitives: <code>lock</code>/<code>unlock</code> (also written as <code>acquire</code>/<code>release</code>):</p> <ol> <li> <p>All threads seeking mutual exclusion must call the <code>lock</code> method. At any moment, only one thread can return from the <code>lock</code> method.</p> </li> <li> <p>Once a thread successfully returns from the <code>lock</code> method, no other thread can return from <code>lock</code> until that thread calls <code>unlock</code>.</p> </li> </ol> <p>We can see that returning from <code>lock</code> marks the start of the Critical Section, and <code>unlock</code> marks its end.</p>"},{"location":"laben/xv6lab-sync/#lock-implementation","title":"Lock Implementation","text":"<p>We might naively write the following code, where <code>status</code> is a shared variable. Multiple threads call <code>lock</code> simultaneously, attempting to set <code>status</code> to <code>LOCKED</code>. Ultimately, only one thread succeeds in executing <code>status = LOCKED</code>, while others spin in the <code>retry</code> loop.</p> <pre><code>int status = UNLOCKED;\n\nvoid lock() {\nretry:\n    if (status != UNLOCKED) {\n        goto retry;\n    }\n    status = LOCKED;\n}\n\nvoid unlock() {\n    status = UNLOCKED;\n}\n</code></pre> <p>However, analyzing this with the Counterfeit Alipay example, we can easily spot a data race: after a thread passes the <code>if (status != UNLOCKED)</code> check, another thread executes <code>status = LOCKED</code>, invalidating the first thread's condition for locking.</p> <p>Thus, we should use an atomic instruction for the compare-and-set step: each thread attempts to atomically change <code>status</code> from <code>UNLOCKED</code> to <code>LOCKED</code>. The CPU ensures only one CPU succeeds. Unsuccessful CPUs continue waiting in the while loop.</p> <pre><code>void lock() {\n    while(!__sync_bool_compare_and_swap(&amp;status, UNLOCKED, LOCKED));\n}\n</code></pre> <p>Without Atomic Instructions</p> <p>This is why Peterson's algorithm seems complex. In the 1960s, when the first correct mutual exclusion algorithm (Dekker's Algorithm) was developed, CPUs lacked atomic instructions.</p>"},{"location":"laben/xv6lab-sync/#spinlock-sleeplock","title":"Spinlock &amp; Sleeplock","text":"<p>In the sections above, we defined only one fundamental property of locks: achieving mutual exclusion. Locks have another property: what should a thread do if it cannot acquire the lock?</p> <p>Locks can be divided into two categories: spinlocks and sleeplocks.</p> <p>A spinlock continuously tries to acquire the lock when it fails, as in the <code>lock</code> method above. It keeps executing <code>__sync_bool_compare_and_swap</code> on failure, causing the CPU to spin on this instruction. This lock is suitable for short critical sections that complete in a fixed time.</p> <p>A sleeplock puts the thread into a <code>SLEEPING</code> state when it cannot acquire the lock, yielding the CPU to the <code>scheduler</code>. When the lock-holding thread releases the lock, it must wake up the waiting threads. This lock is suitable for long critical sections with uncertain durations, such as waiting for I/O.</p> <p>Regarding waking up waiters, sleeplocks can be implemented in different ways:</p> <ol> <li> <p>Wake up all waiting threads; only the thread that acquires the lock continues, while others go back to sleep.</p> </li> <li> <p>Wake up only one waiting thread, leaving others asleep.</p> </li> </ol>"},{"location":"laben/xv6lab-sync/#xv6-spinlock","title":"xv6 Spinlock","text":"<p>In xv6, a <code>spinlock_t</code> structure contains the core <code>locked</code> flag and other fields for debugging.</p> <p>To <code>acquire</code> a <code>spinlock_t</code>, <code>__sync_lock_test_and_set</code> (atomic <code>amoswap</code> instruction) attempts to write 1 to <code>locked</code> and returns the previous value of <code>locked</code>. If the return value is 0, the CPU is the only one that changed <code>locked</code> from 0 to 1, meaning it acquired the lock.</p> <p>The <code>release</code> operation atomically writes 0 to <code>locked</code>.</p> <pre><code>// Mutual exclusion lock.\nstruct spinlock {\n    uint64 locked;  // Is the lock held?, use AMO instructions to access this field.\n\n    // For debugging:\n    char *name;       // Name of lock.\n    struct cpu *cpu;  // The CPU holding the lock.\n    void *where;      // Who calls acquire?\n};\n\n// Acquire the lock.\n// Loops (spins) until the lock is acquired.\nvoid acquire(spinlock_t *lk)\n{\n    uint64 ra = r_ra();\n    push_off();         // Disable interrupts to avoid deadlock.\n    if (holding(lk))    // Check against reentrance\n        panic(\"already acquired by %p, now %p\", lk-&gt;where, ra);\n\n    // On RISC-V, sync_lock_test_and_set turns into an atomic swap:\n    //   a5 = 1\n    //   s1 = &amp;lk-&gt;locked\n    //   amoswap.d.aq a5, a5, (s1)\n    while (__sync_lock_test_and_set(&amp;lk-&gt;locked, 1) != 0)\n        ;\n\n    __sync_synchronize();\n\n    // Record info about lock acquisition for holding() and debugging.\n    lk-&gt;cpu = mycpu();\n    lk-&gt;where = (void *)ra;\n}\n\n// Release the lock.\nvoid release(spinlock_t *lk)\n{\n    if (!holding(lk))\n        panic(\"release\");\n\n    lk-&gt;cpu = 0;\n    lk-&gt;where = 0;\n\n    __sync_synchronize();\n\n    // Release the lock, equivalent to lk-&gt;locked = 0.\n    // On RISC-V, sync_lock_release turns into an atomic swap:\n    //   s1 = &amp;lk-&gt;locked\n    //   amoswap.w zero, zero, (s1)\n    __sync_lock_release(&amp;lk-&gt;locked);\n\n    pop_off();\n}\n\n// Check whether this CPU is holding the lock.\n// Interrupts must be off.\nint holding(spinlock_t *lk)\n{\n    int r;\n    r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());\n    return r;\n}\n</code></pre> <p>__sync_synchronize() &amp; Memory Ordering</p> <p>We intentionally omitted details about <code>__sync_synchronize()</code>. This function relates to CPU memory ordering, and its principles are beyond the scope of an undergraduate operating systems course.</p> <p>In short, writes to memory by one core will eventually be visible to other cores. Relaxed Memory Order (RISC-V, ARM) does not guarantee that two stores by one core will be observed by other cores in the order they appear in the code.  In contrast, x86 (IA-32, amd64) platforms use Total Store Order, ensuring that the order of stores by one core is observed by others as in the code. This is one reason why Windows on ARM struggles to emulate x86 software.</p> <p>Simply put, other cores may observe the lock release before observing old values that should have been overwritten in the critical section.</p> <p>If you're interested, we recommend the following resources:</p> <ol> <li> <p>https://jyywiki.cn/OS/2025/lect13.md (13.4 Giving Up (3): Global Instruction Execution Order)</p> </li> <li> <p>riscv-spec-v2.1.pdf, Section 6.1, Specifying Ordering of Atomic Instructions</p> </li> <li> <p>https://blog.cyyself.name/memory-ordering/</p> </li> <li> <p>https://people.mpi-sws.org/~viktor/papers/asplos2023-atomig.pdf</p> </li> </ol>"},{"location":"laben/xv6lab-sync/#disabling-interrupts","title":"Disabling Interrupts","text":"<p>We use <code>push_off()</code> and <code>pop_off()</code> to represent a pair of disable/enable interrupt operations. For details, refer to the Context Switch chapter.</p>"},{"location":"laben/xv6lab-sync/#lock-checking","title":"Lock Checking","text":"<p>What happens if we try to lock a lock we already hold? We would get stuck in the spin loop forever.  Similarly, if a process holding a lock goes to sleep, other processes trying to acquire the lock will deadlock.</p> <p>This is why we check how many spinlocks the current CPU holds in <code>sched()</code>.</p> <pre><code>void sched() {\n    // ...\n\n    if (mycpu()-&gt;noff != 1)\n        panic(\"holding another locks\");\n\n    swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;sched_context);\n    // ...\n}\n</code></pre> <p>For kernel traps, we want to avoid nested interrupts.  In <code>kernel_trap</code>, we check the trap depth and panic if a nested interrupt occurs.</p> <pre><code>void kernel_trap(struct ktrapframe *ktf) {\n    mycpu()-&gt;inkernel_trap++;\n\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        if (mycpu()-&gt;inkernel_trap &gt; 1) {\n            // Should never have nested interrupt\n            print_sysregs(true);\n            print_ktrapframe(ktf);\n            panic(\"nested kerneltrap\");\n        }\n    }\n}\n</code></pre> <p>We ensure interrupts remain disabled in the <code>kernel_trap</code> context. If we attempt to enable interrupts by releasing a lock in the kernel trap context, the kernel will panic:</p> <pre><code>void pop_off(void) {\n    struct cpu* c = mycpu();\n    c-&gt;noff -= 1;\n    if (c-&gt;noff == 0 &amp;&amp; c-&gt;interrupt_on) {\n        if (c-&gt;inkernel_trap)\n            panic(\"pop_off-&gt;intr_on happens in kernel trap\");\n\n        // We will enable the interrupt, must not happen in kernel trap context.\n        intr_on();\n    }\n}\n</code></pre>"},{"location":"laben/xv6lab-sync/#mutual-exclusion-and-synchronization","title":"Mutual Exclusion and Synchronization","text":"<p>Mutual Exclusion means only one thread can execute at a given moment.</p> <p>Synchronization means events across multiple threads execute in a specific order, which we call <code>happens-before</code>.</p> <p>We can illustrate these concepts with real-world examples:</p> <ol> <li> <p>Consider a single-occupancy restroom with many people needing to use it. At any moment, only one person can be inside.</p> <p>In this problem, the \"restroom\" is the shared resource.</p> </li> <li> <p>Consider a traffic light at an intersection: one direction has a traffic light for vehicles, and perpendicular to it is a pedestrian crosswalk light. We require that before the vehicle light turns green, the perpendicular crosswalk light must already be red.</p> <p>In this problem, we define <code>crosswalk light turns green</code> happens-before <code>vehicle light turns red</code>.</p> </li> </ol> <p>Note that mutual exclusion does not necessarily imply synchronization: for example, if events A, B, and C are mutually exclusive, they cannot execute simultaneously, but this does not mean they must execute in the order A &gt; B &gt; C.</p>"},{"location":"laben/xv6lab-sync/#synchronization","title":"Synchronization","text":"<p>Synchronization means controlling the order of events: A &gt; B &gt; C, forming a controlled <code>happens-before</code> relationship.</p>"},{"location":"laben/xv6lab-sync/#understanding-synchronization","title":"Understanding Synchronization","text":"<p>Synchronization is often described in terms of waiting.</p> <p>For example, three people plan to eat together. They agree to meet at Gate 1 before heading to Baoneng City. In this scenario, the three synchronize on the event of \"meeting at Gate 1.\" Each person waits for the other two to arrive before proceeding to the next step: going to Baoneng City.</p> <p>Events are the execution of code, and ordering is the <code>happens-before</code> relationship between code segments.</p> <ul> <li>In a single-threaded program, code naturally follows a <code>happens-before</code> order.</li> <li>In a multithreaded program, events (code execution) within the same thread maintain their <code>happens-before</code> relationship, but events across different threads have no constraints.</li> </ul> <p>Synchronization re-establishes <code>happens-before</code> relationships between events (code execution) across different threads at specific points.</p> <p></p> <p>We use <code>A &gt; B</code> to denote <code>A happens-before B</code>. We can list the internal <code>happens-before</code> relationships for threads T1 and T2:</p> <ul> <li> <p>T1: <code>A &gt; B</code>, <code>B &gt; sync</code>, <code>sync &gt; C</code>, <code>C &gt; D</code></p> </li> <li> <p>T2: <code>E &gt; F</code>, <code>F &gt; sync</code>, <code>sync &gt; G</code>, <code>G &gt; H</code></p> </li> </ul> <p>Assume that both T1 and T2 wait on the sync event and continue only after the other has reached this point. In this case, we can say that T1 and T2 have completed a synchronization, and we have established a \"happens-before\" relationship between different threads: B &gt; sync &gt; G, F &gt; sync &gt; C.</p>"},{"location":"laben/xv6lab-sync/#condition-variables","title":"Condition Variables","text":"<p>Suppose we have three threads, each running functions A, B, and C in an infinite loop, and we want these functions to always execute in the order <code>A -&gt; B -&gt; C -&gt; A</code>:</p> <p></p> <p>Consider T2: when can it execute <code>B</code>? We require <code>A</code> happens-before <code>B</code>: B can only execute after event A occurs.</p> <p>We naturally derive the condition for executing <code>B</code>. Thus, the synchronization problem becomes checking if the condition is satisfied.</p> <pre><code>int last = 'C';\n\nvoid T1() {\n    while (1) {\n        while (last != 'C');    // wait for last == 'C'\n        A();\n        last = 'A';\n    }\n}\n\nvoid T2() {\n    while (1) {\n        while (last != 'A');    // wait for last == 'A'\n        B();\n        last = 'B';\n    }\n}\n\nvoid T3() {\n    while (1) {\n        while (last != 'B');    // wait for last == 'B'\n        C();\n        last = 'C';\n    }\n}\n</code></pre> <p>Next, we need to address two questions: how to properly set up the critical section, and what to do while waiting for the condition.</p> <p>The <code>last</code> state variable is clearly a shared variable, read and written by all three threads. Thus, access to it must be protected by a lock.</p> <pre><code>mutex_t mtx;\nint last = 'C';\n\nvoid T1() {\n    while (1) {\n        lock(&amp;mtx);\n        while (last != 'C');    // Wait for last == 'C'\n        A();\n        last = 'A';\n        unlock(&amp;mtx);\n    }\n}\n</code></pre> <p>In the <code>while</code> waiting loop, we cannot hold the mutex <code>mtx</code> continuously, as other threads need to modify the <code>last</code> state variable. Thus, if the condition is not met after checking, we release the lock, put the thread to sleep, and reacquire the lock upon waking.  Therefore, after modifying the condition, we must wake up all threads to recheck the condition.</p> <p>This design satisfies two requirements:</p> <ol> <li>When checking the synchronization condition <code>last</code>, the current thread holds the lock.</li> <li>After the synchronization condition is met, the current thread holds the lock (i.e., during the execution of <code>A</code>).</li> </ol> <pre><code>mutex_t mtx;\nint last = 'C';\n\nvoid T1() {\n    while (1) {\n        lock(&amp;mtx);\n        while (last != 'C') {\n            unlock(&amp;mtx);\n            sleep(myself);\n            lock(&amp;mtx);\n        }\n        A();\n        last = 'A';\n        unlock(&amp;mtx);\n        wakeup(all);\n    }\n}\n</code></pre> <p>However, there is an issue. Consider the following execution diagram, where yellow sections are critical sections that cannot overlap with other threads' critical sections.</p> <p></p> <p>In some cases, after T1 calls <code>unlock</code>, it does not immediately go to <code>sleep</code>. Instead, T2 acquires the lock and calls <code>wakeup</code> first, while T1 has not yet gone to sleep, so it is not woken up. After T1 goes to sleep, no thread can wake it, causing all threads to enter sleep mode.</p> <p>We call this issue the Lost Wake-Up Problem.</p> <p>The root cause is that we unlock <code>mtx</code> before marking ourselves as <code>SLEEPING</code>. However, we cannot call <code>sleep()</code> before <code>unlock()</code>, as <code>sleep</code> does not return until woken, meaning <code>unlock()</code> would never execute.</p> <p>Thus, we need to treat \"marking ourselves as SLEEPING\" and \"unlocking mtx\" as a single unit, i.e., include \"marking as SLEEPING\" in the critical section.</p> <p>This explains why xv6's <code>sleep</code> method takes a <code>spinlock_t*</code> parameter.</p> <p>Note: In xv6, accessing <code>p-&gt;state</code> requires holding <code>p-&gt;lock</code>, so \"marking ourselves as SLEEPING\" (or others observing us as SLEEPING) is equivalent to <code>acquire(&amp;p-&gt;lock)</code>.</p> <pre><code>void sleep(void *chan, spinlock_t *lk) {\n    struct proc *p = curr_proc();\n\n    // Must acquire p-&gt;lock in order to\n    // change p-&gt;state and then call sched.\n    // Once we hold p-&gt;lock, we can be\n    // guaranteed that we won't miss any wakeup\n    // (wakeup locks p-&gt;lock),\n    // so it's okay to release lk.\n\n    acquire(&amp;p-&gt;lock);  // DOC: sleeplock1\n    release(lk);\n\n    // Go to sleep.\n    p-&gt;sleep_chan = chan;\n    p-&gt;state      = SLEEPING;\n\n    sched();\n\n    // p get waking up, Tidy up.\n    p-&gt;sleep_chan = 0;\n\n    // Reacquire original lock.\n    release(&amp;p-&gt;lock);\n    acquire(lk);\n}\n</code></pre> <p></p> <p>Why Not Use Atomic Instructions for Condition Checking?</p> <p>Because real-world conditions may not be simple enough to express with a single atomic instruction, we prefer using mutexes (more general) to protect condition access.</p>"},{"location":"laben/xv6lab-sync/#lab-exercises","title":"Lab Exercises","text":"<ol> <li> <p>Suppose <code>sum</code> is a shared variable, and three threads concurrently execute the <code>T_sum</code> function. What is the minimum possible value of <code>sum</code> after all threads exit?</p> <p>Hint: To prove a value is the minimum: 1. Show that all smaller values are impossible. 2. Demonstrate a valid concurrent execution order that produces this minimum value.</p> <p>Using our \"mathematical model\": each thread has 6 parts: (Load, Store, Load, Store, Load, Store). There are three such threads, and they are arranged in a sequence. The last Store operation determines the value of sum after all three threads have finished.</p> <pre><code>int sum = 0;\nvoid T_sum() {\n    for (int i = 0; i &lt; 3; i++) {\n        int t = load(sum);\n        t += 1;\n        store(sum, t);\n    }\n}\n\nint main() {\n    for (int i = 0; i &lt; 3; i++) create(T_sum);\n    join();\n    printf(\"sum = %d\\n\", sum);\n}\n</code></pre> </li> <li> <p>Use GCC's built-in atomic CAS function <code>__sync_bool_compare_and_swap</code> to solve the multithreaded increment problem.</p> <pre><code>volatile int sum = 0;\n\nvoid T_sum() {\n    for(int i=0;i &lt; 10000; i++) {\n        // your code here: increase sum atomically.\n\n    }\n}\n\nint main() {\n    for (int i=0;i&lt;5;i++) create(T_sum);\n    join();\n    printf(\"sum = %d\\n\", sum);\n}\n</code></pre> <p>GCC documentation: https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/_005f_005fsync-Builtins.html</p> </li> <li> <p>In the \"Condition Variables\" section, can T2's <code>wakeup</code> be moved outside the critical section of <code>lk</code>? That is, can T2 call <code>release(lk)</code> before <code>wakeup()</code>?</p> </li> </ol>"},{"location":"laben/xv6lab-sync2/","title":"Week 12 - Synchronization 2","text":""},{"location":"laben/xv6lab-sync2/#synchronization-2","title":"Synchronization 2","text":""},{"location":"laben/xv6lab-sync2/#experiment-objectives","title":"Experiment Objectives","text":"<ol> <li>Understand the principle of semaphores</li> <li>Understand the producer-consumer model</li> </ol>"},{"location":"laben/xv6lab-sync2/#data-race","title":"Data Race","text":"<p>In the course content of Synchronization 1, we did not provide a precise definition of data race. Let's define it now:</p> <p>Two (or more) memory operations conflict if they access the same location and at least one of them is a write operation.</p> <p>If multiple memory accesses target the same address and at least one of them is a write, we call this situation a data race.</p> <p>If we prevent writes, can we read concurrently?</p> <p>This is the design principle of <code>rwlock</code>. We categorize access to shared resources (memory) into read and write operations. The <code>lock</code> operation is divided into <code>rdlock</code> and <code>wrlock</code>.</p> <p>At any given moment, multiple readers can read concurrently (returning from <code>rdlock</code> simultaneously), or there can be only one writer. A single writer is mutually exclusive with all readers and other writers.</p> <p>If a data race has no side effects</p> <p>If we allow data races but ensure they do not cause bugs, we can avoid using locks.</p> <p>In computer science, read-copy-update (RCU) is a synchronization mechanism that avoids the use of lock primitives while multiple threads concurrently read and update elements that are linked through pointers and that belong to shared data structures (e.g., linked lists, trees, hash tables).</p> <p>Whenever a thread is inserting or deleting elements of data structures in shared memory, all readers are guaranteed to see and traverse either the older or the new structure, therefore avoiding inconsistencies (e.g., dereferencing null pointers).</p> <p>See also: https://www.kernel.org/doc/html/next/RCU/whatisRCU.html</p>"},{"location":"laben/xv6lab-sync2/#semaphore","title":"Semaphore","text":"<p>A semaphore is a mutex with a counter.</p> <p>We can understand a semaphore as a \"finite number of shared resources,\" such as lockers in a swimming facility or parking spaces in a parking lot.</p> <p>A swimming facility has a limited number of wristbands. Upon entering, each person receives a wristband (holding the semaphore); only those with wristbands can enter (mutual exclusion). When all lockers are occupied, no wristbands can be issued, so newcomers must wait (blocking). People leaving the facility return their wristbands (release).</p> <p>We can observe that a mutex is a special case of a semaphore where N = 1.</p> <p>Semaphores have two primary operations: acquire and release. When a semaphore has available resources, acquiring it results in holding the semaphore until it is released. When no resources are available, acquiring it results in waiting until a resource is released, at which point the semaphore is held.</p> <p>We define a set of primitives: <code>sem_acquire()</code>/<code>sem_release()</code> (also written as <code>P()</code>/<code>V()</code>, <code>wait()</code>/<code>post()</code>, or <code>decrease()</code>/<code>increase()</code>):</p> <ol> <li>A semaphore has an initial value.</li> <li>During <code>acquire</code>, the semaphore\u2019s value decreases by 1; during <code>release</code>, it increases by 1.</li> <li>The semaphore\u2019s value never drops below 0. If the value is 0, <code>acquire</code> will block and wait; another <code>release</code> will wake it and allow it to attempt <code>acquire</code>.</li> </ol> <p>sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns immediately. If the semaphore currently has the value zero, then the call blocks until it becomes possible to perform the decrement (i.e., the semaphore value rises above zero).</p> <p>sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore.</p> <p>An additional property: <code>acquire</code> (<code>wait</code>) may cause waiting (blocking), while <code>release</code> (<code>post</code>) never causes waiting (blocking).</p> <p>In the final assignment, we will implement semaphores on xv6 and solve the dining philosophers problem.</p>"},{"location":"laben/xv6lab-sync2/#producer-consumer-model","title":"Producer-Consumer Model","text":"<p>The Producer-Consumer model is a very common model in synchronization and concurrent programming.</p> <p>Producers generate data or tasks, while consumers process them. The two are separated by a buffer or queue, ensuring they do not block each other. Producers and consumers only need mutual exclusion when accessing the buffer to protect its integrity.</p> <p>We can write the synchronization conditions for Producer and Consumer:</p> <ul> <li> <p>Producer (produces data): If the buffer has space, insert data; otherwise, wait (block).</p> </li> <li> <p>Consumer (consumes data): If the buffer has data, remove it; otherwise, wait (block).</p> </li> </ul> <p>Between Producer and Consumer, we achieve synchronization: the production of an object must happen-before its consumption.</p> <p>Typically, the buffer is a fixed-size array (no expansion after creation), such as a Ring Buffer.</p>"},{"location":"laben/xv6lab-sync2/#condition-variables","title":"Condition Variables","text":"<p>With synchronization conditions, we can use condition variables from the previous lesson to achieve synchronization: the synchronized object (chan) is <code>&amp;buf</code>, protected by the spinlock <code>&amp;buf.lock</code>. After inserting or removing data from the buffer, we use <code>wakeup</code> to notify all threads sleeping on that object.</p> <pre><code>struct buffer {\n    spinlock_t lock;\n    // ...\n} buf;\n\nbool is_full(struct buffer* b);\nbool is_empty(struct buffer* b);\nvoid put_data(struct buffer* b, void* data);\nvoid* get_data(struct buffer* b);\n\nvoid produce(void* data) {\n    acquire(&amp;buf.lock);\n    while(is_full(&amp;buf))\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_full(&amp;buf));\n    put_data(&amp;buf, data);   // modify the buffer, guarded by buf.lock and cond: !full\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n}\n\nvoid* consume(void* data) {\n    acquire(&amp;buf.lock);\n    while(is_empty(&amp;buf))\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_empty(&amp;buf));\n    void* data = get_data(&amp;buf);    // modify the buffer, guarded by buf.lock and cond: !empty\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n\n    return data;\n}\n</code></pre> <p>For a specific implementation, refer to the <code>sync_main.c</code> file in xv6lab10. You can try commenting out the condition checks in <code>producer</code> and <code>consumer</code> to observe whether they pass the checks.</p> <pre><code>        while (is_empty(&amp;buf)) sleep(&amp;buf, &amp;buf.lock);\n        assert(!is_empty(&amp;buf));\n</code></pre>"},{"location":"laben/xv6lab-sync2/#semaphore_1","title":"Semaphore","text":"<p>We can also use semaphores to implement the producer-consumer model:</p> <ol> <li> <p>Producers and Consumers need to wait on two events: buffer empty or full. Thus, we create two semaphores, <code>avail</code> and <code>empty</code>, representing the current number of elements in the buffer and the number of empty slots, with initial values of <code>0</code> and <code>N</code>, respectively.</p> </li> <li> <p>In <code>produce</code>, <code>wait(empty)</code> decreases the number of empty slots (<code>empty</code> --), waiting for an empty slot. After obtaining a slot, <code>produce</code> adds an object to the buffer, then <code>post(avail)</code> increases the number of elements (<code>avail</code> ++).</p> </li> <li> <p>Conversely, in <code>consume</code>, <code>wait(avail)</code> decreases the number of elements (<code>avail</code> --), waiting for an element, and <code>post(empty)</code> increases the number of empty slots (<code>empty</code> ++).</p> </li> <li> <p>Finally, we need mutual exclusion when accessing the buffer, so we use a <code>mutex</code> semaphore with an initial value of 1.</p> </li> </ol> <pre><code>struct buffer {\n    sem_t mutex;\n    sem_t avail;\n    sem_t empty;\n    // ...\n} buf;\nvoid put_data(struct buffer* b, void* data);\nvoid* get_data(struct buffer* b);\n\nvoid produce(void* data) {\n    wait(&amp;buf.empty);   // empty space --\n\n    wait(&amp;buf.mutex);\n    put_data(&amp;buf, data);   // critical section for buf.\n    post(&amp;buf.mutex);\n\n    post(&amp;buf.avail);   // avail ++\n}\n\nvoid* consume(void* data) {\n    wait(&amp;buf.avail);   // avail --\n\n    wait(&amp;buf.mutex);\n    void* data = get_data(&amp;buf);    // critical section for buf.\n    post(&amp;buf.mutex);\n\n    post(&amp;buf.empty);   // empty space ++\n\n    return data;\n}\n</code></pre>"},{"location":"laben/xv6lab-sync2/#invariant","title":"Invariant","text":"<p>What is an invariant? An invariant is an assertion that must hold at any point during program execution.</p> <p>You may have learned about loop invariants in a mathematical logic course, which are conditions that always hold in a loop and can be used to prove properties of the loop.</p> <p>In concurrent programming, some complex synchronization problems involve relationships between multiple shared variables. An invariant is the logical relationship between these variables. For example, if we use two <code>int</code> variables, <code>avail</code> and <code>empty</code>, to represent the number of objects and empty slots in a fixed-length Ring Buffer, the invariant is <code>avail + empty == N</code>.</p> <p>If we need to temporarily break an invariant, we protect it with a Critical Section, ensuring other CPUs cannot observe the invariant being broken. As mentioned in previous lessons:</p> <p>We can package <code>(A, B)</code> into an uninterruptible whole. From the perspective of other CPUs, these two events occur instantaneously (i.e., atomically). Other CPUs cannot observe the intermediate state of this whole.</p> <p>Typically, in a Critical Section, we access or modify multiple shared variables, but outside the Critical Section, they consistently satisfy a certain relationship.</p>"},{"location":"laben/xv6lab-sync2/#linux-pthread-api","title":"Linux pthread API","text":"<p>The pthread (POSIX thread) library is a multithreading library for Linux. It provides the following groups of APIs:</p> <ol> <li> <p>Thread creation: <code>pthread_create</code>, thread joining: <code>pthread_join</code>.</p> </li> <li> <p>Mutex (a type of sleeplock): <code>pthread_mutex_t</code></p> </li> </ol> <pre><code>// man pthread_mutex_init\n\n#include &lt;pthread.h&gt;\n\npthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;\n\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n</code></pre> <p>DESCRIPTION    A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.</p> <p>A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread). A mutex can never be owned by two different threads simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.</p> <ol> <li>Condition variables: <code>pthread_cond_t</code></li> </ol> <pre><code>// man pthread_cond_init\n\n#include &lt;pthread.h&gt;\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nint pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\n\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);\n</code></pre> <p>A condition (short for ``condition variable'') is a synchronization device that allows threads to suspend execution and relinquish the processors until some predicate on shared data is satisfied. The basic operations on conditions are: signal the condition (when the predicate becomes true), and wait for the condition, suspending the thread execution until another thread signals the condition.</p> <p>A condition variable must always be associated with a mutex, to avoid the race condition where a thread prepares to wait on a condition variable and another thread signals the condition just before the first thread actually waits on it.</p> <p>pthread_cond_init initializes the condition variable cond, using the condition attributes specified in cond_attr, or default attributes if cond_attr is NULL. Variables of type pthread_cond_t can also be initialized statically, using the constant PTHREAD_COND_INITIALIZER.</p> <p>pthread_cond_signal restarts one of the threads that are waiting on the condition variable cond. If no threads are waiting on cond, nothing happens. If several threads are waiting on cond, exactly one is restarted, but it is not specified which.</p> <p>pthread_cond_broadcast restarts all the threads that are waiting on the condition variable cond. Nothing happens if no threads are waiting on cond.</p> <p>pthread_cond_wait atomically unlocks the mutex (as per pthread_unlock_mutex) and waits for the condition variable cond to be signaled. The thread execution is suspended and does not consume any CPU time until the condition variable is signaled. The mutex must be locked by the calling thread on entrance to pthread_cond_wait. Before returning to the calling thread, pthread_cond_wait re acquire mutex (as per pthread_lock_mutex).</p> <p>Unlocking the mutex and suspending on the condition variable is done atomically. Thus, if all threads always acquire the mutex before signaling the condition, this guarantees that the condition cannot be signaled (and thus ignored) between the time a thread locks the mutex and the time it waits on the condition variable.</p> <ol> <li>Semaphore</li> </ol> <pre><code>#include &lt;semaphore.h&gt;\n\n// man sem_init\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n\n// man sem_post\nint sem_post(sem_t *sem);\n\n// man sem_wait\nint sem_wait(sem_t *sem);\nint sem_trywait(sem_t *sem);\nint sem_timedwait(sem_t *restrict sem, const struct timespec *restrict abs_timeout);\n</code></pre>"},{"location":"laben/xv6lab-sync2/#lab-exercises","title":"Lab Exercises","text":"<ol> <li> <p>Suppose there are two types of threads, each with multiple instances: the first type continuously prints left parentheses <code>(</code>, and the second type continuously prints right parentheses <code>)</code>. The requirement is that at any moment, the printed string is a balanced parenthesis string or its prefix, such as <code>()(())</code> or <code>(((</code>. The maximum nesting level of parentheses is limited to N.</p> <p>For example:</p> <ul> <li> <p><code>()((()))</code> is a valid balanced parenthesis string with a maximum nesting depth of 3.</p> </li> <li> <p><code>())</code> is not a valid balanced parenthesis string.</p> </li> <li> <p><code>(((</code> is a prefix of <code>((()))</code> with a nesting depth of 2.</p> </li> </ul> <p>Given a variable <code>count</code> representing the number of left parentheses exceeding right parentheses, write the synchronization conditions for these two types of threads. That is, when can each type of thread print <code>(</code> or <code>)</code>?</p> </li> <li> <p>In the producer-consumer model implemented with condition variables, can the <code>while() sleep</code> loop in the <code>produce</code> method be replaced with an <code>if() sleep</code>?</p> <pre><code>void produce(void* data) {\n    acquire(&amp;buf.lock);\n    if (is_full(&amp;buf))       // change while to if\n        sleep(&amp;buf, &amp;buf.lock);\n\n    assert(!is_full(&amp;buf));\n    put_data(&amp;buf, data);   // modify the buffer, guarded by buf.lock and cond: !full\n\n    wakeup(&amp;buf);\n    release(&amp;buf.lock);\n}\n</code></pre> </li> <li> <p>Use the Linux command <code>man xxx</code> to read the manpages for <code>pthread_cond_signal</code> and <code>pthread_cond_broadcast</code>, and briefly describe the difference between them.</p> <p>Also, answer: In the implementation of the producer-consumer model, how many condition variables (<code>pthread_cond_t</code>) should we use? And when notifying a condition change (equivalent to <code>wakeup</code> in xv6), should we use <code>pthread_cond_signal</code> or <code>pthread_cond_broadcast</code>?</p> </li> </ol>"},{"location":"laben/xv6lab-userprocess/","title":"User Process","text":""},{"location":"laben/xv6lab-userprocess/#lab-objectives","title":"Lab Objectives","text":"<ol> <li>Understand user address space</li> <li>Master the implementation principles of fork\\exec\\exit\\wait</li> </ol> <p>xv6-lab6 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab6</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab6 xv6lab6</code> to download the xv6-lab6 code.</p> <p>Use <code>make run</code> to run the kernel for this Lab, which will start the first user process <code>init</code>, and <code>init</code> will start the Shell process <code>sh</code>.</p> <p>You will see the user space structure of the <code>sh</code> process.</p> <pre><code>init: starting sh\n[INFO  0,2] exec: exec-ed sh, mm structure:\nmm 0xfffffffd000fff48:\npgt: 0xffffffc080d25000\nref: 1\nvma: 0xfffffffd010bfd38\n    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n=== PageTable at 0xffffffc080d25000 ===\n...\n</code></pre> <p>Note: The initialization code for <code>struct mm</code> in this Lab has been modified compared to the previous Lab code.</p>"},{"location":"laben/xv6lab-userprocess/#address-space","title":"Address Space","text":"<p>First, let's review how the address space in U-mode is described from the perspective of the kernel and CPU.</p> <p>For the CPU, all memory accesses in U-mode, including instruction fetch (IF), memory read (LD), and memory write (ST), must go through page table address translation. The CPU uses the CSR <code>satp</code> as the base address of the page table for address translation.</p> <p>Therefore, the kernel needs to set up a page table structure for user processes. In the kernel, we use <code>struct mm</code> to manage user memory, and each PCB <code>struct proc</code> has a pointer <code>*mm</code> pointing to <code>struct mm</code>.</p> <pre><code>// os/vm.h\nstruct mm {\n    spinlock_t lock;\n\n    pagetable_t __kva pgt;\n    struct vma* vma;\n};\n</code></pre> <p>Each <code>struct mm</code> contains a page table <code>pgt</code>, which is the <code>satp</code> used by the user process. We can observe this in <code>usertrapret</code> and trampoline:</p> <pre><code>// os/trap.c\nvoid usertrapret() {\n    // ...\n\n    // tell trampoline.S the user page table to switch to.\n    uint64 satp  = MAKE_SATP(KVA_TO_PA(curr_proc()-&gt;mm-&gt;pgt));      // &lt;--\n    uint64 stvec = (TRAMPOLINE + (uservec - trampoline)) &amp; ~0x3;\n\n    // jump to userret in trampoline.S at the top of memory, which\n    // switches to the user page table, restores user registers,\n    // and switches to user mode with sret.\n    uint64 fn = TRAMPOLINE + (userret - trampoline);\n    ((void (*)(uint64, uint64, uint64))fn)(TRAPFRAME, satp, stvec);\n}\n\n// os/trampoline.S\n.globl userret\nuserret:\n        # userret(TRAPFRAME, pagetable, stvec)\n        # switch from kernel to user.\n        # usertrapret() calls here.\n        # a0: TRAPFRAME, in user page table.\n        # a1: user page table, for satp.\n        # a2: uservec\n\n        # switch to the user page table.\n        csrw satp, a1\n        sfence.vma zero, zero\n</code></pre> <p>From the kernel's perspective, the user's memory space consists of several contiguous virtual address regions. Each contiguous region is represented by a <code>struct vma</code> (Virtual Memory Area), and they are linked together in a list. Each <code>vma</code> contains the start and end addresses of the region (aligned to page boundaries) and the permissions for the region.</p> <pre><code>// os/vm.h\nstruct vma {\n    struct mm* owner;\n    struct vma* next;   // linked list   \n    uint64 vm_start;    // start address (user virtual address)\n    uint64 vm_end;      // end address   (user virtual address)\n    uint64 pte_flags;   // flags\n};\n</code></pre> <p>Note that <code>struct vma</code> contains a <code>struct mm*</code> pointer, indicating that each VMA belongs to a <code>struct mm</code>.</p>"},{"location":"laben/xv6lab-userprocess/#loading","title":"Loading","text":"<p>A user program specifies which contiguous regions (also called segments) it needs to load during loading.  The following is the output of <code>llvm-readelf-19 -a user/build/sh</code>, showing that the <code>sh</code> program requires three contiguous regions when loading (LOAD):</p> <pre><code>Elf file type is EXEC (Executable file)\nEntry point 0x402000\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x00c3dc 0x0000000000000000 0x0000000000000000 0x000061 0x000000 R   0x1\n  LOAD           0x001000 0x0000000000402000 0x0000000000402000 0x0011f4 0x0011f4 R E 0x1000\n  LOAD           0x003000 0x0000000000404000 0x0000000000404000 0x0000cd 0x0000cd R   0x1000\n  LOAD           0x004000 0x0000000000405000 0x0000000000405000 0x000020 0x0007d0 RW  0x1000\n</code></pre> <p>We can use the <code>mm_print</code> function in the <code>exec</code> function in <code>os/proc.c</code> to print the <code>struct mm</code> structure and <code>pgt</code> page table of the process after <code>sh</code> is loaded.</p> <pre><code>mm 0xfffffffd000fff88:\n  pgt: 0xffffffc080b14000\n  ref: 1\n  vma: 0xfffffffd010bfe28\n    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n=== PageTable at 0xffffffc080b14000 ===\n[0], pte[0xffffffc080b14000]: 0x0000000000000000 -&gt; 0x0000000080b22000 -------V\n  [2], pte[0xffffffc080b22010]: 0x0000000000400000 -&gt; 0x0000000080b23000 -------V\n    [2], pte[0xffffffc080b23010]: 0x0000000000402000 -&gt; 0x0000000080b21000 ---UX-RV\n    [3], pte[0xffffffc080b23018]: 0x0000000000403000 -&gt; 0x0000000080b20000 ---UX-RV\n    [4], pte[0xffffffc080b23020]: 0x0000000000404000 -&gt; 0x0000000080b1f000 ---U--RV\n    [5], pte[0xffffffc080b23028]: 0x0000000000405000 -&gt; 0x0000000080b1e000 ---U-WRV\n[3], pte[0xffffffc080b14018]: 0x00000000c0000000 -&gt; 0x0000000080b18000 -------V\n  [1ff], pte[0xffffffc080b18ff8]: 0x00000000ffe00000 -&gt; 0x0000000080b19000 -------V\n    [1e8], pte[0xffffffc080b19f40]: 0x00000000fffe8000 -&gt; 0x0000000080b1d000 ---U-WRV\n    [1e9], pte[0xffffffc080b19f48]: 0x00000000fffe9000 -&gt; 0x0000000080b1c000 ---U-WRV\n    [1ea], pte[0xffffffc080b19f50]: 0x00000000fffea000 -&gt; 0x0000000080b1b000 ---U-WRV\n    [1eb], pte[0xffffffc080b19f58]: 0x00000000fffeb000 -&gt; 0x0000000080b1a000 ---U-WRV\n    [1ec], pte[0xffffffc080b19f60]: 0x00000000fffec000 -&gt; 0x0000000080b24000 ---U-WRV\n    [1ed], pte[0xffffffc080b19f68]: 0x00000000fffed000 -&gt; 0x0000000080b25000 ---U-WRV\n    [1ee], pte[0xffffffc080b19f70]: 0x00000000fffee000 -&gt; 0x0000000080b26000 ---U-WRV\n    [1ef], pte[0xffffffc080b19f78]: 0x00000000fffef000 -&gt; 0x0000000080b27000 ---U-WRV\n[ff], pte[0xffffffc080b147f8]: 0x0000003fc0000000 -&gt; 0x0000000080b15000 -------V\n  [1ff], pte[0xffffffc080b15ff8]: 0x0000003fffe00000 -&gt; 0x0000000080b16000 -------V\n    [1fe], pte[0xffffffc080b16ff0]: 0x0000003fffffe000 -&gt; 0x0000000080b17000 DA---WRV\n    [1ff], pte[0xffffffc080b16ff8]: 0x0000003ffffff000 -&gt; 0x000000008020b000 -A--X-RV\n=== END === \n</code></pre> <p>We can observe that in the vma linked list, three regions correspond to the LOAD segments in the ELF file, which are the <code>.text</code>, <code>.rodata</code>, and <code>.data/.bss</code> segments. <pre><code>    [0x0000000000402000, 0x0000000000404000), flags: ---UX-R-\n    [0x0000000000404000, 0x0000000000405000), flags: ---U--R-\n    [0x0000000000405000, 0x0000000000406000), flags: ---U-WR-\n</code></pre></p> <p>Another address starting with <code>0xfffe</code> is the stack area of the process. <pre><code>    [0x00000000fffe8000, 0x00000000ffff0000), flags: ---U-WR-\n</code></pre></p> <p>Additionally, there is a region of size 0, which follows all LOAD segments. This is the heap area (Heap, known as <code>Program Break</code> in ancient operating systems). The process needs to use the <code>sbrk</code> system call to expand or shrink the heap area.</p> <pre><code>    [0x0000000000406000, 0x0000000000406000), flags: ---U-WR-\n</code></pre>"},{"location":"laben/xv6lab-userprocess/#overview-diagram","title":"Overview Diagram","text":"<p>This diagram shows the data structures used by the kernel to manage the user address space of the <code>sh</code> process.</p> <p></p>"},{"location":"laben/xv6lab-userprocess/#fork","title":"fork","text":"<p>The fork system call is used in the operating system to create a new process. When a process calls fork, it creates a new process (called the child process) that is almost identical to the parent process. The child process copies the parent process's address space and all register values. The only difference is the return value of the fork call:</p> <ul> <li> <p>Parent process: fork returns the PID (process ID) of the child process.</p> </li> <li> <p>Child process: fork returns 0.</p> </li> </ul> <p>The implementation of <code>fork</code> in xv6 is located in the <code>fork</code> function in <code>os/proc.c</code>. Here is a simplified version:</p> <pre><code>int fork() {\n    int ret;\n    struct proc *np = allocproc();  // child process\n    struct proc *p = curr_proc();   // parent process\n\n    // create a new struct mm for child process\n    np-&gt;mm = mm_create(np-&gt;trapframe);\n\n    // Copy user memory from parent to child.\n    mm_copy(p-&gt;mm, np-&gt;mm);\n\n    // copy saved user registers.\n    *(np-&gt;trapframe) = *(p-&gt;trapframe);\n\n    // Cause fork to return 0 in the child.\n    np-&gt;trapframe-&gt;a0 = 0;\n    np-&gt;parent        = p;\n\n    // add the child process to scheduler\n    np-&gt;state         = RUNNABLE;\n    add_task(np);\n\n    return np-&gt;pid; // return value for the parent process\n}\n</code></pre> <p>The caller of <code>fork</code> is the parent process, and the new PCB allocated with <code>allocproc</code> is the child process. We modify the trapframe of <code>np</code> to ensure that the two processes have different return values. Note that we do not modify the trapframe of <code>p</code> because the <code>syscall</code> function will write the return value of the <code>fork</code> function into the <code>a0</code> register in the trapframe when dispatching the system call. We only need to make <code>fork</code> return the PID of the child process.</p> <p>The <code>mm_copy</code> function (located in <code>os/vm.c</code>) ultimately implements the copying of all <code>vma</code>s: it creates new <code>struct vma</code>s under the new <code>mm</code>, assigns the attributes in <code>vma</code>, calls <code>mm_mappages</code> to map the <code>vma</code>, and finally copies the actual memory data.</p> <p>Trapframe and Trampoline</p> <p>In the overview diagram, we can see that the user page table includes Trapframe and Trampoline, but the <code>vma</code> linked list does not include these two pages. This design is intentional, not a bug.</p> <p>Consider the lifecycle of <code>vma</code> (user's Virtual Memory Area). The <code>exec</code> system call will delete all existing user memory mappings and replace them with new ones, but the PCB (i.e., <code>struct proc</code>) object does not need to be destroyed and recreated, and the Trapframe does not seem to require reallocation of physical pages.</p> <p>Therefore, the lifecycle of Trapframe and Trampoline is actually consistent with the process itself, not with any <code>vma</code> entry.</p> <p>In implementation, we allocate the Trapframe page during system initialization, i.e., in <code>proc_init</code>, and map Trampoline and Trapframe in <code>create_mm</code>.</p>"},{"location":"laben/xv6lab-userprocess/#exec","title":"exec","text":"<p>The exec system call is used to execute a new program and replace the current process's memory space with the new program. Unlike fork, exec does not create a new process but replaces the current process's code, data, and stack with a new program.</p> <p>When exec is called, the current process's address space is replaced by the new program's code and data. The original process's code, data, and stack are cleared, and the new program is loaded. Then, the current process's execution flow jumps to the new program's entry point and continues executing the new program's code.</p> <pre><code>int exec(char *name, char *args[]) {\n    struct user_app *app = get_elf(name);\n\n    struct proc *p = curr_proc();\n\n    // execve does NOT preserve memory mappings:\n    //  free VMAs including program_brk, and ustack\n    // load_user_elf() will create a new mm for the new process and free the old one\n    //  , if page allocations all succeed.\n    // Otherwise, we will return to the old process.\n    // However, keep the phys page of trapframe, because it belongs to struct proc.\n    load_user_elf(app, p, args);\n\n    // syscall() will overwrite trapframe-&gt;a0 to the return value.\n    return p-&gt;trapframe-&gt;a0;\n}\n</code></pre> <p>The <code>load_user_elf</code> function has been modified compared to the previous Lab. We need to note that allocating physical pages may fail. When the system does not have enough memory, the <code>exec</code> function fails to execute, and we need to return to the original process to continue execution, releasing the half-allocated memory.(Avoid memory leaks)</p> <p>Therefore, we create a new <code>struct mm</code> and load the segments from the ELF file and the process stack into it. Only after we no longer need to allocate memory (<code>mm_mappages</code>) do we clear and overwrite <code>p-&gt;mm</code>.</p> <pre><code>// os/loader.c, Simpilfied version.\nint load_user_elf(struct user_app *app, struct proc *p, char *args[]) {\n\n    // create a new mm for the process, including trapframe and trampoline mappings\n    struct mm *new_mm = mm_create(p-&gt;trapframe);\n\n    Elf64_Ehdr *ehdr      = (Elf64_Ehdr *)app-&gt;elf_address;\n    for (int i = 0; i &lt; ehdr-&gt;e_phnum; i++) {\n        struct vma *vma = mm_create_vma(new_mm);\n        // Load Segment from phdr.\n        if (mm_mappages(vma) &lt; 0)   // if page allocation fails, jump to bad.\n            goto bad;\n    }\n    // setup brk: zero\n    mm_mappages(vma_brk);\n    // setup stack\n    mm_mappages(vma_ustack);\n\n    // from here, we are done with all page allocation \n    // (including pagetable allocation during mapping the trampoline and trapframe).\n\n    // free the old mm.\n    if (p-&gt;mm)\n        mm_free(p-&gt;mm);    \n\n    // we can modify p's fields because we will return to the new exec-ed process.\n    p-&gt;mm      = new_mm;\n    // setup trapframe\n    p-&gt;trapframe-&gt;epc = ehdr-&gt;e_entry;\n\n    return 0;\n\n    // otherwise, page allocations fails. we will return to the old process.\nbad:\n    warnf(\"load (%s) failed: %d\", app-&gt;name, ret);\n    mm_free(new_mm);\n    return ret;\n}\n</code></pre>"},{"location":"laben/xv6lab-userprocess/#lifecycle","title":"Lifecycle","text":""},{"location":"laben/xv6lab-userprocess/#exit","title":"exit","text":"<p>The <code>exit</code> system call is used to terminate the current process and return an exit status to the operating system. The <code>exit</code> system call never returns. After calling <code>exit</code>, some resources of the process are not immediately reclaimed by the operating system. Moreover, <code>exit</code> does not immediately make the process disappear from the parent process's view. It remains in the \"zombie process\" state until the parent process obtains the child process's exit status through the <code>wait</code> system call and reclaims the process.</p> <p>Here is a simplified version of <code>exit</code>. Note that we do not reclaim user resources here: up to this Lab, we have only introduced one type of user resource, namely user memory.</p> <p>In <code>exit</code>, we only set our state to <code>ZOMBIE</code> and save the exit code to <code>p-&gt;exit_code</code>. Then, we use <code>wakeup</code> to wake up our parent process.</p> <pre><code>// Exit the current process.\nvoid exit(int code) {\n    int wakeinit = 0;\n    struct proc *p = curr_proc();\n\n    acquire(&amp;wait_lock);\n    // reparent\n\n    // wakeup wait-ing parent.\n    wakeup(p-&gt;parent);\n\n    acquire(&amp;p-&gt;lock);\n    p-&gt;exit_code = code;\n    p-&gt;state     = ZOMBIE;\n    release(&amp;wait_lock);\n\n    sched();\n    panic_never_reach();\n}\n</code></pre> <p>wakeup</p> <p>We will explain locks and synchronization in detail in subsequent synchronization Labs, including what <code>wait_lock</code> is in the above code.</p> <p>In this Lab, we only need to know that the parent process will sleep when <code>wait</code> cannot find a child process in the <code>ZOMBIE</code> state. The child process <code>exit</code> will set itself to <code>ZOMBIE</code>, which breaks the condition for the parent process to sleep, so we wake up the parent process to prevent it from sleeping.</p>"},{"location":"laben/xv6lab-userprocess/#reparent","title":"reparent","text":"<p>\"Reparent\" refers to the operating system changing the parent process of a process to the init process (process with PID 1) when the parent process terminates. This is a system-level management mechanism to ensure that when the parent process terminates, the child process still has a parent process to perform necessary operations such as resource reclamation and process management.</p> <p>The reparent mechanism is mainly used to avoid the \"orphan process\" problem and ensure that system resources are properly reclaimed. In xv6, <code>init</code> is like an \"orphanage,\" responsible for reclaiming the grandchild processes created by child processes.</p> <p></p> <pre><code>// user/src/init.c\n\nfor (;;) {\n    // this call to wait() returns if the shell exits,\n    // or if a parentless process exits.\n    wpid = wait(-1, NULL);\n    if (wpid == pid) {\n        // the shell exited; restart it.\n        printf(\"init: sh exited, restarting...\\n\");\n        break;\n    } else {\n        // it was a parentless process; do nothing.\n        printf(\"init: wait a parentless process %d\\n\", wpid);\n    }\n}\n</code></pre>"},{"location":"laben/xv6lab-userprocess/#wait","title":"wait","text":"<p>The wait system call is a crucial function for process control in operating systems. Its primary purpose is to allow a parent process to wait for a state change in its child process (in xv6, only termination is supported) and retrieve the child's exit code.</p> <p>In xv6, the prototype of <code>wait</code> resembles Linux's <code>waitpid(2)</code>. The provided <code>pid</code> can be a negative value, indicating that the parent waits for \u200b\u200bany\u200b\u200b child process; otherwise, it waits for a specific child process.</p> <p>For simplicity, xv6 represents the parent-child relationship using only the <code>parent</code> pointer in the child's Process Control Block (PCB), without maintaining a reverse <code>children</code> list for traversal. Thus, to find a child, the implementation scans \u200b\u200ball processes\u200b\u200b, checking whether any process's <code>parent</code> pointer points to the current process (<code>curr_proc()</code>).</p> <p>When such a child process is found \u200b\u200band\u200b\u200b it is in the ZOMBIE state, the system can reclaim its resources and return from the wait system call.</p> <pre><code>int wait(int pid, int *code) {\n    struct proc *child;\n    int havekids;\n    struct proc *p = curr_proc();\n\n    acquire(&amp;wait_lock);\n\n    for (;;) {\n        // Scan through table looking for exited children.\n        havekids = 0;\n        for (int i = 0; i &lt; NPROC; i++) {\n            child = pool[i];\n            if (child == p)\n                continue;\n\n            acquire(&amp;child-&gt;lock);\n            if (child-&gt;parent == p) {\n                havekids = 1;\n                if (child-&gt;state == ZOMBIE &amp;&amp; (pid &lt;= 0 || child-&gt;pid == pid)) {    // condition for matching a child process\n                    int cpid = child-&gt;pid;\n                    // Found one.\n                    if (code)\n                        *code = child-&gt;exit_code;\n                    freeproc(child);\n                    release(&amp;child-&gt;lock);\n                    release(&amp;wait_lock);\n                    return cpid;\n                }\n            }\n            release(&amp;child-&gt;lock);\n        }\n\n        // No waiting if we don't have any children.\n        if (!havekids || p-&gt;killed) {\n            release(&amp;wait_lock);\n            return -ECHILD;\n        }\n\n        debugf(\"pid %d sleeps for wait\", p-&gt;pid);\n        // Wait for a child to exit.\n        sleep(p, &amp;wait_lock);  // DOC: wait-sleep\n    }\n}\n</code></pre> <p>The <code>freeproc</code> function releases the child's PCB (marking it as UNUSED) and reclaims its user memory (<code>mm_free</code>).</p>"},{"location":"laben/xv6lab-userprocess/#sleep-mechanism","title":"Sleep Mechanism","text":"<p>Imagine a process is using the <code>read</code> system call to read data from stdin (i.e., the console), but at this moment, the user hasn\u2019t input anything yet. The operating system has two options to handle this situation:</p> <ol> <li>Temporarily suspend the process and wait until there is data available on the console before returning.</li> <li>Continuously poll the console input and return from <code>read</code> as soon as there is input.</li> </ol> <p>Clearly, the second approach is inefficient for a valuable resource like the CPU. Input/Output operations, such as those involving the console, have no upper bound on response time. Instead of letting the CPU spin idly, it\u2019s better to yield the CPU to other processes for execution and wake up the original process once data becomes available on the console. This is why we need to put a process to sleep: because it lacks certain conditions to continue executing. Rather than wasting CPU resources, it\u2019s more efficient to wait until the conditions are met and then wake the process up.</p> <p>In the case of the console, the missing condition is that the user hasn\u2019t provided any input. So, how does the process get woken up when there\u2019s input on the console? Recalling our previous lessons, we should let the console send an interrupt to the CPU when data is available.</p>"},{"location":"laben/xv6lab-userprocess/#sleep-wakeup","title":"sleep &amp; wakeup","text":"<p>The implementation of the <code>sleep</code> and <code>wakeup</code> functions is as follows. We use a <code>void*</code> pointer to represent arbitrary data, indicating why the current process is entering the <code>SLEEPING</code> state.</p> <p>The <code>sleep</code> function sets <code>curr_proc()-&gt;state</code> to <code>SLEEPING</code> and calls the <code>sched()</code> function to switch to the scheduler. Note that the scheduler only selects <code>RUNNABLE</code> processes to execute, so the current process will no longer be scheduled\u2014meaning it won\u2019t continue running.</p> <p>The <code>wakeup</code> function iterates through all processes. If a process\u2019s sleep reason (<code>sleep_chan</code>) matches the provided <code>chan</code>, its state is set back to <code>RUNNABLE</code>, allowing it to be scheduled and executed again by the scheduler.</p> <pre><code>void sleep(void *chan, spinlock_t *lk) {\n    struct proc *p = curr_proc();\n\n    acquire(&amp;p-&gt;lock);  // DOC: sleeplock1\n    // Go to sleep.\n    p-&gt;sleep_chan = chan;\n    p-&gt;state      = SLEEPING;\n\n    sched();\n    // p get waking up, Tidy up.\n    p-&gt;sleep_chan = 0;\n\n    release(&amp;p-&gt;lock);\n}\nvoid wakeup(void *chan) {\n    for (int i = 0; i &lt; NPROC; i++) {\n        struct proc *p = pool[i];\n        acquire(&amp;p-&gt;lock);\n        if (p-&gt;state == SLEEPING &amp;&amp; p-&gt;sleep_chan == chan) {\n            p-&gt;state = RUNNABLE;\n            add_task(p);\n        }\n        release(&amp;p-&gt;lock);\n    }\n}\n</code></pre> <p>lock</p> <p>Note that the <code>sleep</code> function takes a spinlock <code>spinlock_t *lk</code> as an argument. For this lesson, we don\u2019t need to fully understand why it\u2019s designed this way yet.</p>"},{"location":"laben/xv6lab-userprocess/#console","title":"Console","text":"<p>Taking the console as an example, the <code>read</code> system call eventually reaches the <code>os/console.c: user_console_read</code> function. If the kernel\u2019s buffer <code>cons.buffer</code> is empty (<code>cons.r == cons.w</code>), the current process is put to sleep on <code>&amp;cons</code>.</p> <p>When there\u2019s readable data on the console device, the console triggers an interrupt to the CPU via the PLIC. In <code>trap.c: plic_handle()</code>, we determine whether the interrupt comes from the console (UART) based on the <code>irq</code>. If it does, the interrupt is dispatched to <code>uart_intr</code> for handling. The <code>uart_intr</code> function reads a byte from the UART device using <code>uartgetc</code> and calls <code>consintr</code>. When we receive a <code>\\n</code>, we wake up the processes waiting on <code>&amp;cons</code>.</p> <pre><code>static void consintr(int c) {\n    if (c == '\\n' || c == C('D') || cons.e - cons.r == INPUT_BUF_SIZE) {\n        // wake up consoleread() if a whole line (or end-of-file)\n        // has arrived.\n        cons.w = cons.e;\n        wakeup(&amp;cons);\n    }\n}\n</code></pre>"},{"location":"laben/xv6lab-userprocess/#lab-report","title":"Lab Report","text":"<ol> <li>Starting from a user program calling the <code>fork</code> system call in, list in sequence the important functions that the operating system will execute, until the child process returns 0 from <code>fork</code>. These \"important functions\" are functions that manage the following subsystems (or features): PCB (Process Control Block), User Address Space (only <code>vm.c</code>), Trap, CPU Scheduler, and Context Switch.</li> </ol> <p>Requirements: No need to consider the parent process. No need to list operations related to locks (<code>acquire</code>, <code>release</code>). For nested function calls, only write up to the first third call-depth. You can assume memory allocation always returns successfully; no need to consider error handling paths.</p> <ol> <li> <p>Fill in the table below, mapping the process states (explained in theoretical classes) to the values of <code>enum procstate</code> (<code>os/proc.h</code>) in xv6 (<code>struct proc, state</code>), and describe the events that cause state transitions. </p> <p>Note: The upper-left \"new\" state corresponds to <code>USED</code> in <code>enum procstate</code>.</p> <p></p> </li> <li> <p>In different processes, is their Trampoline the same physical page? Is their Trapframe the same physical page?</p> </li> </ol> <p>Hint: When executing the command <code>test_arg 123 asd</code> under <code>sh &gt;&gt;</code>, <code>sh</code> will fork&amp;exec to launch the <code>test_arg</code> program. The kernel will also print the page table of <code>test_arg</code>. Observe the Trapframe and Trampoline in its page table and in the page table of <code>sh</code>.</p> <ol> <li> <p>When using the <code>exec</code> system call, we pass the process's arguments, i.e., <code>int exec(char *path, char *argv[])</code>. In the <code>main</code> function, we receive the <code>argv</code> array: <code>int main(int argc, char *argv[])</code>, where <code>argv</code> is an array of <code>char*</code> (string pointers), and its last element is <code>NULL</code>. The <code>argc</code> represents the number of string pointers in the array.</p> <p>We know that <code>exec</code> will remove all memory mappings. So, how are the <code>argv</code> values passed from the old process to the new process when the <code>exec</code> system call is invoked?</p> <p>Hint: After running make run, <code>test_arg</code> will appear in the applists. You can test it in the <code>sh &gt;&gt;</code> prompt.</p> <p>Debugger Tutorial\uff1aUse <code>make debug</code> to run QEMU with a debugger, and connect to QEMU with <code>gdb-multiarch</code>. First, use <code>continue</code> twice to make the kernel run to the <code>sh &gt;&gt;</code> prompt.</p> <p></p> <p>In GDB, press Ctrl+C to interrupt, then use <code>add-symbol-file user/build/test_arg</code> to add debugging symbols for the user program. Set a breakpoint at the main function of the user program by executing <code>b main</code>.</p> <p></p> <p>Execute <code>continue</code> to resume the kernel. In the kernel command line, type <code>test_arg asdf asfkjls asf</code> (the additional arguments can be random) and press Enter. You should hit the breakpoint in GDB at the user program.</p> <p></p> <p>Use <code>stack -l 20</code> to observe the content on the stack. (Note that addresses after <code>0xffff0000</code> are unmapped.) The value a1 on the right represents the value of the a1 register, which is the address <code>0x00000000fffefff0</code>.</p> <pre><code>(qemu) gef\u27a4  stack -l 20\n0x00000000fffeff70\u2502+0x0000: 0x00000000fffeffd0  \u2192  0x0000000000006466  \u2192  0x0000000000006466     \u2190 $sp\n0x00000000fffeff78\u2502+0x0008: 0x000000000040234c  \u2192  0x02813c8303813b83  \u2192  0x02813c8303813b83\n0x00000000fffeff80\u2502+0x0010: 0x00000000fffefff0  \u2192  0x6772615f74736574  \u2192  0x6772615f74736574     \u2190 $fp, $a1\n0x00000000fffeff88\u2502+0x0018: 0x00000000fffeffe8  \u2192  0x0000343135343131  \u2192  0x0000343135343131\n0x00000000fffeff90\u2502+0x0020: 0x00000000fffeffe0  \u2192  0x0030313839313931  \u2192  0x0030313839313931\n0x00000000fffeff98\u2502+0x0028: 0x00000000fffeffd8  \u2192  0x0066647361667361  \u2192  0x0066647361667361\n0x00000000fffeffa0\u2502+0x0030: 0x00000000fffeffc8  \u2192  0x7361667361667361  \u2192  0x7361667361667361\n0x00000000fffeffa8\u2502+0x0038: 0x00000000fffeffb8  \u2192  0x7769756168667361  \u2192  0x7769756168667361\n0x00000000fffeffb0\u2502+0x0040: 0x0000000000000000  \u2192  0x0000000000000000\n0x00000000fffeffb8\u2502+0x0048: 0x7769756168667361  \u2192  0x7769756168667361\n0x00000000fffeffc0\u2502+0x0050: 0x000000006b666265  \u2192  0x000000006b666265\n0x00000000fffeffc8\u2502+0x0058: 0x7361667361667361  \u2192  0x7361667361667361\n0x00000000fffeffd0\u2502+0x0060: 0x0000000000006466  \u2192  0x0000000000006466\n0x00000000fffeffd8\u2502+0x0068: 0x0066647361667361  \u2192  0x0066647361667361\n0x00000000fffeffe0\u2502+0x0070: 0x0030313839313931  \u2192  0x0030313839313931\n0x00000000fffeffe8\u2502+0x0078: 0x0000343135343131  \u2192  0x0000343135343131\n0x00000000fffefff0\u2502+0x0080: 0x6772615f74736574  \u2192  0x6772615f74736574\n0x00000000fffefff8\u2502+0x0088: 0x0000000000000000  \u2192  0x0000000000000000\n</code></pre> <p>Notice that numbers like <code>0x7769756168667361</code> seem like ASCII codes. You can use <code>x/60s $sp</code> to print the stack content that looks like strings.</p> <p>Note: At the low level of computers, \"strings\" are sequences of bytes that are terminated by 0x00.</p> </li> </ol>"},{"location":"laben/xv6lab-userprocess/#reading","title":"Reading","text":"<ol> <li> <p>Where do the physical pages for Trampoline and Trapframe come from?</p> <p>Referring to the user page table of the sh process we printed above, pay attention to the physical addresses mapped in the last two entries:</p> <pre><code>[ff], pte[0xffffffc080b147f8]: 0x0000003fc0000000 -&gt; 0x0000000080b15000 -------V\n[1ff], pte[0xffffffc080b15ff8]: 0x0000003fffe00000 -&gt; 0x0000000080b16000 -------V\n    [1fe], pte[0xffffffc080b16ff0]: 0x0000003fffffe000 -&gt; 0x0000000080b17000 DA---WRV\n    [1ff], pte[0xffffffc080b16ff8]: 0x0000003ffffff000 -&gt; 0x000000008020b000 -A--X-RV\n</code></pre> <p>Refer to the \"xv6 Kernel Memory Layout\" section from \"Week 6 - Kernel Paging\" to determine which physical address regions these two physical addresses belong to. Cross-check your answers with the source code in <code>trampoline.S</code> and the linker script <code>os/kernel.ld</code>.</p> </li> <li> <p>Recalling last week's class report question: Trapframe and Trampoline are two pages. Should these two pages be accessible in U-mode?</p> <p>Please conduct an experiment to verify this yourself.</p> <p>For Trampoline, modify the <code>kvmmake</code> function in <code>kvm.c</code>. When calling <code>kvmmap</code> to map the trampoline, OR the PTE_U permission into the permissions.</p> <p>For Trapframe, modify the <code>allocproc</code> function in <code>proc.c</code>. At the point where mm_mappage_at is called, OR the PTE_U permission into the permissions.</p> <p>Use <code>make debug</code> and <code>gdb-multiarch</code> to attach a debugger. Set breakpoints at the kernel trap entry and at <code>uservec</code> with <code>b kernel_trap_entry</code> and <code>b *0x3ffffff000</code>. Use <code>print $scause</code> to manually inspect the trap-related CSR registers.</p> </li> </ol>"},{"location":"laben/xv6lab-userspace/","title":"Userspace","text":"<p>Userspace is a restricted runtime environment provided by the operating system for user programs. The OS leverages CPU hardware features to enforce isolation between userspace and the kernel, typically including:</p> <ul> <li>Privilege-level isolation: Userspace runs at a low privilege level, and attempts to execute high-privilege instructions trigger exceptions.</li> <li>Memory space isolation: The kernel configures page tables to define userspace address space, preventing direct access to kernel addresses.</li> </ul>"},{"location":"laben/xv6lab-userspace/#lab-objectives","title":"Lab Objectives","text":"<ol> <li>Understand how to establish userspace.</li> <li>Grasp the trampoline mechanism.</li> <li>Comprehend the execution process of the first user process.</li> <li>Understand the role of <code>uaccess</code>.</li> </ol>"},{"location":"laben/xv6lab-userspace/#overview","title":"Overview","text":"<p>In this Lab, we will run the CPU in U-mode for the first time and execute the first user program.</p> <p>From the assignment1, we observed that if <code>sstatus.SPP == 0</code> during an <code>sret</code> instruction, the CPU downgrades to U-mode.  Once in U-mode, the CPU can only return to S-mode via a trap, which can be either an exception or an interrupt.</p> <ul> <li>User programs can invoke an exception using <code>ecall</code>, triggering Exception: Code 8 (Environment call from U-mode), the RISC-V mechanism for system calls (syscalls).</li> <li>In U-mode, interrupts are always enabled. Recall from the \"Trap, Exception, and Interrupt\" chapter: a trap occurs if (running in S-mode with <code>sstatus.SIE == 1</code>) or (running in U-mode).</li> </ul> <p>Upon completing the details outlined in this lab, you can refer to the diagram below to understand the userspace structure in xv6.</p> <p>In the diagram, blue blocks represent pages allocated by <code>kallocpage</code>, yellow blocks denote kernel code, and green blocks indicate trampoline code. It illustrates pointer relationships (black arrows) among kernel data structures and the code invocation process (red dashed arrows) during kernel-user mode transitions.</p> <p></p> <p>xv6-lab5 Code Branch</p> <p>https://github.com/yuk1i/SUSTech-OS-2025/tree/xv6-lab5</p> <p>Use the command <code>git clone https://github.com/yuk1i/SUSTech-OS-2025 -b xv6-lab5 xv6lab5</code> to download the xv6-lab5 code.</p> <p>Run <code>make run</code> to launch the kernel for this lab, which starts the first user process <code>init</code>, with source code at <code>user/src/init.c</code>.</p>"},{"location":"laben/xv6lab-userspace/#user-and-kernel-mode-transitions","title":"User and Kernel Mode Transitions","text":"<p>The RISC-V CPU operates at a specific privilege level. The OS runs in S-mode, while user programs execute in U-mode.</p> <p>We will explain how to downgrade from S-mode to U-mode and return from U-mode to S-mode.</p>"},{"location":"laben/xv6lab-userspace/#kernel-user","title":"Kernel -&gt; User","text":"<p>In the \"Interrupts\" chapter, we learned that the <code>sret</code> instruction performs three actions:</p> <ol> <li><code>sstatus.SIE &lt;= sstatus.SPIE</code></li> <li><code>Current_Privilege_Level &lt;= sstatus.SPP</code></li> <li><code>pc &lt;= sepc</code></li> </ol> <p>In plain terms: restore <code>sstatus.SIE</code> from <code>sstatus.SPIE</code>, set the privilege level (U/S) to <code>sstatus.SPP</code>, and set the program counter (PC) to <code>sepc</code>.</p> <p>The <code>SPP</code> bit in the CSR <code>sstatus</code> is described as follows:</p> <p>The SPP bit indicates the privilege level at which a hart was executing before entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap originated from user mode, or 1 otherwise. When an SRET instruction (see Section 3.3.2) is executed to return from the trap handler, the privilege level is set to user mode if the SPP bit is 0, or supervisor mode if the SPP bit is 1; SPP is then set to 0.</p> <p>Thus, if <code>sstatus.SPP == 0</code> during <code>sret</code>, the CPU downgrades to U-mode. (This does not strictly require being in a trap handler.)</p>"},{"location":"laben/xv6lab-userspace/#user-kernel","title":"User -&gt; Kernel","text":"<p>In U-mode, the CPU returns to S-mode by triggering a trap, which includes:</p> <ul> <li>Interrupts: Such as timer interrupts or external interrupts.</li> <li> <p>Exceptions: Including:</p> <ul> <li>Illegal Instruction</li> <li>(Load, Store, Fetch) Page Fault</li> <li>Environment call (RISC-V\u2019s syscall mechanism\uff0ci.e., <code>ecall</code> )</li> </ul> </li> </ul> <p>For system calls, user programs use the <code>ecall</code> instruction to trigger a trap, allowing the CPU to return to S-mode via the trap mechanism.</p> <p>ecall</p> <p>Recall that we previously used <code>ecall</code> in S-mode to invoke interfaces provided by M-mode.</p> <p>An environment call requests services from the execution environment by raising an exception.</p>"},{"location":"laben/xv6lab-userspace/#user-page-table-kernel-page-table","title":"User Page Table / Kernel Page Table","text":"<p>In the previous lab, we explored the RISC-V page table model and set up a page table for the kernel. The 4<sup>th</sup> bit in a PTE, <code>PTE_U</code>, indicates whether the mapping is accessible in user mode.</p> <p>In this lab, we introduce userspace, where user processes must execute.  We divide the 512 GiB address space into user addresses (low) and kernel addresses (high), with user addresses starting at <code>0x0000_00</code> and kernel addresses at <code>0xffff_ff</code>.</p> <p>Each user process requires its own independent address space, so we create a distinct user page table for each user program.</p> <p>In xv6, user page tables exclude kernel page table entries, meaning they lack mappings for kernel code, data, or direct mappings. This poses a challenge during S-mode to U-mode transitions:</p> <p>Imagine a user process using its user page table when a trap occurs, requiring a switch to S-mode. Before entering the trap handler, the CPU must jump to <code>stvec</code>, but it still uses the user\u2019s <code>satp</code> (user page table), which lacks kernel space mappings. Thus, the kernel\u2019s trap handler address (<code>stvec</code>, e.g., <code>0xffff_ffff_8020_xxxx</code>) is inaccessible, creating a problem.</p> <p>We cannot directly use the kernel\u2019s <code>stvec</code> in U-mode. This issue resembles the relocation challenges we faced earlier.</p> <p>To resolve this, we designate a special trap handler for U-mode with a virtual address identical in both kernel and user page tables. This allows execution in kernel mode with a user page table during U-mode to S-mode transitions via traps.</p> <p>This special page, called the trampoline, is mapped to <code>0x0000_003f_ffff_f000</code>.</p>"},{"location":"laben/xv6lab-userspace/#trampoline-trampolines","title":"Trampoline (trampoline.S)","text":"<p>Trampoline: n. A springboard or rebound mechanism.</p> <p>In xv6, the trampoline consists of two code segments, <code>uservec</code> and <code>userret</code>, handling transitions from user mode to kernel mode (U-mode\u2019s <code>stvec</code>) and from kernel mode to user mode, respectively.</p> <p>The trampoline\u2019s virtual address, <code>0x0000_003f_ffff_f000</code>, exists in both the kernel page table and every user page table, ensuring safe <code>satp</code> switches without invalidating the current PC (recall relocation issues from the previous chapter).</p>"},{"location":"laben/xv6lab-userspace/#trampoline-user-to-kernel","title":"Trampoline - User to Kernel","text":"<p>When transitioning from U-mode to S-mode via a trap, <code>uservec</code> switches to the kernel page table and invokes the user\u2019s trap handler, <code>usertrap</code>.</p>"},{"location":"laben/xv6lab-userspace/#uservec-trampolines","title":"uservec (trampoline.S)","text":"<pre><code>    .section trampsec\n.globl trampoline\ntrampoline:\n\n.globl uservec\nuservec:\n        # trap.c sets stvec to point here, so\n        # traps from user space start here,\n        # in supervisor mode, but with a user page table.\n        #\n        # sscratch points to where the process's p-&gt;trapframe is\n        # mapped into user space, at TRAPFRAME.\n\n    # swap a0 and sscratch, so that a0 is TRAPFRAME\n        csrrw a0, sscratch, a0\n\n        # save the user registers (x1 - x31) in TRAPFRAME\n        sd ra, 40(a0)\n        sd sp, 48(a0)\n        # ...\n        sd t5, 272(a0)\n        sd t6, 280(a0)\n\n        # we have saved t0, so we can smash it\n        # restore a0 from sscratch, and save it\n        csrr t0, sscratch\n        sd t0, 112(a0)\n\n        # save epc\n        csrr t1, sepc\n        sd t1, 24(a0)\n\n        # load kernel's satp, sp, usertrap handler, tp(cpuid)\n        ld t1, 0(a0)\n        ld sp, 8(a0)\n        ld t0, 16(a0)\n        ld tp, 32(a0)\n\n        csrw satp, t1\n        sfence.vma zero, zero\n\n        jr t0\n</code></pre> <p>In <code>uservec</code>, all GPRs (x1-x31) are in use by the user program. We must preserve them when returning via <code>sret</code> in <code>userret</code>, consistent with kernel trap handling.</p> <p>For kernel traps, we built a <code>struct ktrapframe</code> on the kernel stack to save GPRs. Similarly, for user traps, we define a <code>trapframe</code>, smaller than a page, mapped to a fixed user page table address, <code>0x0000_003f_ffff_e000</code> (the page below the trampoline).</p> <p>The <code>struct trapframe</code> is defined in <code>proc.h</code>:</p> <pre><code>struct trapframe {\n    /*   0 */ uint64 kernel_satp;    // kernel page table\n    /*   8 */ uint64 kernel_sp;      // top of process's kernel stack\n    /*  16 */ uint64 kernel_trap;    // usertrap()\n    /*  24 */ uint64 epc;            // saved user program counter\n    /*  32 */ uint64 kernel_hartid;  // saved kernel tp\n    /*  40 */ uint64 ra;\n    /*  48 */ uint64 sp;\n    /*  ... */\n    /* 272 */ uint64 t5;\n    /* 280 */ uint64 t6;\n};\n</code></pre> <p>Since RISC-V instruction destinations must be registers (not immediates), and we cannot modify registers before saving them, we need at least one scratch register to hold the trapframe address (<code>0x0000_003f_ffff_e000</code>). RISC-V provides the <code>sscratch</code> register for this purpose. Using <code>csrrw a0, sscratch, a0</code>, we swap <code>sscratch</code> and <code>a0</code>, storing the user\u2019s <code>a0</code> in <code>sscratch</code> and loading <code>sscratch</code>\u2019s value (the trapframe address) into <code>a0</code>.</p> <p>We stipulate that, after OS initialization, <code>sscratch</code> holds the trapframe\u2019s virtual address in the user page table (<code>0x0000_003f_ffff_e000</code>).  After entering <code>uservec</code>, swapping <code>a0</code> and <code>sscratch</code> sets <code>a0</code> to <code>0x0000_003f_ffff_e000</code>.  We then use instructions like <code>sd ra, 40(a0)</code> to save all user registers except <code>a0</code>. Once saved, we can modify registers, retrieving the user\u2019s <code>a0</code> from <code>sscratch</code> into <code>t0</code> and storing it in the trapframe, completing the save process. Next, we save <code>sepc</code> into the trapframe.</p> <p>Finally, we load kernel-related data from the trapframe: kernel page table (<code>t1</code>, <code>kernel_satp</code>), kernel stack (<code>sp</code>, <code>kernel_sp</code>), kernel trap handler (<code>t0</code>, <code>kernel_trap</code>), and CPU ID (<code>tp</code>, <code>kernel_hartid</code>).  After switching to the kernel page table, we jump to <code>tf-&gt;kernel_trap</code> to handle <code>usertrap</code> in a C environment.</p> <p>Kernel Stack</p> <p>The kernel uses several stacks:</p> <ul> <li><code>boot_stack</code>: Used during kernel boot.</li> <li><code>sched_kstack</code>: Per-CPU stack for the scheduler.</li> <li><code>p-&gt;kstack</code>: Per-process kernel stack for kernel threads. When transitioning from U-mode to S-mode, the user-mode <code>sp</code> is unavailable, so we switch to this stack.</li> </ul>"},{"location":"laben/xv6lab-userspace/#trampoline-kernel-to-user","title":"Trampoline - Kernel to User","text":"<p>To transition from S-mode to U-mode (e.g., for the first user process run or returning from a trap), we call <code>usertrapret</code> to save kernel state, load user state, switch to the user page table via <code>userret</code>, and resume execution at the <code>sepc</code>-recorded location.</p>"},{"location":"laben/xv6lab-userspace/#usertrapret-trapc","title":"usertrapret (trap.c)","text":"<p><code>usertrapret</code> saves kernel information into the trapframe, sets <code>sepc</code> to the trapframe\u2019s <code>epc</code>, configures <code>sstatus.SPP</code>, computes the user page table\u2019s <code>satp</code> and <code>stvec</code>, and jumps to <code>userret</code> in the trampoline.</p> <p>When calling <code>userret</code>, we pass three arguments: the user\u2019s trapframe address, user page table <code>satp</code>, and <code>stvec</code>. In assembly, these are accessible via <code>a0</code>, <code>a1</code>, and <code>a2</code>.</p> <pre><code>//\n// return to user space\n//\nvoid usertrapret() {\n    if (intr_get())\n        panic(\"usertrapret entered with intr on\");\n\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    trapframe-&gt;kernel_satp      = r_satp();                                 // kernel page table\n    trapframe-&gt;kernel_sp        = curr_proc()-&gt;kstack + KERNEL_STACK_SIZE;  // process's kernel stack\n    trapframe-&gt;kernel_trap      = (uint64)usertrap;\n    trapframe-&gt;kernel_hartid    = r_tp();\n\n    w_sepc(trapframe-&gt;epc);\n    // set up registers for trampoline.S's sret to user space\n\n    // set S Previous Privilege mode to User\n    uint64 x = r_sstatus();\n    x &amp;= ~SSTATUS_SPP;  // clear SPP to 0 for user mode\n    x |= SSTATUS_SPIE;  // enable interrupts in user mode\n    w_sstatus(x);\n\n    // tell trampoline.S the user page table to switch to\n    uint64 satp  = MAKE_SATP(KVA_TO_PA(curr_proc()-&gt;mm-&gt;pgt));\n    uint64 stvec = (TRAMPOLINE + (uservec - trampoline)) &amp; ~0x3;\n\n    uint64 fn = TRAMPOLINE + (userret - trampoline);\n    tracef(\"return to user @%p, fn %p\", trapframe-&gt;epc);\n    ((void (*)(uint64, uint64, uint64))fn)(TRAPFRAME, satp, stvec);\n}\n</code></pre>"},{"location":"laben/xv6lab-userspace/#userret-trampolines","title":"userret (trampoline.S)","text":"<p>In <code>userret</code>, we use the <code>a1</code> register (from <code>usertrapret</code>) to switch to the user page table. We can then access the trapframe at <code>0x0000_003f_ffff_e000</code> and set <code>stvec</code> to the user trap handler (<code>uservec</code>) from the kernel trap entry.</p> <p>Next, we store the user\u2019s <code>a0</code> in <code>sscratch</code> and restore other user registers from the trapframe. Finally, we swap <code>a0</code> and <code>sscratch</code> with <code>csrrw a0, sscratch, a0</code>, restoring the user\u2019s <code>a0</code> while setting <code>sscratch</code> back to the trapframe address (<code>0x0000_003f_ffff_e000</code>).</p> <p>At the end of <code>userret</code>, we execute <code>sret</code>, switching to U-mode and resuming execution at the <code>sepc</code> location.</p> <pre><code>.globl userret\nuserret:\n        # userret(TRAPFRAME, pagetable, stvec)\n        # switch from kernel to user.\n        # usertrapret() calls here.\n        # a0: TRAPFRAME, in user page table.\n        # a1: user page table, for satp.\n\n        # switch to the user page table.\n        csrw satp, a1\n        sfence.vma zero, zero\n\n        # switch to the user stvec.\n        csrw stvec, a2\n\n        # put the saved user a0 in sscratch, so we\n        # can swap it with our a0 (TRAPFRAME) in the last step.\n        ld t0, 112(a0)\n        csrw sscratch, t0\n\n        # restore all but a0 from TRAPFRAME\n        ld ra, 40(a0)\n        ld sp, 48(a0)\n        # ...\n        ld t5, 272(a0)\n        ld t6, 280(a0)\n\n        # restore user a0, and save TRAPFRAME in sscratch\n        csrrw a0, sscratch, a0\n\n        # return to user mode and user pc.\n        # usertrapret() set up sstatus and sepc.\n        sret\n</code></pre>"},{"location":"laben/xv6lab-userspace/#the-first-user-process","title":"The First User Process","text":"<p>Here, we explore how the OS, after booting, transitions from S-mode to U-mode to run the first user process and handles traps within it.</p>"},{"location":"laben/xv6lab-userspace/#creating-the-user-process","title":"Creating the User Process","text":"<p>After booting, the OS loads the first user process, <code>init</code>, via <code>load_init_app</code> called from <code>bootcpu_init</code>. <code>allocproc</code> creates and initializes the Process Control Block (PCB) for <code>init</code>, <code>load_user_elf</code> loads the <code>init</code> ELF into the PCB <code>p</code>, and <code>add_task</code> enqueues it in the scheduler for its first execution.</p> <pre><code>int load_init_app() {\n    struct user_app *app = get_elf(INIT_PROC);\n    struct proc *p = allocproc();\n    load_user_elf(app, p, argv);\n    add_task(p);\n    init_proc = p;\n    release(&amp;p-&gt;lock);\n    return 0;\n}\n</code></pre> <p>In the \"Context Switch\" chapter, <code>allocproc</code> initialized fields like <code>pid</code> and <code>state</code> in <code>struct proc</code>, setting the context to <code>sched_first_ret</code>. In this chapter, with user mode introduced, <code>allocproc</code> additionally maps the trampoline to a kernel code page in the user address space, allocates and maps a trapframe page, and stores its kernel virtual address (KVA) in <code>p-&gt;trapframe</code>.</p> <p><pre><code>struct proc *allocproc() {\n    // ...\nfound:\n    // ==== Resources Allocation ====\n\n    p-&gt;pid   = allocpid();\n    p-&gt;state = USED;\n    // create struct mm for user memory management\n    p-&gt;mm    = mm_create();\n\n    // map trampoline to user address `TRAMPOLINE`\n    mm_mappageat(p-&gt;mm, TRAMPOLINE, KIVA_TO_PA(trampoline), PTE_A | PTE_R | PTE_X);\n\n    // allocate a physical page for trapframe\n    uint64 __pa tf = (uint64)kallocpage();\n    mm_mappageat(p-&gt;mm, TRAPFRAME, tf, PTE_A | PTE_D | PTE_R | PTE_W);\n\n    // ==== Resources Allocation Ends ====\n\n    // prepare trapframe and the first return context\n    p-&gt;trapframe = (struct trapframe *)PA_TO_KVA(tf);\n    memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));\n    memset((void *)p-&gt;kstack, 0, KERNEL_STACK_SIZE);\n    memset((void *)p-&gt;trapframe, 0, PGSIZE);\n    p-&gt;context.ra = (uint64)first_sched_ret;\n    p-&gt;context.sp = p-&gt;kstack + KERNEL_STACK_SIZE;\n\n    return p;\n}\n</code></pre> In <code>load_user_elf</code>, the user program\u2019s <code>epc</code> and other details are written into the process\u2019s trapframe: <pre><code>    // setup trapframe\n    p-&gt;trapframe-&gt;sp  = sp;\n    p-&gt;trapframe-&gt;epc = ehdr-&gt;e_entry;\n    p-&gt;trapframe-&gt;a0  = argc;\n    p-&gt;trapframe-&gt;a1  = uargv_ptr;\n    p-&gt;state          = RUNNABLE;\n</code></pre></p> <p>At this point, the first user process is fully loaded and created.</p>"},{"location":"laben/xv6lab-userspace/#first-transition-to-userspace","title":"First Transition to Userspace","text":"<p>Similar to the \"Context Switch\" chapter, after the scheduler switches to the user process via <code>swtch</code>, <code>first_sched_ret</code> executes when the process is first scheduled. It releases <code>p-&gt;lock</code> per scheduler conventions and jumps to <code>usertrapret</code> (see Trampoline section). Since the trapframe already contains the user program\u2019s entry point and related data, <code>userret</code> \u2018restores\u2019 the user state, and <code>sret</code> initiates execution in userspace.</p>"},{"location":"laben/xv6lab-userspace/#first-userspace-code","title":"First Userspace Code","text":"<p>The initial userspace code is not the entry of <code>init.c</code>. The linker script in <code>user/lib/user.ld</code> defines the ELF entry as <code>__start_main</code>, implemented in <code>user/lib/start_main.c</code>.</p> <p>This function calls <code>main</code> and uses its return value as the exit status for <code>exit</code>, allowing <code>return</code> in <code>main</code> to terminate the program without mandating an explicit <code>exit</code> syscall.</p> <pre><code>#include \"syscall.h\"\n\nextern int main(int, char **);\n\n__attribute__((section(\".text.entry\"))) int __start_main(int argc, char *argv[])\n{\n    exit(main(argc, argv));\n    return 0;\n}\n</code></pre>"},{"location":"laben/xv6lab-userspace/#exiting-userspace","title":"Exiting Userspace","text":"<p>Upon completion, the user process calls the <code>exit</code> syscall in userspace to terminate normally and wake its parent for resource cleanup.</p> <p><code>exit</code> executes code generated by <code>user\\lib\\usys.pl</code>, placing the exit syscall number in <code>a7</code> and invoking <code>ecall</code> to trigger an environment call trap, transitioning to S-mode for syscall execution. (The same process applies to traps during user execution.)</p> <p>After <code>ecall</code>, since the user\u2019s <code>stvec</code> points to <code>uservec</code>, execution jumps to the trampoline\u2019s <code>uservec</code> (see Trampoline section) to enter S-mode. <code>uservec</code> ultimately jumps to <code>usertrap</code> for trap handling.</p>"},{"location":"laben/xv6lab-userspace/#usertrap-trapc","title":"usertrap (trap.c)","text":"<p>In <code>usertrap</code>, we set <code>stvec</code> to <code>kerneltrap</code> to capture subsequent kernel-mode interrupts/exceptions, read <code>scause</code> to process the exception, and return to userspace via <code>usertrapret</code>.</p> <pre><code>void usertrap() {\n    set_kerneltrap();\n\n    assert(!intr_get());\n    if ((r_sstatus() &amp; SSTATUS_SPP) != 0)\n        panic(\"usertrap: not from user mode\");\n\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    uint64 cause = r_scause();\n\n    // handle usertrap according to scause\n\n    assert(!intr_get());\n    usertrapret();\n}\n</code></pre> <p>As a syscall, <code>exit</code> triggers the <code>ecall</code> branch in trap handling, invoking <code>syscall()</code> to execute the corresponding syscall. Since <code>exit</code> does not return, the OS remains in S-mode for cleanup and prepares for the next scheduling cycle, marking the end of the user process.</p>"},{"location":"laben/xv6lab-userspace/#system-call-syscall","title":"System Call (Syscall)","text":"<p>A system call is an OS interface allowing user programs to request kernel services. Syscalls follow a calling convention (e.g., see <code>man 2 syscall</code> for Linux conventions across platforms).</p> <p>On RISC-V, syscalls are initiated by <code>ecall</code>, with the syscall number in <code>a7</code>, up to six arguments in <code>a0-a5</code>, and return values in <code>a0</code> and <code>a1</code>.</p> <p>The <code>ecall</code> instruction raises an exception, causing a trap with <code>scause</code> set to 8 (ecall from U-mode). In <code>usertrap</code>, we handle this exception and delegate to <code>syscall</code> in <code>syscall.c</code>.</p> <pre><code>void usertrap() {\n    // ...\n    struct proc *p              = curr_proc();\n    struct trapframe *trapframe = p-&gt;trapframe;\n\n    uint64 cause = r_scause();\n    if (cause &amp; SCAUSE_INTERRUPT) {\n        // handle interrupt\n    } else if (cause == UserEnvCall) {\n        // sepc points to the ecall instruction,\n        // but we want to return to the next instruction.\n        trapframe-&gt;epc += 4;\n\n        // an interrupt will change sepc, scause, and sstatus,\n        // so enable only now that we're done with those registers.\n        intr_on();\n        syscall();\n        intr_off();\n    }\n    // ...\n    assert(!intr_get());\n    usertrapret();\n}\n</code></pre> <p>The <code>syscall</code> function retrieves register values from the trapframe at the time of <code>ecall</code> and invokes the appropriate syscall handler.</p> <pre><code>void syscall() {\n    struct trapframe *trapframe = curr_proc()-&gt;trapframe;\n    int id                      = trapframe-&gt;a7;\n    uint64 ret;\n    uint64 args[6] = {trapframe-&gt;a0, trapframe-&gt;a1, trapframe-&gt;a2, trapframe-&gt;a3, trapframe-&gt;a4, trapframe-&gt;a5};\n    switch (id) {\n        case SYS_read:\n            ret = sys_read(args[0], args[1], args[2]);\n            break;\n        case SYS_write:\n            ret = sys_write(args[0], args[1], args[2]);\n            break;\n        default:\n            ret = -1;\n            errorf(\"unknown syscall %d\", id);\n    }\n    trapframe-&gt;a0 = ret;\n    tracef(\"syscall ret %d\", ret);\n}\n</code></pre>"},{"location":"laben/xv6lab-userspace/#uaccess","title":"uaccess","text":""},{"location":"laben/xv6lab-userspace/#read-write","title":"read &amp; write","text":"<p><code>read</code> and <code>write</code> are critical Linux syscalls with the following prototypes:</p> <pre><code>ssize_t read(int fd, void buf[.count], size_t count);\nssize_t write(int fd, const void buf[.count], size_t count);\n</code></pre> <p><code>read</code> allows a user program to read up to <code>count</code> bytes from a file descriptor (<code>fd</code>) into <code>buf</code>, returning the number of bytes read. <code>write</code> writes up to <code>count</code> bytes from <code>buf</code> to <code>fd</code>.</p> <p>In the xv6 version we're using for this lab, we haven't introduced the concept of files yet. Therefore, we assume that the <code>read</code> and <code>write</code> system calls correspond to reading from and writing to standard input/output. These two system calls will ultimately be handled by <code>user_console_write</code> and <code>user_console_read</code>.  </p> <p>Thus, in the current xv6, the semantics of <code>read</code> and <code>write</code> are quite simple:  <code>write</code> means printing data from the userspace <code>buf</code> to the serial port.  <code>read</code> means waiting for data from the serial port and copying it into the <code>buf</code>.</p> <p>Both syscalls face a common issue: How does the OS read/write user memory? User memory uses a user page table, not the kernel\u2019s.</p>"},{"location":"laben/xv6lab-userspace/#uaccess_1","title":"uaccess","text":"<p>Accessing user process memory from the kernel is a common requirement, leading us to create a set of functions known as user access primitives.</p> <p>Before exploring \"how uaccess enables kernel read/write of user memory,\" we\u2019ve already performed this task: in <code>loader.c</code>, <code>load_user_elf</code> modifies user memory while loading an ELF user program.</p> <p>Let\u2019s recall how <code>load_user_elf</code> allocates and writes to user memory:</p> <ol> <li>For each <code>PT_LOAD</code> segment, we determine its target virtual address and range, represented by a <code>struct vma</code>.</li> </ol> <pre><code>    Elf64_Phdr *phdr = &amp;phdr_base[i];\n\n    struct vma *vma = mm_create_vma(p-&gt;mm);\n    vma-&gt;vm_start   = PGROUNDDOWN(phdr-&gt;p_vaddr);\n    vma-&gt;vm_end     = PGROUNDUP(vma-&gt;vm_start + phdr-&gt;p_memsz);\n    vma-&gt;pte_flags  = pte_perm;\n</code></pre> <ol> <li>We map the <code>vma</code> region using <code>mm_mappages</code>, which allocates physical pages via <code>kallocpage()</code>.</li> </ol> <pre><code>mm_mappages(vma);\n</code></pre> <ol> <li>Using <code>walkaddr</code>, we translate the virtual address (VA) to a physical address (PA). Since <code>kallocpage</code> returns pages in the kernel\u2019s direct mapping region, we convert the PA to a KVA with <code>PA_TO_KVA</code> for direct access.</li> </ol> <pre><code>void *__kva pa = (void *)PA_TO_KVA(walkaddr(p-&gt;mm, va));\nvoid *src      = (void *)(app-&gt;elf_address + phdr-&gt;p_offset + file_off);\nuint64 copy_size = MIN(file_remains, PGSIZE);\n\nmemmove(pa, src, copy_size);\n</code></pre> <p>Similarly, uaccess uses the <code>walk</code> family (e.g., <code>walkaddr</code>) with <code>p-&gt;mm-&gt;pgt</code> to convert user VAs to PAs, enabling memory access via the PA.</p> <p>We define three primitives:</p> <pre><code>int copy_to_user(struct mm *mm, uint64 __user dstva, char *src, uint64 len);\nint copy_from_user(struct mm *mm, char *dst, uint64 __user srcva, uint64 len);\nint copystr_from_user(struct mm *mm, char *dst, uint64 __user srcva, uint64 max);\n</code></pre> <p>Assignment 2 will deepen your understanding of uaccess.</p>"},{"location":"laben/xv6lab-userspace/#lab-exercises","title":"Lab Exercises","text":"<ol> <li> <p>List the register states (including PC, only non-zero values) when the <code>init</code> process first returns to user mode.</p> <p>Hint: In <code>first_sched_ret</code>, before <code>usertrapret</code>, use <code>print_trapframe</code> to display <code>curr_proc()</code>\u2019s trapframe.</p> </li> <li> <p>In <code>user/src/init.c</code>, uncomment: <code>asm volatile(\"csrw stvec, %0\" : : \"r\"(0x80000000));</code>.</p> <p>Run the kernel with <code>make run</code>; <code>init</code> should trigger an exception and exit.</p> <p>Identify the exception triggered by <code>init</code> and explain why it occurs.</p> </li> <li> <p>Should the trapframe and trampoline pages be accessible in U-mode? Should their PTE flags in the user page table include <code>PTE_U</code>? Explain in \u226450 words.</p> <p>Hint: In <code>proc.c</code>\u2019s <code>allocproc</code>, we map these pages using <code>mm_mappageat</code>.</p> </li> </ol>"},{"location":"laben/xv6lab-userspace/#related-reading","title":"Related Reading","text":""},{"location":"laben/xv6lab-userspace/#struct-mm","title":"<code>struct mm</code>","text":"<p>The <code>struct mm</code> manages user memory space, defined in <code>vm.c</code>. (Kernel memory management is in <code>kvm.c</code>.)</p> <p><code>struct vma</code> represents a contiguous virtual address range. Each <code>struct mm</code> links multiple <code>struct vma</code> instances via <code>vma-&gt;next</code>.</p> <pre><code>struct vma {\n    struct mm* owner;\n    struct vma* next;\n    uint64 vm_start;\n    uint64 vm_end;\n    uint64 pte_flags;\n};\n\nstruct mm {\n    spinlock_t lock;\n\n    pagetable_t __kva pgt;\n    struct vma* vma;\n    int refcnt;\n};\n\n// vm.c\nvoid uvm_init();\n\npte_t* walk(struct mm* mm, uint64 va, int alloc);\nuint64 __pa walkaddr(struct mm* mm, uint64 va);\nuint64 useraddr(struct mm* mm, uint64 va);\n\nstruct mm* mm_create();\nstruct vma* mm_create_vma(struct mm* mm);\nvoid mm_free_pages(struct mm* mm);\nvoid mm_free(struct mm* mm);\nint mm_mappages(struct vma* vma);\nint mm_remap(struct vma *vma, uint64 start, uint64 end, uint64 pte_flags);\nint mm_mappageat(struct mm *mm, uint64 va, uint64 __pa pa, uint64 flags);\nint mm_copy(struct mm* old, struct mm* new);\nstruct vma* mm_find_vma(struct mm* mm, uint64 va);\n</code></pre> <p>To map user memory:</p> <ol> <li>Create a <code>struct vma</code> with <code>mm_create_vma</code>, setting <code>vma_start</code>, <code>vma_end</code>, and <code>pte_flags</code>.</li> <li>Map it with <code>mm_mappages</code>.</li> <li>Access it by converting the VA to a PA with <code>walkaddr</code>, then to a KVA with <code>PA_TO_KVA</code>.</li> </ol> <pre><code>// loader.c, load_user_elf\n\n// setup stack\nstruct vma *vma_ustack   = mm_create_vma(p-&gt;mm);\nvma_ustack-&gt;vm_start  = USTACK_START - USTACK_SIZE;\nvma_ustack-&gt;vm_end    = USTACK_START;\nvma_ustack-&gt;pte_flags = PTE_R | PTE_W | PTE_U;\nmm_mappages(vma_ustack);\n\nfor (uint64 va = vma_ustack-&gt;vm_start; va &lt; vma_ustack-&gt;vm_end; va += PGSIZE) {\n    void *__kva pa = (void *)PA_TO_KVA(walkaddr(p-&gt;mm, va));\n    memset(pa, 0, PGSIZE);\n}\n</code></pre>"},{"location":"laben/xv6lab-userspace/#mm_mappages","title":"mm_mappages","text":"<p>Prototype: <code>int mm_mappages(struct vma *vma)</code>.</p> <p>This function maps the virtual address range in <code>vma</code> within the page table <code>vma-&gt;owner-&gt;pgt</code>. Note that this page table is the user process\u2019s page table, <code>p-&gt;mm-&gt;pgt</code>.</p> <p>For each page, it allocates a physical page with <code>kallocpage()</code> and maps it.</p> <pre><code>int mm_mappages(struct vma *vma) {  // simplified\n    // sanity checking\n    struct mm *mm = vma-&gt;owner;\n    for (uint64 va = vma-&gt;vm_start; va &lt; vma-&gt;vm_end; va += PGSIZE) {\n        pte_t *pte = walk(mm, va, 1);\n        void* pa = kallocpage();\n        *pte = PA2PTE(pa) | vma-&gt;pte_flags | PTE_V;\n    }\n}\n</code></pre> <p><code>mm_mappages</code> uses <code>walk</code> to locate the PTE address in <code>mm-&gt;pgt</code> for a given VA and constructs the PTE.</p>"},{"location":"laben/xv6lab-userspace/#walk","title":"walk","text":"<p><code>walk</code> returns the PTE address in the page table for a VA. If <code>alloc</code> is set, it allocates missing intermediate page table pages.</p> <pre><code>// Return the address of the PTE in page table pagetable\n// that corresponds to virtual address va.  \n// If alloc!=0, create any required page-table pages.\npte_t *walk(struct mm *mm, uint64 va, int alloc) {\n    assert(holding(&amp;mm-&gt;lock));\n\n    pagetable_t pagetable = mm-&gt;pgt;\n\n    if (!IS_USER_VA(va))\n        return NULL;\n\n    for (int level = 2; level &gt; 0; level--) {\n        pte_t *pte = &amp;pagetable[PX(level, va)];\n        if (*pte &amp; PTE_V) {\n            pagetable = (pagetable_t)PA_TO_KVA(PTE2PA(*pte));\n        } else {\n            if (!alloc)\n                return 0;\n            void *pa = kallocpage();\n            if (!pa)\n                return 0;\n            pagetable = (pagetable_t)PA_TO_KVA(pa);\n            memset(pagetable, 0, PGSIZE);\n            *pte = PA2PTE(KVA_TO_PA(pagetable)) | PTE_V;\n        }\n    }\n    return &amp;pagetable[PX(0, va)];\n}\n</code></pre>"},{"location":"laben/xv6lab-userspace/#program-loading","title":"Program Loading","text":"<p><code>load_user_elf</code> in <code>loader.c</code> loads an ELF file into userspace. It processes each <code>PT_LOAD</code> segment based on its program header:</p> <ul> <li><code>p_vaddr</code>: Target virtual address.</li> <li><code>p_paddr</code>: Target physical address (ignored for userspace; pages are dynamically allocated).</li> <li><code>p_memsz</code>: Memory size of the segment.</li> <li><code>p_filesz</code>: File size of the segment.</li> <li><code>p_offset</code>: Offset in the ELF file.</li> <li><code>p_flags</code>: Segment permissions.</li> </ul> <p>Here\u2019s the program header for <code>init</code>:</p> <pre><code>Elf file type is EXEC (Executable file)\nEntry point 0x402400\nThere are 4 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n  ATTRIBUTES     0x0074ed 0x0000000000000000 0x0000000000000000 0x000061 0x000000 R   0x1\n  LOAD           0x001000 0x0000000000402000 0x0000000000402000 0x000f30 0x000f30 R E 0x1000\n  LOAD           0x002000 0x0000000000403000 0x0000000000403000 0x0000b9 0x0000b9 R   0x1000\n  LOAD           0x003000 0x0000000000404000 0x0000000000404000 0x000028 0x000440 RW  0x1000\n</code></pre> <p>How the Kernel Locates User ELF Files</p> <p>User programs reside in <code>user/</code>. <code>make user</code> compiles them, with outputs in <code>user/build/stripped/</code>.</p> <p>The kernel\u2019s Makefile invokes <code>scripts/pack.py</code> to generate <code>link_app.S</code>, embedding all user ELFs into the kernel image\u2019s rodata section.</p>"},{"location":"qrh/csr/","title":"\u4ec0\u4e48\u662f CSR","text":"<p>CSR \u5b9a\u4e49</p> <p>CSR Field Specifications: </p> <ul> <li>WPRI</li> <li>WLRL</li> <li>WARL</li> </ul>"},{"location":"qrh/gdb/","title":"GDB","text":""},{"location":"qrh/git/","title":"Git","text":"<p>\u50cf Git \u8fd9\u6837\u7684\u7248\u672c\u63a7\u5236\u7cfb\u7edf\u663e\u7740\u5f71\u54cd\u4e86\u73b0\u4ee3\u8f6f\u4ef6\u5f00\u53d1\uff0c\u8fd9\u9700\u8981\u5408\u4f5c\u548c\u5feb\u901f\u8fed\u4ee3\u3002 \u4f60\u4eec\u5e94\u8be5\u5728\u6b64\u524d\u7684\u8bf8\u591a\u8bfe\u7a0b\u4e2d\u4e0e Git \u4ea4\u624b\u8fc7\uff0c\u5728\u63a5\u4e0b\u6765\u7684\u5b9e\u9a8c\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u4f7f\u7528 GitLab\u3002</p>"},{"location":"qrh/nav/","title":"\u5feb\u901f\u53c2\u8003\u624b\u518c","text":"<p>\u672c\u624b\u518c\u4f1a\u8bb0\u5f55\u4f60\u5728\u8fdb\u884c\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u9a8c\u4e2d\u53ef\u80fd\u4f1a\u9047\u5230\u7684\u95ee\u9898\uff0c\u6216\u8005\u9700\u8981\u5b66\u4e60\u7684\u524d\u7f6e\u77e5\u8bc6</p> <ul> <li>GDB \u6559\u7a0b</li> <li>Git \u6559\u7a0b</li> </ul>"},{"location":"qrh/ssh-vscode/","title":"SSH & VSCode \u8fdc\u7a0b\u914d\u7f6e","text":""},{"location":"qrh/ssh-vscode/#ssh","title":"\u865a\u62df\u673a SSH \u914d\u7f6e","text":"<p>SSH \u662f\u4e00\u79cd\u5b89\u5168\u7684\u8fdc\u7a0b\u767b\u9646\u670d\u52a1\u5668\u7684\u65b9\u5f0f\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u7528\u9014\uff1a</p> <ol> <li>\u8fdc\u7a0b\u767b\u9646\uff0c\u6253\u5f00\u4e00\u4e2a Shell</li> <li>\u4f7f\u7528 <code>scp</code> \u8fdb\u884c\u6587\u4ef6\u4f20\u8f93</li> <li>\u7aef\u53e3\u8f6c\u53d1</li> </ol> <p>\u6211\u4eec\u53ef\u4ee5\u5728\u7269\u7406\u673a\u4e0a\u4f7f\u7528 SSH \u8fde\u63a5\u5230\u865a\u62df\u673a\u5185\u90e8\uff0c\u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u5728\u5bbf\u4e3b\u673a\u7684\u684c\u9762\u73af\u5883\u4e2d\u4f7f\u7528\u865a\u62df\u673a\u3002</p>"},{"location":"qrh/ssh-vscode/#openssh-server","title":"\u5b89\u88c5 openssh-server","text":"<p>\u5728\u7ec8\u7aef\u4e2d\u8f93\u5165\uff1a<code>sudo apt install openssh-server</code></p> <p></p> <p>\u8f93\u5165 y \u56de\u8f66\u786e\u5b9a</p>"},{"location":"qrh/ssh-vscode/#ip","title":"\u67e5\u770b\u865a\u62df\u673a ip \u5730\u5740","text":"<p>\u5728\u7ec8\u7aef\u4e2d\u8f93\u5165\uff1a<code>ip a</code>\uff1a</p> <p></p> <p>\u67d0\u4e2a\u4ee5 <code>ens</code> \u6216 <code>enp</code> \u6216 <code>eth</code> \u5f00\u5934\u7684\u7f51\u5361\u4e0b\u9762\uff0cinet \u540e\u9762\u8ddf\u7684\u5730\u5740\u5373\u662fvm\u7684ip\u5730\u5740\u3002</p>"},{"location":"qrh/ssh-vscode/#ssh_1","title":"SSH \u767b\u9646","text":"<p>\u5728\u4f60\u7684\u7269\u7406\u673a\u4e0a\uff1a</p> <ul> <li> <p>Windows \u7528\u6237\uff1a\u6253\u5f00 Windows Terminal\uff0c\u8fdb\u5165 PowerShell</p> </li> <li> <p>macOS \u7528\u6237\uff1a\u6253\u5f00\u7ec8\u7aef (Terminal)</p> </li> </ul> <p>\u8f93\u5165 <code>ssh oslab@vm\u7684ip</code>\uff1a</p> <p></p> <p>\u9996\u6b21\u767b\u9646\u4f1a\u9700\u8981\u786e\u8ba4\u516c\u94a5\uff0c\u8f93\u5165y\u56de\u8f66\u786e\u8ba4\u5373\u53ef\u3002</p> <p>\u6211\u4eec\u5148\u4f7f\u7528\u5bc6\u7801\u767b\u9646\uff0coslab\u7684\u9ed8\u8ba4\u5bc6\u7801\u662f 123456\u3002</p>"},{"location":"qrh/ssh-vscode/#ssh_2","title":"\u8bbe\u7f6e SSH \u5bc6\u94a5\u767b\u9646","text":"<p>SSH \u5bc6\u94a5\u662f\u4e00\u5bf9\u975e\u5bf9\u79f0\u52a0\u5bc6\u7684\u5bc6\u94a5\uff0c\u5206\u4e3a\u516c\u94a5\u548c\u79c1\u94a5\u3002</p> <p>\u79c1\u94a5\u662f\u4fdd\u5bc6\u7684\uff0c\u9ed8\u8ba4\u5b58\u50a8\u5728 <code>$USER/.ssh/</code> \u76ee\u5f55\u4e0b\uff0c\u4ee5 <code>id_</code> \u5f00\u5934\u3002\u516c\u94a5\u662f\u53ef\u4ee5\u516c\u5f00\u7684\uff0c\u6587\u4ef6\u540d\u901a\u5e38\u662f <code>id_xxx.pub</code> \uff0c\u6211\u4eec\u5c06\u628a\u5b83\u653e\u5230\u865a\u62df\u673a\u91cc\u9762\uff0c\u8868\u793a\u865a\u62df\u673a\u5c06\u5141\u8bb8\u4f7f\u7528\u8be5\u79c1\u94a5\u767b\u9646\u3002</p> <p>\u5728\u7269\u7406\u673a\u7684\u7ec8\u7aef\u4e0a\u8f93\u5165 <code>ssh-keygen</code> \u8fd9\u5c06\u751f\u6210\u4e00\u5bf9\u516c\u79c1\u94a5\u5bf9\u3002</p> <p></p> <p>\u8f93\u5165 <code>cat ~/.ssh/id_ed25519.pub</code> \uff0c\u663e\u793a\u5176\u5185\u5bb9\uff1a</p> <p></p> <p>\u5728\u865a\u62df\u673a\u4e2d \uff1a<code>vim ~/.ssh/authorized_keys</code></p> <p></p> <p>\u6309 i \u8fdb\u5165 insert mode\uff0c\u53f3\u952e\u7c98\u8d34\u3002</p> <p></p> <p>\u6309 ESC \u9000\u51fa insert mode\uff0c\u8f93\u5165 <code>:wq</code> \u4fdd\u5b58\u5e76\u9000\u51fa\u3002</p> <p></p> <p>\u4e4b\u540e\u6211\u4eec\u5728\u7269\u7406\u673a\u4e0a\u4f7f\u7528 ssh \u767b\u9646\u4e0d\u518d\u9700\u8981\u5bc6\u7801\u3002</p>"},{"location":"qrh/ssh-vscode/#scp","title":"scp \u62f7\u8d1d\u6587\u4ef6","text":"<p>\u8bf7\u67e5\u9605 <code>man scp</code>\u3002</p> <p>scp \u547d\u4ee4\u7684\u4e3b\u8981\u683c\u5f0f\u4e3a\uff1a<code>scp [OPTIONS] source ... target</code></p> <p>\u5982\u679c source \u6216 target \u662f SSH \u76ee\u6807\uff0c\u5219\u4f7f\u7528 <code>user@host:file_path</code> \u7684\u683c\u5f0f\u6307\u5b9a\u8fdc\u7a0b\u76ee\u6807\u4e0a\u7684\u6587\u4ef6\u8def\u5f84</p> <p>\u4f8b\u5982 <code>scp -r oslab@192.168.231.128:~/Desktop/SUSTechOS ~/Desktop</code> \u662f\u5c06\u8fdc\u7a0b\u670d\u52a1\u5668\u4e0a\u9762\u7684 <code>~/Desktop/SUSTechOS</code> \u76ee\u5f55\u6574\u4e2a\u590d\u5236\u5230\u5bbf\u4e3b\u673a\u7684\u684c\u9762\u4e0a\u3002</p> <p></p>"},{"location":"qrh/ssh-vscode/#vscode-ssh","title":"vscode SSH \u63d2\u4ef6","text":"<p>\u5728 VSCode \u4e2d\u5b89\u88c5\u8fd9\u4e2a\u63d2\u4ef6\uff1a</p> <p></p> <p>\u4f7f\u7528 Ctrl + Shift + P \u6253\u5f00\u547d\u4ee4\u7a97\u53e3\uff0c\u5728 <code>&gt;</code> \u63d0\u793a\u7b26\u540e\u9762\u8f93\u5165 ssh</p> <p></p> <p>\u9009\u62e9 <code>Remote-SSH: Connect to Host</code> \u56de\u8f66\u786e\u8ba4</p> <p></p> <p>\u8f93\u5165 <code>oslab@ip\u5730\u5740</code>\uff0c\u5e76\u4fdd\u5b58\u914d\u7f6e\uff0c\u7b2c\u4e00\u6b21\u8fde\u63a5\u4f1a\u9009\u62e9\u8fdc\u7a0b\u670d\u52a1\u5668\u73af\u5883\uff0c\u9009\u62e9 Linux\u3002</p> <p>\u914d\u7f6e\u5b8c\u6210\u540e\uff0c\u53ef\u4ee5\u5728 VSCode \u4e2d\u6253\u5f00 SSH \u76ee\u6807\u4e0a\u7684 Workspace\u3002</p> <p>\u4f8b\u5982\uff0c\u6211\u4eec\u6253\u5f00 <code>~/Desktop/SUSTechOS</code>\uff0c\u5373\u53ef\u5728\u5bbf\u4e3b\u673a\u4e0a\u7f16\u8f91\u6211\u4eec\u7684\u5185\u6838\u4ee3\u7801\uff0c\u5e76\u5728vscode \u7684 terminal \u7a97\u53e3\u4e2d\u4f7f\u7528 <code>make run</code>\u8fd0\u884c\u3002</p> <p></p>"},{"location":"qrh/vf2/","title":"VisionFive2 \u677f\u5b50\u6559\u7a0b","text":""},{"location":"qrh/vf2/#visionfive2","title":"VisionFive2 \u5f00\u53d1\u677f\u4f7f\u7528\u6559\u7a0b","text":"<p>\u6211\u4eec\u4f1a\u53d1\u4ee5\u4e0b\u6750\u6599\uff0c\u8bf7\u6838\u5bf9\u6e05\u5355\uff1a</p> <ul> <li>VisionFive 2 \u5f00\u53d1\u677f</li> <li>nanoDAP \u8c03\u8bd5\u5668</li> <li>\u675c\u90a6\u7ebf\u82e5\u5e72\uff0810\u6839\u4ee5\u4e0a\uff09</li> <li>\u4e00\u5f20 32G SD\u5361</li> <li>\u4e00\u4e2a\u8bfb\u5361\u5668</li> </ul> <p>\u8bf7\u4f60\u81ea\u884c\u51c6\u5907\u4e00\u4e2a\u624b\u673a\u5145\u7535\u5668\u5934\uff0c\u548c Type-C \u7ebf\u3002</p> <p>\u62c6\u5f00\u5305\u88c5\u540e\uff0c\u8bf7\u4f60\u5c06\u4e00\u4e0b\u5185\u5bb9\u7269\u4ea4\u8fd8\u5230\u8bb2\u53f0\uff1a</p> <ul> <li>\u5199\u6709 \u201c\u6609\u00b7\u661f\u5149 VisionFive 2\u201d \u7684\u7eb8\u58f3</li> <li>\u9ed1\u8272\u9759\u7535\u888b</li> <li>\u4e00\u5305\u88c5\u6709\u5851\u6599\u87ba\u4e1d\u811a\u57ab\u7684\u888b\u5b50</li> <li>\uff08\u5982\u6709\uff09\u4e00\u4e2a\u7528\u888b\u5b50\u88c5\u7740\u7684 USB \u7f51\u5361</li> </ul> <p>\u5176\u4f59\u5783\u573e\u8bf7\u8bfe\u540e\u81ea\u884c\u5904\u7406\u3002</p> <p></p>"},{"location":"qrh/vf2/#_1","title":"\u5b89\u88c5\u5de5\u5177","text":"<p>\u5728 VM \u4e2d\uff1a<code>sudo apt install minicom</code> \u5b89\u88c5\u4e32\u53e3\u5de5\u5177 minicom\u3002</p> <p></p>"},{"location":"qrh/vf2/#uart","title":"\u8fde\u63a5 UART \u63a5\u53e3","text":"<p>\u4f7f\u7528 \u4e09\u6839 \u675c\u90a6\u7ebf\u8fde\u63a5\u677f\u5b50\u4e0a\u7684 GND, UART TX, UART RX \u7aef\u53e3\u3002</p> <p>\u7528\u53f3\u4e0a\u89d2\u7684 Pin 6, 8, 10\u3002 \u6ce8\u610f\u4e0d\u8981\u8fde\u63a5\u5230 5V Power \u4e0a\u9762\uff01\uff01</p> <p></p> <p>\u5b9e\u62cd\u56fe\uff1a</p> <p></p> <p>\u5c06\u677f\u5b50\u4e0a\u7684 GND, UART TX, UART RX \u5206\u522b\u8fde\u63a5\u5230\u8c03\u8bd5\u5668\u4e0a\u7684 GND, U_RX, U_TX \u4e0a\u9762\uff0c\u6ce8\u610f UART \u7684 RX \u548c TX \u662f\u4ea4\u53c9\u7684\uff0c\u8c03\u8bd5\u5668\u6b63\u53cd\u9762\u90fd\u6709\u7aef\u53e3\u63d0\u793a\u3002</p> <p></p> <p>\u4e0d\u8981\u63a5\u8c03\u8bd5\u5668\u4e0a\u9762\u7684 5V \u548c 3V3 \uff01\uff01\uff01\uff01 \u4e5f\u4e0d\u8981\u8bd5\u56fe\u901a\u8fc7\u8c03\u8bd5\u5668\u7ed9 VisionFive2 \u677f\u5b50\u4f9b\u7535\uff01\uff01</p>"},{"location":"qrh/vf2/#vm","title":"\u8fde\u63a5\u5230 VM","text":"<p>\u542f\u52a8 VMware \u4e2d\u7684\u865a\u62df\u673a\u3002</p> <p>\u5c06\u8c03\u8bd5\u5668\u63d2\u5165\u7535\u8111USB\u53e3\uff08macOS \u7528\u6237\u8bf7\u81ea\u5907 Type-C \u5230 USB-A \u8f6c\u63a5\u5668\uff09\uff0c\u4f60\u5e94\u8be5\u4f1a\u6536\u5230\u4ee5\u4e0b\u63d0\u793a\u3002</p> <p></p> <p>\u9009\u62e9 <code>Conenct to a virtual machine</code>\u3002\u5c06\u8c03\u8bd5\u5668\u8fde\u63a5\u81f3\u865a\u62df\u673a\u4e2d\u3002\u5982\u679c\u4f60\u6ca1\u6709\u770b\u5230\u8fd9\u4e2a\u7a97\u53e3\u6216\u9519\u8fc7\u4e86\uff0c\u4f60\u53ef\u4ee5\u5728\u83dc\u5355\u680f\u4e2d\u9009\u62e9 <code>VM -&gt; Removable Devices -&gt; NXP DAPLink CMSIS-DAP -&gt; Connect (Disconnect from Host)</code>\u3002</p> <p></p> <p>\u5728\u865a\u62df\u673a\u7684\u7ec8\u7aef\u4e2d\uff0c\u6267\u884c <code>lsusb</code>\uff0c\u4f60\u5e94\u8be5\u80fd\u770b\u5230\u4e00\u9879 \"NXP ARM mbed\" \u7684\u9879\u76ee\uff0c\u5982\u679c\u770b\u4e0d\u5230\uff0c\u8bf7\u62a5\u544a\u52a9\u6559\u3002</p> <p></p> <p>\u5728\u7ec8\u7aef\u4e2d\u6267\u884c\uff1a<code>ls /dev/tty*</code> \u4f60\u5e94\u8be5\u80fd\u770b\u5230\u4e00\u9879\u4e3a <code>/dev/ttyACM0</code> \uff0c\u8fd9\u5c31\u662f\u4e32\u53e3\u8bbe\u5907\u3002\u5982\u679c\u770b\u4e0d\u5230\uff0c\u8bf7\u62a5\u544a\u52a9\u6559\u3002</p> <p>\u5728\u7ec8\u7aef\u4e2d\u6267\u884c\uff1a<code>sudo usermod -aG dialout oslab</code>\uff0c\u8f93\u5165\u5bc6\u7801\u786e\u8ba4\u540e\u91cd\u542f\u865a\u62df\u673a\u3002</p> <p>\u91cd\u542f\u540e\uff0c\u5728\u7ec8\u7aef\u4e2d\u6267\u884c\uff1a<code>id</code>\uff0c\u4f60\u5e94\u8be5\u4f1a\u770b\u5230 gid \u540e\u9762\u6709\u4e00\u9879 dialout\u3002</p> <p></p> <p>\u5728\u7ec8\u7aef\u4e2d\u6267\u884c <code>sudo minicom -s</code> \u8bbe\u7f6e minicom \u5de5\u5177\uff0c\u4f60\u4f1a\u8fdb\u5165\u5982\u4e0b\u754c\u9762\uff0c\u4f7f\u7528\u4e0a\u4e0b\u5de6\u53f3\u3001ESC\u3001Enter\u8fdb\u884c\u79fb\u52a8\u3002</p> <p></p> <p>\u8fdb\u5165 <code>Serial port setup</code>\uff0c\u6309 A \u7f16\u8f91 <code>Serial Device</code> \u8fd9\u4e00\u9879\uff0c\u5c06\u5176\u6539\u4e3a <code>/dev/ttyACM0</code></p> <p></p> <p>\u56de\u8f66\u786e\u8ba4\u4e24\u6b21\uff0c\u56de\u5230 <code>configuration</code> \u754c\u9762\uff0c\u9009\u62e9 <code>Save setup as dfl</code> \u56de\u8f66\u786e\u8ba4\uff0c\u4f60\u5e94\u8be5\u80fd\u770b\u5230 <code>Configuration Saved</code> \u63d0\u793a\u3002</p> <p>\u9009\u62e9 Exit \u9000\u51fa\u914d\u7f6e\u9875\u9762\uff0c\u8fdb\u5165 minicom \u7ec8\u7aef\uff0c\u4f7f\u7528 Ctrl A + X \u9000\u51fa minicom\u3002</p> <p></p> <p>\u4f7f\u7528\u666e\u901a\u7528\u6237 oslab \u6267\u884c minicom\uff0c\u4f60\u5e94\u8be5\u80fd\u6b63\u5e38\u6253\u5f00\u4e32\u53e3\u3002</p> <p></p>"},{"location":"qrh/vf2/#_2","title":"\u677f\u5b50\u4e0a\u7535","text":"<p>\u5728\u6253\u5f00 minicom \u7684\u60c5\u51b5\u4e0b\uff0c\u7528 Type-C \u53e3\u7ed9\u677f\u5b50\u4f9b\u7535\u3002</p> <p>\u4f60\u5e94\u8be5\u80fd\u770b\u5230\u677f\u5b50 Type-C \u63a5\u53e3\u65c1\u8fb9\u6709\u4e00\u4e2a\u7ea2\u8272 LED \u4eae\u8d77\uff0c\u540c\u65f6\u4e32\u53e3\u754c\u9762\u6709\u663e\u793a\u3001\u8c03\u8bd5\u5668\u4e0a\u95ea\u70c1\u7eff\u706f\uff1a</p> <pre><code>U-Boot SPL 2025.01-dirty (Feb 21 2025 - 21:15:06 +0800)\nDDR version: dc2e84f0.\nTrying to boot from SPI\n\nOpenSBI v1.5.1\n   ____                    _____ ____ _____\n  / __ \\                  / ____|  _ \\_   _|\n | |  | |_ __   ___ _ __ | (___ | |_) || |\n | |  | | '_ \\ / _ \\ '_ \\ \\___ \\|  _ &lt; | |\n | |__| | |_) |  __/ | | |____) | |_) || |_\n  \\____/| .__/ \\___|_| |_|_____/|____/_____|\n        | |\n        |_|\n\nPlatform Name             : StarFive VisionFive 2 v1.3B                         \nPlatform Features         : medeleg                                             \n...\n\nU-Boot 2025.01-dirty (Feb 21 2025 - 21:15:06 +0800)                             \n\nCPU:   sifive,u74-mc                                                            \nModel: StarFive VisionFive 2 v1.3B                                              \nDRAM:  4 GiB                                                                    \nCore:  136 devices, 26 uclasses, devicetree: board                              \nWDT:   Not starting watchdog@13070000                                           \nMMC:   mmc@16010000: 0, mmc@16020000: 1\n\nStarFive EEPROM format v2                                                             \n\n--------EEPROM INFO--------                                                           \nVendor : StarFive Technology Co., Ltd.                                                \nProduct full SN: VF7110B1-2253-D004E000-40000798                                      \ndata version: 0x2                                                                     \nPCB revision: 0xb2                                                                    \nBOM revision: A                                                                       \nEthernet MAC0 address: 6c:cf:39:00:6c:bc                                              \nEthernet MAC1 address: 6c:cf:39:00:6c:bd                                              \n--------EEPROM INFO--------                                                           \n..\n\nStarFive #\n</code></pre> <p>\u53ef\u4ee5\u770b\u5230 OpenSBI \u52a0\u8f7d\u548c U-Boot \u52a0\u8f7d\uff0c\u6700\u540e\u6709\u4e00\u4e2a <code>StarFive #</code> \u7684\u547d\u4ee4\u63d0\u793a\u7b26\uff0c\u6211\u4eec\u5c06\u5176\u79f0\u4e3a uboot \u7ec8\u7aef\u3002</p> <p>.</p>"},{"location":"qrh/vf2/#xv6","title":"\u8fd0\u884c xv6 \u5185\u6838","text":"<p>\u5728 minicom \u4e0b\uff0c\u677f\u5b50\u542f\u52a8\u5b8c\u6210\u540e\uff0c\u51fa\u73b0 uboot \u7ec8\u7aef</p> <p>\u4f7f\u7528\u53e6\u4e00\u4e2a\u7ec8\u7aef\u7a97\u53e3\uff0ccd \u5230\u5185\u6838\u4ee3\u7801\u76ee\u5f55\u4e0b\uff0c<code>make</code> \u7f16\u8bd1\u5185\u6838\uff0c\u7136\u540e cd \u5230 <code>build</code> \u76ee\u5f55\u4e0b\uff1a</p> <p></p> <p>\u6267\u884c pwd \u4ee5\u83b7\u53d6\u5f53\u524d\u76ee\u5f55\u7684\u5b8c\u6574\u8def\u5f84\uff0c\u53f3\u952e\u62f7\u8d1d\u3002</p> <p>\u5728 uboot \u7ec8\u7aef\u4e0b\u6267\u884c\uff1a<code>loadx</code>\uff1a</p> <p></p> <p>\u6309 Ctrl A + S\uff0c\u6253\u5f00 <code>[Upload]</code> \u63d0\u793a\u6846\uff0c</p> <p></p> <p>\u9009\u62e9 <code>xmodem</code>\uff0c\u5207\u6362\u5230 <code>[Goto]</code>\uff0c\u7136\u540e\u56de\u8f66\uff0c\u5728 <code>Goto directory</code> \u4e0b\u9762\u7c98\u8d34\u6211\u4eec\u4e4b\u524d\u590d\u5236\u7684 build \u76ee\u5f55\u7684\u5b8c\u6574\u8def\u5f84\uff0c\u56de\u8f66\u786e\u8ba4\u3002</p> <p></p> <p>\u5de6\u53f3\u79fb\u52a8\u5149\u6807\u5230 <code>[Okay]</code>\uff0c\u4e0a\u4e0b\u79fb\u52a8\u5149\u6807\u5230 <code>kernel</code> \u8fd9\u4e00\u9879\uff0c\u7136\u540e\u7a7a\u683c\u9009\u4e2d\uff0c</p> <p></p> <p>\u7136\u540e\u56de\u8f66\u786e\u8ba4\uff0c\u5f00\u59cb\u4e0a\u4f20\u3002</p> <p></p> <p>\u4e0a\u4f20\u7ed3\u675f\u540e\uff0c<code>[xmodem upload]</code> \u7a97\u53e3\u6d88\u5931\uff0cuboot\u7ec8\u7aef\u4e0b\u4f1a\u63d0\u793a <code>##Total Size</code> \u548c <code>## Start Addr</code>\u3002</p> <p></p> <p>\u6267\u884c\u547d\u4ee4 <code>bootelf -p</code>\uff0c\u7136\u540e\u6267\u884c <code>go 0x80200000</code></p> <p>uboot \u7ec8\u7aef\u5e94\u8be5\u4f1a\u63d0\u793a <code>## Starting application at 0x80200000 ...</code>\uff0c\u7136\u540e\u8df3\u8f6c\u5230\u6211\u4eec\u7684\u5185\u6838\uff0c\u6700\u7ec8 sh \u542f\u52a8\u6210\u529f\u3002</p> <p></p>"}]}