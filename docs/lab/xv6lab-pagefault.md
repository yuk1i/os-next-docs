# Page Fault

## Demand Paging

在现代操作系统中， **需求分页（Demand Paging）** 是一种内存管理策略，它只有在程序访问某一内存页时才将该页加载到内存。与传统的将整个程序的所有页一次性加载到内存的策略不同，需求分页可以更有效地利用内存资源，避免浪费。

在当前的 xv6 中，每个用户进程的栈分配了 8 个物理页面。我们要思考一个问题：用户进程真的会使用到所有 8 个页面吗？
栈是从高地址向低地址生长的，因此程序在运行时栈会逐渐扩展。这种动态扩展意味着在进程的初期，它可能并不会使用到所有分配的栈空间。这样，一开始就为栈分配大量内存，可能会造成资源浪费。

所以，在分配栈的时候，我们可以先只分配 2 个物理页面，等 **用户进程需要剩下的页面时，我们再进行分配物理页面** 。
当用户进程真正用得到时，它会向该地址（虚拟地址）发起内存访问，CPU 会发现在页表中这个地址没有被映射，则会发起 Page Fault 异常。

但是，内核是向用户进程分配了这个虚拟地址的。内核收到来自用户进程的 Page Fault，表示用户进程的确用到了这个页面。所以，我们可以在 Page Fault 中实际分配该物理页面，在填充页表后重新返回到发生 Page Fault 的指令处重新执行。而这时，CPU 会认为这个虚拟地址是合法的了。在用户进程看起来，它只是执行的时候被暂停了一下，这对于用户进程而言是无感知的。

## Swap

